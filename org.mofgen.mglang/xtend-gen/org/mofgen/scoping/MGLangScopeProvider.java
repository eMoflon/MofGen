/**
 * generated by Xtext 2.20.0
 */
package org.mofgen.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.Case;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.Parameter;
import org.mofgen.mGLang.ParameterNode;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.RefOrCall;
import org.mofgen.mGLang.RefType;
import org.mofgen.scoping.AbstractMGLangScopeProvider;
import org.mofgen.utils.MofgenModelUtils;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MGLangScopeProvider extends AbstractMGLangScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    boolean _isNodeCreation = this.isNodeCreation(context, reference);
    if (_isNodeCreation) {
      return this.getScopeForNodeCreationType(((Node) context));
    }
    boolean _isReferenceType = this.isReferenceType(context, reference);
    if (_isReferenceType) {
      return this.getScopeForReferenceType(((PatternNodeReference) context));
    }
    boolean _isReferenceTarget = this.isReferenceTarget(context, reference);
    if (_isReferenceTarget) {
      return this.getScopeForReferenceTarget(((PatternNodeReference) context));
    }
    boolean _isNodeAttributeAssignmentType = this.isNodeAttributeAssignmentType(context, reference);
    if (_isNodeAttributeAssignmentType) {
      return this.getScopeForNodeAssignmentType(((Assignment) context));
    }
    boolean _isRefOrCallRef = this.isRefOrCallRef(context, reference);
    if (_isRefOrCallRef) {
      return this.getScopeForRefOrCallRef(((RefOrCall) context));
    }
    boolean _isRefOrCallCalled = this.isRefOrCallCalled(context, reference);
    if (_isRefOrCallCalled) {
      return this.getScopeForRefOrCallCalled(((RefOrCall) context));
    }
    return super.getScope(context, reference);
  }
  
  public IScope getScopeForNodeCreationType(final Node n) {
    final MofgenFile file = this.getRootFile(n);
    final ArrayList<EClass> classes = MofgenModelUtils.getClasses(file);
    return Scopes.scopeFor(classes);
  }
  
  public IScope getScopeForReferenceType(final PatternNodeReference ref) {
    final MofgenFile file = this.getRootFile(ref);
    final Node src = EcoreUtil2.<Node>getContainerOfType(ref, Node.class);
    final ArrayList<EClass> classes = MofgenModelUtils.getClasses(file);
    final Function1<EClass, Boolean> _function = (EClass c) -> {
      EClass _type = src.getType();
      return Boolean.valueOf(Objects.equal(c, _type));
    };
    final Iterable<EClass> filteredClasses = IterableExtensions.<EClass>filter(classes, _function);
    boolean _isEmpty = IterableExtensions.isEmpty(filteredClasses);
    if (_isEmpty) {
      return IScope.NULLSCOPE;
    } else {
      return Scopes.scopeFor((((EClass[])Conversions.unwrapArray(filteredClasses, EClass.class))[0]).getEAllReferences());
    }
  }
  
  public IScope getScopeForAllNodes(final EObject context) {
    final MofgenFile root = this.getRootFile(context);
    final List<Node> allNodes = EcoreUtil2.<Node>getAllContentsOfType(root, Node.class);
    return Scopes.scopeFor(allNodes);
  }
  
  public IScope getScopeForReferenceTarget(final PatternNodeReference ref) {
    return this.getScopeForAllNodes(ref);
  }
  
  public IScope getScopeForNodeAssignmentType(final Assignment ass) {
    final Node srcNode = EcoreUtil2.<Node>getContainerOfType(ass, Node.class);
    final MofgenFile file = this.getRootFile(ass);
    final ArrayList<EClass> clazzez = MofgenModelUtils.getClasses(file);
    try {
      final Function1<EClass, Boolean> _function = (EClass c) -> {
        EClass _type = srcNode.getType();
        return Boolean.valueOf(Objects.equal(c, _type));
      };
      final Iterable<EClass> filteredClazzez = IterableExtensions.<EClass>filter(clazzez, _function);
      boolean _isEmpty = IterableExtensions.isEmpty(filteredClazzez);
      if (_isEmpty) {
        return IScope.NULLSCOPE;
      } else {
        return Scopes.scopeFor((((EClass[])Conversions.unwrapArray(filteredClazzez, EClass.class))[0]).getEAllAttributes());
      }
    } catch (final Throwable _t) {
      if (_t instanceof NullPointerException) {
        return IScope.NULLSCOPE;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public IScope getScopeForRefOrCallRef(final RefOrCall r) {
    final Pattern pattern = EcoreUtil2.<Pattern>getContainerOfType(r, Pattern.class);
    final EList<Parameter> params = pattern.getParameters();
    final EList<Node> patternNodes = pattern.getNodes();
    final Iterable<Node> shadowingNodes = this.getEventuallyShadowingNodes(r);
    final ArrayList<Integer> indicesToRemove = CollectionLiterals.<Integer>newArrayList();
    for (final Node pNode : patternNodes) {
      for (final Node node : shadowingNodes) {
        boolean _equals = node.getName().equals(pNode.getName());
        if (_equals) {
          indicesToRemove.add(Integer.valueOf(patternNodes.indexOf(pNode)));
        }
      }
    }
    List<Integer> _reverse = ListExtensions.<Integer>reverse(indicesToRemove);
    for (final Integer index : _reverse) {
      patternNodes.remove(index);
    }
    Iterable<RefType> _plus = Iterables.<RefType>concat(params, patternNodes);
    return Scopes.scopeFor(_plus);
  }
  
  public Iterable<Node> getEventuallyShadowingNodes(final EObject obj) {
    final Iterable<Case> parentCases = Iterables.<Case>filter(EcoreUtil2.getAllContainers(obj), Case.class);
    final Function1<Case, Node> _function = (Case c) -> {
      return c.getNode();
    };
    return IterableExtensions.<Case, Node>map(parentCases, _function);
  }
  
  public IScope getScopeForRefOrCallCalled(final RefOrCall r) {
    RefOrCall _target = r.getTarget();
    boolean _tripleEquals = (_target == null);
    if (_tripleEquals) {
      EClass _eClass = r.getRef().eClass();
      boolean _matched = false;
      if (Objects.equal(_eClass, Node.class)) {
        _matched=true;
        RefType _ref = r.getRef();
        final EClass type = ((Node) _ref).getType();
        final EClass clazz = ((EClass) type);
        final EList<EOperation> ops = clazz.getEAllOperations();
        final EList<EAttribute> attrs = clazz.getEAllAttributes();
        final EList<EReference> refs = clazz.getEReferences();
        Iterable<ETypedElement> _plus = Iterables.<ETypedElement>concat(ops, attrs);
        Iterable<ETypedElement> _plus_1 = Iterables.<ETypedElement>concat(_plus, refs);
        return Scopes.scopeFor(_plus_1);
      }
      if (!_matched) {
        if (Objects.equal(_eClass, ParameterNode.class)) {
          _matched=true;
          RefType _ref_1 = r.getRef();
          final EClassifier type_1 = ((ParameterNode) _ref_1).getType();
          if ((type_1 instanceof EClass)) {
            final EClass clazz_1 = ((EClass) type_1);
            final EList<EOperation> ops_1 = clazz_1.getEAllOperations();
            final EList<EAttribute> attrs_1 = clazz_1.getEAllAttributes();
            final EList<EReference> refs_1 = clazz_1.getEReferences();
            Iterable<ETypedElement> _plus_2 = Iterables.<ETypedElement>concat(ops_1, attrs_1);
            Iterable<ETypedElement> _plus_3 = Iterables.<ETypedElement>concat(_plus_2, refs_1);
            return Scopes.scopeFor(_plus_3);
          }
        }
      }
    } else {
      final EClassifier type_2 = r.getCalled().getEType();
      if ((type_2 instanceof EClass)) {
        final EClass clazz_2 = ((EClass) type_2);
        final EList<EOperation> ops_2 = clazz_2.getEAllOperations();
        final EList<EAttribute> attrs_2 = clazz_2.getEAllAttributes();
        final EList<EReference> refs_2 = clazz_2.getEReferences();
        Iterable<ETypedElement> _plus_4 = Iterables.<ETypedElement>concat(ops_2, attrs_2);
        Iterable<ETypedElement> _plus_5 = Iterables.<ETypedElement>concat(_plus_4, refs_2);
        return Scopes.scopeFor(_plus_5);
      }
    }
    return IScope.NULLSCOPE;
  }
  
  public boolean isReferenceType(final EObject context, final EReference reference) {
    return ((context instanceof PatternNodeReference) && 
      Objects.equal(reference, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
  }
  
  public boolean isReferenceTarget(final EObject context, final EReference reference) {
    return ((context instanceof PatternNodeReference) && 
      Objects.equal(reference, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
  }
  
  public boolean isNodeCreation(final EObject context, final EReference reference) {
    return ((context instanceof Node) && Objects.equal(reference, MGLangPackage.Literals.NODE__TYPE));
  }
  
  public boolean isNodeAttributeAssignmentType(final EObject context, final EReference reference) {
    return ((context instanceof Assignment) && Objects.equal(reference, MGLangPackage.Literals.ASSIGNMENT__TARGET));
  }
  
  public boolean isRefOrCallRef(final EObject context, final EReference reference) {
    return ((context instanceof RefOrCall) && Objects.equal(reference, MGLangPackage.Literals.REF_OR_CALL__REF));
  }
  
  public boolean isRefOrCallCalled(final EObject context, final EReference reference) {
    return ((context instanceof RefOrCall) && Objects.equal(reference, MGLangPackage.Literals.REF_OR_CALL__CALLED));
  }
  
  public MofgenFile getRootFile(final EObject context) {
    return EcoreUtil2.<MofgenFile>getContainerOfType(context, MofgenFile.class);
  }
}
