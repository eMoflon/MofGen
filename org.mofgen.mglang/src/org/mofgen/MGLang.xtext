grammar org.mofgen.MGLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate mGLang "http://www.mofgen.org/MGLang"

MofgenFile:
	(imports+=Import)*
	(config=Config)
	(commands += FileCommand)*
;

FileCommand:
	Pattern | Generator
;

Import:
	IMPORT_KW uri=STRING 'as' name=ID;

Config:
	{Config} CONFIG_KW '(' ')' '{'
	(expressions += ConfigExpression)*
	'}'
	;

ConfigExpression:
	HomeExpression | UseProjectAsHomeExpression
;

HomeExpression:
	'home' ASSIGNMENT_OP uri=STRING
;

UseProjectAsHomeExpression:
	'useProjectLocationAsHome' ASSIGNMENT_OP val = BooleanLiteral
;

Pattern:
	PATTERN_OPENER name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (commands += PatternCommand )* '}'
	(return=PatternReturn)?;

PatternCommand:
	Collection | Node | ParamManipulation | Switch
;

PatternReturn:
	{PatternReturn} RETURN_KW THIS_KW ('.' returnValue=[Node])?;

ParamManipulation:
	param=[ParameterNode] content=NodeContent;	// TODO wollten wir das nicht eigentlich verbieten?

Node:
	(srcModel=[Import]'.')? type=[ecore::EClass] name=ID (createdBy=NodeContent | (ASSIGNMENT_OP createdBy=PatternCall))?;

NodeContent:
	{NodeContent} '{' (refsAssigns+=NodeReferenceOrAssignmentOrControlFlow)* '}';

PatternCall:
	called=[Pattern] '(' (params+= ArithmeticExpression (',' params+=ArithmeticExpression)*)? ')';

NodeReferenceOrAssignmentOrControlFlow:
	(PatternNodeReference | Assignment | Switch);

PatternNodeReference:
	type=[ecore::EReference] REFERENCE_OP target=[Node];

Assignment:
	target=[ecore::ENamedElement] ASSIGNMENT_OP value=ArithmeticExpression
;
	
Parameter:
	PrimitiveParameter | ParameterNode;

PrimitiveParameter:
	type=PrimitiveType name=ID;

ParameterNode:
	(srcModel=[Import]'.')? type=[ecore::EClassifier] name=ID;

//Using generic eobject references to make enums possible.
RefOrCall:
	ref=[ecore::EObject] ({RefOrCall.target=current} '.' ref=[ecore::ENamedElement] ('(' (params = RefParams)? bracesSet?=')')?)*;

RefParams:
	params += ArithmeticExpression (',' params+=ArithmeticExpression)*;

Generator:
	{Generator} GEN_OPENER '(' (params+=Parameter)* ')' '{' (commands+=GeneratorExpression)* '}';

GeneratorExpression: //Only serves as super class for all possible commands within generator
	ForStatement | Switch | Collection | PatternCall | PatternVariable | Variable | VariableManipulation | CollectionManipulation;

CollectionManipulation:
	trg=[Collection] '.' op=[ecore::EOperation] '(' (params = RefParams)? ')'
;

VariableManipulation:
	var=[Variable] ASSIGNMENT_OP val=ArithmeticExpression	
;

PatternVariable:
	type=[Pattern] name=ID ASSIGNMENT_OP patternCall=PatternCall;

Variable:
	VARIABLE_KW name=ID ASSIGNMENT_OP value=ArithmeticExpression
;

ForStatement:
	FOR_KW head=ForHead '{' body=ForBody '}';

ForHead:
	RangeForHead | ForEachHead | ListForHead;

RangeForHead:
	iteratorVar=ID 'in' range=ForRange;

ForRange:
	start=ArithmeticExpression ':' end=ArithmeticExpression;

ForEachHead:
	src=RefOrCall '-' eref=[ecore::EReference] REFERENCE_OP iteratorVar=ID;

ListForHead:
	iteratorVar=ID 'in' list=[List]
;

ForBody:
	{ForBody} (commands+=GeneratorExpression)*;

SwitchExpression:
	ForStatement | Collection | PatternCall | PatternVariable | NodeReferenceOrAssignmentOrControlFlow
;

Switch:
	IfElseSwitch | SwitchCase;

IfElseSwitch:
	SWITCH_KW '{' (cases+=IfElseCase)+ (default=Default)? '}';

IfElseCase:
	CASE_KW val=ArithmeticExpression ':' body=CaseBody;

Default:
	DEFAULT_KW ':' CaseBody;

SwitchCase:
	SWITCH_KW '(' attribute=RefOrCall ')' '{' (cases+=Case)+ (default=Default)? '}';

Case:
	CaseWithCast | CaseWithoutCast;

CaseWithCast:
	CASE_KW node=Node (CASE_CONDITION_KW when=ArithmeticExpression)? ':' body=CaseBody;

CaseWithoutCast:
	CASE_KW val=ArithmeticExpression ':' body=CaseBody;

CaseBody:
	{CaseBody} '{' (expressions+=SwitchExpression)* '}' | expressions+=SwitchExpression;

Collection:
	List | Map;

List:
	LIST_KW name=ID (defOrDecl=ListDefOrDecl)?;

ListDefOrDecl:
	ListDefinition | ListDeclaration
;

ListDeclaration:
	COLL_TYPE_KW type=[ecore::EClass]
;

ListDefinition:
	ASSIGNMENT_OP (ListAdHoc | RefOrCall);	//Can lists even be returned by any calls or is this redundant?

ListAdHoc:
	{ListAdHoc} '[' (elements+=ArithmeticExpression (',' elements+=ArithmeticExpression)*)? ']'
;

Map:
	MAP_KW name=ID (createdBy=MapDefOrDecl)?;

MapDefOrDecl:
	MapDefinition | MapDeclaration
;

MapDeclaration:
	COLL_TYPE_KW keyType=[ecore::EClass] MAPPING_OP entryType=[ecore::EClass] //TODO: How to signal key to entry relation?
;

MapDefinition:
	ASSIGNMENT_OP (MapAdHoc | RefOrCall);	

MapAdHoc:
	{MapAdHoc} '[' (entries+=MapTupel (',' entries+=MapTupel)*)? ']';

MapTupel:
	'(' key=ArithmeticExpression ',' value=ArithmeticExpression ')';


	//======================================Arithmetics============================================
ArithmeticExpression:
	TertiaryExpression;

TertiaryExpression returns ArithmeticExpression:
	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;

SecondaryExpression returns ArithmeticExpression:
	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;

PrimaryExpr returns ArithmeticExpression:
	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;

RelationExpression returns ArithmeticExpression:
	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;

BaseExpr returns ArithmeticExpression:
	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
	expr=ArithmeticExpression ')' | {UnaryMinus} '-' expr=BaseExpr | Literal | RefOrCall | PatternCall;

Literal:
	BooleanLiteral | StringLiteral | NumberLiteral;

BooleanLiteral:
	val = (TRUE|FALSE)
;

StringLiteral:
	val = STRING;

NumberLiteral:
	val = DOUBLE;
	
enum MathFunc:	//TODO Replace by methods of java.math or similar
	SQRT='sqrt' | ABS='abs';

enum PrimitiveType:
	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' | BOOLEAN='boolean' //String as Primitive? (and therefore also better lowercase?)
;

terminal DOUBLE returns ecore::EDouble:
	INT ('.' INT)?
;

terminal TRUE returns ecore::EBoolean:
	'true';

terminal FALSE returns ecore::EBoolean:
	'false';

enum RelationalOp:
	GREATER='>' |
	GREATER_OR_EQUAL='>=' |
	EQUAL='==' |
	UNEQUAL='!=' |
	LESS_OR_EQUAL='<=' |
	LESS ='<';

enum TertiaryOp:
	PLUS='+' |
	MINUS='-' |
	OR='||';

enum SecondaryOp:
	MOD='%' |
	XOR='^';

enum PrimaryOp:
	MUL='*' |
	DIV='/' |
	AND='&&';

terminal ASSIGNMENT_OP:
	'=';

terminal IMPORT_KW:
	'import'
;

terminal CONFIG_KW:
	'config'
;

terminal RETURN_KW:
	'return'
;

terminal THIS_KW:
	'this'
;

terminal REFERENCE_OP:
	'->'
;

terminal MAPPING_OP:
	'->'
;

terminal VARIABLE_KW:
	'var'
;

terminal FOR_KW:
	'for'
;

terminal CASE_KW:
	'case'
;

terminal SWITCH_KW:
	'switch'
;

terminal GEN_OPENER:
	'gen'
;

terminal CASE_CONDITION_KW:
	'when'
;

terminal COLL_TYPE_KW:
	'of'
;

terminal LIST_KW:
	'List'
;

terminal MAP_KW:
	'Map'
;

terminal DEFAULT_KW:
	'default'
;

terminal PATTERN_OPENER:
	'pattern'
;