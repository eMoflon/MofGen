grammar org.mofgen.MGLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate mGLang "http://www.mofgen.org/MGLang"

// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es benötigt wird?
MofgenFile:
	(imports+=Import)*
	(patterns+=Pattern |
	generators+=Generator)*;

Import:
	'import' name=STRING 'as' alias=ID;

Pattern:
//(abstract?='abstract')? // 'Abstract' necessary? TODO
	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (nodes+=Node)* '}'
	(return=PatternReturn)?;

PatternReturn:
	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;

Node:
	type=[ecore::EClass] name=ID (createdBy=(NodeConstructor | PatternCall))?;

NodeConstructor:
	{NodeConstructor} '{' (refsAssigns+=NodeReferenceOrAssignment)* '}';

PatternCall:
	called=[Pattern] '(' (params+=LiteralExpression)* ')';

NodeReferenceOrAssignment:
	(PatternNodeReference | Assignment) ('[' condition=Condition ']')?;

Condition:
	lhs=[Parameter] // EditorRelation only needed for non-booleans
	(relation=EditorRelation rhs=[Parameter])?;

PatternNodeReference:
	type=[ecore::EReference] '->' target=[Node];
	//TODO: "doc -entries-> entry" fügt einen entry in entries hinzu oder weist entries objekt entry zu? Das führt zu zweideutigkeiten so

Assignment:
	target=[ecore::EAttribute] ASSIGNMENT_OP value=LiteralExpression;
	//TODO make Enum Assignments possible

NodeAttributeCall:
	node=[Node] '.' attribute=[ecore::EAttribute];

Parameter:
	PrimitiveParameter | ObjectParameter
;

PrimitiveParameter:
	type=PrimitiveType name=ID
;

ObjectParameter:
	type=[ecore::EClassifier] name=ID
;

StringConcatenation returns STRING:
	StringLiteral ({Concat.left=current} '+' right=StringConcatenation)?
;

StringLiteral returns STRING:
	value=STRING
;

enum PrimitiveType:
	INT='int' | CHAR='char' | DOUBLE = 'double'
;

Generator:
	{Generator} 'gen' '('
	// TODO	
	')' '{' (commands+=GeneratorElement)* '}';

GeneratorElement:
	GeneratorCommand | ForLoop;

GeneratorCommand: //Only serves as super class for all possible commands within generator
	PatternCall | PatternObjectCreation; //TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermöglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject übersetzen?
GenPatternCall:
	calledPattern=[Pattern] ('(' (params+=PatternObject)* ')')?;

PatternObjectCreation:
	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;

PatternObject:
	type=[Pattern] name=ID;

ForLoop:
	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
	(commands+=GeneratorCommand)*
	'}';

ForCondition:
	ForEachCollection | ForRange;

ForEachCollection:
	coll=NodeAttributeCall;

ForRange:
	start=INT ':' end=INT;

LiteralExpression:
	{BooleanLiteral} value=('true' | 'false') |
	{NumberLiteral} value=('-')? INT ('.' INT)? |
	{StringLiteral} value=StringConcatenation;

enum EditorRelation:
	GREATER='>' |
	GREATER_OR_EQUAL='>=' |
	EQUAL='==' |
	UNEQUAL='!=' |
	SMALLER_OR_EQUAL='<=' |
	SMALLER='<';

terminal ASSIGNMENT_OP:
	'=';