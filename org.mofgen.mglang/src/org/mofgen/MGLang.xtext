grammar org.mofgen.MGLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate mGLang "http://www.mofgen.org/MGLang"

// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es benötigt wird?
MofgenFile:
	(imports+=Import)*
	(patterns+=Pattern |
	generators+=Generator)*;

Import:
	'import' name=STRING 'as' alias=ID;

Pattern:
//(abstract?='abstract')? // 'Abstract' necessary? TODO
	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (nodes+=Node)* '}'
	(return=PatternReturn)?;

PatternReturn:
	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;

Node:
	type=[ecore::EClass] name=ID (createdBy=(NodeConstructor | PatternCall))?;

NodeConstructor:
	{NodeConstructor} '{' (refsAssigns+=NodeReferenceOrAssignment)* '}';

PatternCall:
	called=[Pattern] '(' (params+=StringExpression)* ')';

NodeReferenceOrAssignment:
	(PatternNodeReference | Assignment) ('[' condition=BooleanExpression ']')?;

PatternNodeReference:
	type=[ecore::EReference] '->' target=[Node];
	//TODO: "doc -entries-> entry" fügt einen entry in entries hinzu oder weist entries objekt entry zu? Das führt zu zweideutigkeiten so

Assignment:
	target=[ecore::EAttribute] ASSIGNMENT_OP value=StringExpression;
	//TODO make Enum Assignments possible

NodeAttributeCall:
	node=[Node] '.' attribute=[ecore::EAttribute];

Parameter:
	PrimitiveParameter | ObjectParameter
;

PrimitiveParameter:
	type=PrimitiveType name=ID
;

ObjectParameter:
	type=[ecore::EClassifier] name=ID
;

ParameterOrMethodCall:
	ParameterRef | MethodCall
;

ParameterRef:
	ref=[Parameter] //TODO Scoping
;

MethodCall: //TODO Scoping
	calledNode=[Node] '.' method=[ecore::EOperation]
;


BooleanExpression:
	BooleanOr
;

RelationExpression returns BooleanExpression:
	lhs=ParameterOrMethodCall relation=RelationalOp rhs=ParameterOrMethodCall
;

BooleanOr returns BooleanExpression:
	BooleanXor ({Or.left=current} '||' right=(BooleanXor))*
;

BooleanXor returns BooleanExpression:
	BooleanAnd ({Xor.left=current} '^' right=(BooleanAnd))*
;

BooleanAnd returns BooleanExpression:
	BaseBoolean ({And.left=current} '&&' right=(BaseBoolean))*
;

BaseBoolean returns BooleanExpression:
	{NegatedBoolean} '!' '(' expr=BooleanExpression ')' | '(' BooleanExpression ')' | {BooleanLiteral} value=Boolean | RelationExpression
;


enum Boolean:
	TRUE='true' | FALSE='false'
;

NumberLiteral:
	value=NUMBER
;
	
@Override
terminal INT returns ecore::EInt: ('0'..'9')+;

terminal NUMBER:
	('-')? INT ('.' INT)?
;

StringExpression:
	StringConcatenation
;

StringConcatenation returns STRING:
	StringLiteral ({Concat.left=current} '+' right=StringConcatenation)?
;

StringLiteral returns STRING:
	value=STRING
;

enum PrimitiveType:
	INT='int' | CHAR='char' | DOUBLE = 'double'
;

Generator:
	{Generator} 'gen' '('
	// TODO	
	')' '{' (commands+=GeneratorElement)* '}';

GeneratorElement:
	GeneratorCommand | ForLoop;

GeneratorCommand: //Only serves as super class for all possible commands within generator
	PatternCall | PatternObjectCreation; //TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermöglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject übersetzen?
GenPatternCall:
	calledPattern=[Pattern] ('(' (params+=PatternObject)* ')')?;

PatternObjectCreation:
	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;

PatternObject:
	type=[Pattern] name=ID;

ForLoop:
	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
	(commands+=GeneratorCommand)*
	'}';

ForCondition:
	ForEachCollection | ForRange;

ForEachCollection:
	coll=NodeAttributeCall;

ForRange:
	start=INT ':' end=INT;

enum RelationalOp:
	GREATER='>' |
	GREATER_OR_EQUAL='>=' |
	EQUAL='==' |
	UNEQUAL='!=' |
	SMALLER_OR_EQUAL='<=' |
	SMALLER='<';

terminal ASSIGNMENT_OP:
	'=';