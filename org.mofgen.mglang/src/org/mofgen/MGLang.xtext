grammar org.mofgen.MGLang with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate mGLang "http://www.mofgen.org/MGLang"

MofgenFile:
	(imports+=Import)*
	(patterns+=Pattern |
	generators+=Generator)*;

Import:
	'import' name=STRING 'as' alias=ID;

Pattern:
//(abstract?='abstract')? // 'Abstract' necessary? TODO
	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (((colls+=Collection)*)? & ((nodes+=Node)*)? & ((paramManipulations+=ParamManipulation)*)?)'}' (return=PatternReturn)?;

PatternReturn:
	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;

ParamManipulation:
	param=[ParameterNode] content=NodeContent
;

Node:
	type=[ecore::EClass] name=ID (createdBy=NodeContent | (ASSIGNMENT_OP createdBy=PatternCall))?;

NodeContent:
	{NodeContent} '{' (refsAssigns+=NodeReferenceOrAssignment)* '}';

PatternCall:
	called=[Pattern] '(' (params+=ArithmeticExpression)* ')';

NodeReferenceOrAssignment:
	(PatternNodeReference | Assignment) ('[' condition=ArithmeticExpression ']')?;

PatternNodeReference:
	type=[ecore::EReference] '->' target=[Node];

Assignment:
	target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression;
	//TODO make Enum Assignments possible

NodeAttributeCall:
	node=[Node] '.' attribute=[ecore::EAttribute];

Parameter:
	PrimitiveParameter | ParameterNode;

PrimitiveParameter:
	type=PrimitiveType name=ID;

ParameterNode:
	type=[ecore::EClassifier] name=ID;

ParameterRefOrMethodCall:
	ParameterRef | MethodCall;

ParameterRef:
	ref=[Parameter] //TODO Scoping
;

MethodCall: //TODO Scoping
	calledNode=[Node] '.' method=[ecore::EOperation];

ArithmeticExpression:
	TertiaryExpression;

TertiaryExpression returns ArithmeticExpression:
	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;

SecondaryExpression returns ArithmeticExpression:
	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;

PrimaryExpr returns ArithmeticExpression:
	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;

RelationExpression returns ArithmeticExpression:
	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;

BaseExpr returns ArithmeticExpression:
	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '(' expr=ArithmeticExpression ')' | {Literal} Literal |
	ParameterRefOrMethodCall;

Literal:
	BooleanLiteral | StringLiteral | NumberLiteral;

BooleanLiteral returns ecore::EBoolean:
	TRUE | FALSE;

StringLiteral returns ecore::EString:
	STRING;

NumberLiteral returns ecore::EDouble:
	INT ('.' INT)?; //TODO: Negative Numbers?
enum MathFunc:
	SQRT='sqrt' | ABS='abs';

enum PrimitiveType:
	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' //TODO: String as Primitive? (and therefore also better lowercase?)
;

Generator:
	{Generator} 'gen' '('
	(params+=Parameter)*
	')' '{' (commands+=GeneratorCommand)* '}';

	//TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermöglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject übersetzen?
GeneratorCommand: //Only serves as super class for all possible commands within generator
	ForStatement | IfStatement | SwitchCase | Collection | PatternCall | PatternObjectCreation;

PatternObjectCreation:
	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;

PatternObject:
	type=[Pattern] name=ID;

ForStatement:
	'for' head=ForHead '{' body=ForBody '}';

ForHead:
	GeneralForHead | ForEachHead;

GeneralForHead:
	iteratorVar=ID 'in' range=ForRange;

ForEachHead:
	src=[NodeOrParameterOrCollection] '-' ref=[ecore::EReference] '->' iteratorVar=ID;

NodeOrParameterOrCollection:
	Node | Parameter | Collection;

ForBody:
	GenCommandBlock;

IfStatement:
	SingleLineIf //| BlockIf
;

SingleLineIf:
	'if' '(' condition=ArithmeticExpression ')' command=GeneratorCommand;

GenCommandBlock:
	{GenCommandBlock} (commands+=GeneratorCommand)*;

//TODO If-Recursion
BlockIf:
	'if' if=IfHeadAndBody (('else' 'if' elseifs+=IfHeadAndBody)* ('else' else=IfBody))?;

IfHeadAndBody:
	'(' head=IfHead ')' '{' body=IfBody '}';

IfHead:
	condition=ArithmeticExpression;

IfBody:
	commands=GenCommandBlock;

SwitchCase:
	'switch' '(' attribute=ParameterRefOrMethodCall ')' '{' (cases+=Case)+ default=Default;

Default:
	'default' ':' GeneratorCommand;

Case:
	'case' val=ArithmeticExpression ':' body=CaseBody;

CaseBody:
	'{' GenCommandBlock '}' | GeneratorCommand;

Collection:
	List | Map;

List:
	'List' name=ID (ASSIGNMENT_OP ListAdHoc);

ListAdHoc:
	'[' elements+=Literal (',' elements+=Literal)* ']' //TODO Allow empty lists? --> Probably have no purpose here since one will not be able to manipulate them, right?
;

Map:
	'Map' name=ID (ASSIGNMENT_OP MapAdHoc);

MapAdHoc:
	'[' entries+=MapTupel (',' entries+=MapTupel)* ']';

MapTupel:
	'(' key=Literal ',' value=ArithmeticExpression ')';

ForRange:
	start=INT ':' end=INT;

terminal TRUE returns ecore::EBoolean:
	'true';

terminal FALSE returns ecore::EBoolean:
	'false';

enum RelationalOp:
	GREATER='>' |
	GREATER_OR_EQUAL='>=' |
	EQUAL='==' |
	UNEQUAL='!=' |
	SMALLER_OR_EQUAL='<=' |
	SMALLER='<';

enum TertiaryOp:
	PLUS='+' |
	MINUS='-' |
	OR='||';

enum SecondaryOp:
	MOD='%' |
	XOR='^';

enum PrimaryOp:
	MUL='*' |
	DIV='/' |
	AND='&&';

terminal ASSIGNMENT_OP:
	'=';

terminal NEWLINE:
	'\n';
