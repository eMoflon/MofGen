/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.scoping

import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.mofgen.mGLang.MGLangPackage
import org.mofgen.utils.MofgenModelUtils
import org.eclipse.xtext.scoping.Scopes
import org.mofgen.mGLang.MofgenFile
import org.mofgen.mGLang.PatternNodeReference
import org.eclipse.xtext.scoping.IScope
import org.mofgen.mGLang.Node
import org.eclipse.xtext.EcoreUtil2
import org.mofgen.mGLang.Assignment
import org.mofgen.mGLang.Pattern
import org.mofgen.mGLang.RefOrCall
import org.mofgen.mGLang.Case
import org.mofgen.mGLang.ParameterNode
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EOperation

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MGLangScopeProvider extends AbstractMGLangScopeProvider {

	// TODO: Scoping for calls / refs within case-bodies shadowing the outer scope
	override getScope(EObject context, EReference reference) {
		if (isNodeCreation(context, reference)) {
			return getScopeForNodeCreationType(context as Node)
		}
		if (isReferenceType(context, reference)) {
			return getScopeForReferenceType(context as PatternNodeReference)
		}
		if (isReferenceTarget(context, reference)) {
			return getScopeForReferenceTarget(context as PatternNodeReference)
		}
		if (isNodeAttributeAssignmentType(context, reference)) {
			return getScopeForNodeAssignmentType(context as Assignment)
		}
//		if (isRefOrCallRef(context, reference)) {
//			return getScopeForRefOrCallRef(context as RefOrCall)
//		}
//		if (isRefOrCallCalled(context, reference)) {
//			return getScopeForRefOrCallCalled(context as RefOrCall)
//		}
		if (isRefOrCall(context)) {
			return getScopeForRefOrCall(context as RefOrCall)
		}

		return super.getScope(context, reference)
	// return IScope.NULLSCOPE;
	}

	def getScopeForNodeCreationType(Node n) {
		val file = getRootFile(n)
		val classes = MofgenModelUtils.getClasses(file)
		return Scopes.scopeFor(classes)
	}

	def getScopeForReferenceType(PatternNodeReference ref) {
		val file = getRootFile(ref)
		val src = EcoreUtil2.getContainerOfType(ref, Node)
		val classes = MofgenModelUtils.getClasses(file)
		val filteredClasses = classes.filter[c|c == src.type]
		if (filteredClasses.empty) {
			return IScope.NULLSCOPE
		} else {
			return Scopes.scopeFor(filteredClasses.get(0).EAllReferences)
		}

	}

	def getScopeForAllNodes(EObject context) {
		val root = getRootFile(context)
		val allNodes = EcoreUtil2.getAllContentsOfType(root, Node)
		return Scopes.scopeFor(allNodes)
	}

	def getScopeForReferenceTarget(PatternNodeReference ref) {
		return getScopeForAllNodes(ref)
	}

	def getScopeForNodeAssignmentType(Assignment ass) {
		val srcNode = EcoreUtil2.getContainerOfType(ass, Node)
		val file = getRootFile(ass)
		val clazzez = MofgenModelUtils.getClasses(file)
		try {
			val filteredClazzez = clazzez.filter[c|c == srcNode.type]
			if (filteredClazzez.isEmpty) {
				return IScope.NULLSCOPE
			} else {
				return Scopes.scopeFor(filteredClazzez.get(0).EAllAttributes)
			}
		} catch (NullPointerException e) {
			return IScope.NULLSCOPE
		}

	}

	def getScopeForRefOrCallRef(RefOrCall r) {
		// get parameters of above Pattern
		val pattern = EcoreUtil2.getContainerOfType(r, Pattern)
		val params = pattern.parameters

		// get nodes of pattern
		val patternNodes = pattern.nodes
		// get nodes of casts in above case-heads (remove names from pattern-nodes eventually)
		val shadowingNodes = getEventuallyShadowingNodes(r)
		val indicesToRemove = newArrayList()

		// find shadowed Pattern nodes
		for (pNode : patternNodes) {
			for (node : shadowingNodes) {
				if (node.name.equals(pNode.name)) {
					indicesToRemove.add(patternNodes.indexOf(pNode))
				}
			}
		}

		for (index : indicesToRemove.reverse) {
			patternNodes.remove(index)
		}

		return Scopes.scopeFor(params + patternNodes)
	}

	def getEventuallyShadowingNodes(EObject obj) {
		val parentCases = EcoreUtil2.getAllContainers(obj).filter(Case)
		return parentCases.map[c|c.node]
	}

	def getScopeForRefOrCall(RefOrCall r) {

		if (r.target === null) {
			// get parameters of above Pattern
			val pattern = EcoreUtil2.getContainerOfType(r, Pattern)
			val params = pattern.parameters

			// get nodes of pattern
			val patternNodes = pattern.nodes
			// get nodes of casts in above case-heads (remove names from pattern-nodes eventually)
			val shadowingNodes = getEventuallyShadowingNodes(r)
			val indicesToRemove = newArrayList()

			// find shadowed Pattern nodes
			for (pNode : patternNodes) {
				for (node : shadowingNodes) {
					if (node.name.equals(pNode.name)) {
						indicesToRemove.add(patternNodes.indexOf(pNode))
					}
				}
			}

			for (index : indicesToRemove.reverse) {
				patternNodes.remove(index)
			}
			return Scopes.scopeFor(params + patternNodes)
			
		} else {
			val trg = r.target
			val refClass = trg.ref.eClass
			
			val ops = refClass.EAllOperations
			val attrs = refClass.EAllAttributes
			val refs = refClass.EReferences
			return Scopes.scopeFor(ops + attrs + refs)
		}
	}

	def isReferenceType(EObject context, EReference reference) {
		return context instanceof PatternNodeReference &&
			reference == MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE
	}

	def isReferenceTarget(EObject context, EReference reference) {
		return context instanceof PatternNodeReference &&
			reference == MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET
	}

	def isNodeCreation(EObject context, EReference reference) {
		return context instanceof Node && reference == MGLangPackage.Literals.NODE__TYPE
	}

	def isNodeAttributeAssignmentType(EObject context, EReference reference) {
		return context instanceof Assignment && reference == MGLangPackage.Literals.ASSIGNMENT__TARGET
	}

	def isRefOrCall(EObject context){
		return context instanceof RefOrCall
	}

//	def isRefOrCallRef(EObject context, EReference reference) {
//		return context instanceof RefOrCall && reference == MGLangPackage.Literals.REF_OR_CALL__REF
//	}
//
//	def isRefOrCallCalled(EObject context, EReference reference) {
//		return context instanceof RefOrCall && reference == MGLangPackage.Literals.REF_OR_CALL__CALLED
//	}

	def getRootFile(EObject context) {
		return EcoreUtil2.getContainerOfType(context, MofgenFile)
	}
}
