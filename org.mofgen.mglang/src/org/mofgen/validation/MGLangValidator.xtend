/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.validation

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EOperation
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.mofgen.interpreter.Calculator
import org.mofgen.mGLang.ArithmeticExpression
import org.mofgen.mGLang.Import
import org.mofgen.mGLang.MGLangPackage
import org.mofgen.mGLang.PatternCall
import org.mofgen.utils.MofgenModelUtils
import org.mofgen.mGLang.CaseWithCast
import org.mofgen.mGLang.RefOrCall
import org.mofgen.mGLang.Assignment
import org.eclipse.emf.ecore.EAttribute
import org.mofgen.interpreter.MismatchingTypesException
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.mofgen.mGLang.RangeForHead
import org.mofgen.mGLang.ForBody
import org.mofgen.interpreter.TypeCalculator
import org.mofgen.typeModel.TypeModelPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.EClass
import org.mofgen.mGLang.PatternCommand
import org.mofgen.mGLang.Switch
import org.mofgen.mGLang.IfElseSwitch
import org.mofgen.mGLang.SwitchCase

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGLangValidator extends AbstractMGLangValidator {

	@Inject Calculator calc
	@Inject TypeCalculator typeChecker

// TODO Check if there are sufficient null checks so no strange errors occur in the editor
	@Check
	def validForRange(RangeForHead head) {
		val forRange = head.range
		if (forRange !== null) {
			if (forRange.start !== null && forRange.end !== null) {
				val start = forRange.start
				val end = forRange.end
				checkForNumber(forRange.start, forRange, MGLangPackage.Literals.FOR_RANGE__START)
				checkForNumber(forRange.end, forRange, MGLangPackage.Literals.FOR_RANGE__END)
				val castStart = calc.evaluate(start) as Double
				val castEnd = calc.evaluate(end) as Double
				if (castStart > castEnd) {
					error("Limiting bound is less than starting value", MGLangPackage.Literals.RANGE_FOR_HEAD__RANGE)
				}
			}
		}
	}

	def private checkForNumber(ArithmeticExpression expr, EObject obj, EReference errorLoc) {
		try {
			val eval = typeChecker.evaluate(expr)
			if (eval !== TypeModelPackage.Literals.NUMBER) {
				error("For-Range needs numerical bounds but was given type " + eval.name, obj, errorLoc)
			}
		} catch (MismatchingTypesException e) {
			error(e.message, obj, errorLoc)
		}
	}

	@Check
	def warnEmptyForLoop(ForBody body) {
		if (body.commands.empty) {
			warning("empty for-loop", body.eContainer, MGLangPackage.Literals.FOR_STATEMENT__HEAD)
		}
	}

	@Check
	def checkBooleanWhen(CaseWithCast caze) {
		if (caze.when !== null) {
			try {
				val res = typeChecker.evaluate(caze.when)
				if (res !== TypeModelPackage.Literals.BOOLEAN) {
					error("Needs boolean value for conditional expression", caze,
						MGLangPackage.Literals.CASE_WITH_CAST__WHEN)
				}
			} catch (MismatchingTypesException e) {
				error(e.message, caze, MGLangPackage.Literals.CASE_WITH_CAST__WHEN)
			}
		}
	}

	@Check
	def checkForImportConflicts(Import imp) {
		var imports = EcoreUtil2.getAllContentsOfType(MofgenModelUtils.getRootFile(imp), Import)
		imports.remove(imp)
		val duplicateClasses = checkImportsForDuplicates(imports, imp)
		if (!duplicateClasses.isEmpty) {
			warning("Import conflict for classes with names" + duplicateClasses.toString,
				MGLangPackage.Literals.IMPORT__URI)
		}
	}

	def checkImportsForDuplicates(List<Import> imps, Import otherImp) {
		var conflicts = newLinkedList()

		if(imps.isEmpty) return conflicts

		val classes = MofgenModelUtils.getClassesFromImportList(imps)
		val otherClasses = MofgenModelUtils.getClassesFromImport(otherImp)
		for (otherClass : otherClasses) {
			if (classes.contains(otherClass)) {
				conflicts.add(otherClass.name)
			}
		}
		return conflicts
	}

	@Check
	def checkAttributeType(Assignment ass) {
		val trg = ass.target
		if (trg instanceof EAttribute) {
			val attribute = trg as EAttribute
			val attributeType = MofgenModelUtils.getEClassForInternalModel(attribute.EAttributeType)

			try {
				val assignedValue = MofgenModelUtils.getEClassForInternalModel(typeChecker.evaluate(ass.value))
				if (assignedValue != TypeModelPackage.Literals.ENUM_LITERAL && attributeType == TypeModelPackage.Literals.ENUM) {
					error("Can only assign enum values to enum attribute " + attribute.name,
						MGLangPackage.Literals.ASSIGNMENT__VALUE)
				} else {
					if (assignedValue == TypeModelPackage.Literals.ENUM_LITERAL && attributeType != TypeModelPackage.Literals.ENUM) {
						error("Cannot assign enum value to non-enum attribute " + attribute.name,
							MGLangPackage.Literals.ASSIGNMENT__VALUE)
					}
				}
			} catch (MismatchingTypesException e) {
				error(e.message, ass, MGLangPackage.Literals.ASSIGNMENT__VALUE)
			}

		}
	}

	@Check
	def matchingParameters_pc(PatternCall pc) {
		// check parameter count
		var neededParams = 0
		var actualParams = 0

		if (pc.called.parameters !== null) {
			neededParams = pc.called.parameters.length
		}
		if (pc.params !== null) {
			actualParams = pc.params.length
		}

		if (neededParams != actualParams) {
			error("Pattern " + pc.called.name + " expects " + neededParams + " parameters but was given " +
				actualParams, MGLangPackage.Literals.PATTERN_CALL__PARAMS)
			return;
		}

		// check parameter types
		for (i : 0 ..< pc.params.length) {
			val givenParameterExpression = pc.params.get(i)
			val neededParameter = pc.called.parameters.get(i)

		val givenParameterType = typeChecker.evaluate(givenParameterExpression)
			val neededParameterType = MofgenModelUtils.getInternalParameterType(neededParameter)

			if (givenParameterType instanceof EClass && neededParameterType instanceof EClass && 
				!(neededParameterType.isSuperTypeOf(givenParameterType))) {
				// TODO Is it right that any object fits into an eobject parameter?
				if (neededParameterType !== EcorePackage.Literals.EOBJECT) {
					if (givenParameterType !== neededParameterType) {
						error("Given type " + givenParameterType.name + " does not match needed type " +
							neededParameterType.name, MGLangPackage.Literals.PATTERN_CALL__CALLED)
					}
				}
			}
		}
	}

//	@Check
//	def matchingParameters_roc(RefOrCall roc) {
//		if (roc.ref instanceof EOperation) {
//			if (!roc.bracesSet) {
//				error("Missing parameter list", MGLangPackage.Literals.REF_OR_CALL__PARAMS)
//				return;
//			} else {
//				val op = roc.ref as EOperation
//				val givenParams = roc.params.params
//				val neededParams = op.EParameters
//
//				// Check parameter count
//				if (givenParams.size != neededParams.size) {
//					error("Method " + op.name + " expects " + neededParams.size + " parameters but was given " +
//						givenParams.size, MGLangPackage.Literals.REF_OR_CALL__PARAMS)
//					return;
//				}
//
//				// Check parameter types
//				for (var i = 0; i < givenParams.size; i++) {
//					try {
//						val givenParameterType = MofgenModelUtils.getEClassForInternalModel(
//							typeChecker.evaluate(givenParams.get(i)))
//						val neededParameterType = MofgenModelUtils.getEClassForInternalModel(neededParams.get(i).EType)
//
//						if (!(givenParameterType instanceof EClass && neededParameterType instanceof EClass &&
//							neededParameterType.isSuperTypeOf(givenParameterType))) {
//							// TODO Is it right that any object fits into an eobject parameter?
//							if (neededParameterType !== EcorePackage.Literals.EOBJECT) {
//								if (givenParameterType !== neededParameterType) {
//									error(
//										"Given parameter type " + givenParameterType.name +
//											" does not match needed parameter type " + neededParameterType.name,
//										MGLangPackage.Literals.REF_OR_CALL__PARAMS)
//								}
//							}
//						}
//					} catch (MismatchingTypesException e) {
//						error(e.message, MGLangPackage.Literals.REF_OR_CALL__PARAMS)
//					}
//				}
//			}
//		} else {
//			if (roc.bracesSet) {
//				error(roc.ref + " is not a method", MGLangPackage.Literals.REF_OR_CALL__BRACES_SET) // TODO Correct highlighting?
//				return;
//			}
//		}
//	}

}
