/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.validation

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EOperation
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.mofgen.interpreter.Calculator
import org.mofgen.mGLang.ArithmeticExpression
import org.mofgen.mGLang.GeneralForHead
import org.mofgen.mGLang.Import
import org.mofgen.mGLang.MGLangPackage
import org.mofgen.mGLang.Parameter
import org.mofgen.mGLang.PatternCall
import org.mofgen.mGLang.PrimitiveParameter
import org.mofgen.utils.MofgenModelUtils
import org.mofgen.mGLang.ParameterNode

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGLangValidator extends AbstractMGLangValidator {
	
	@Inject Calculator calc
	
	@Check
	def validForRange(GeneralForHead head){
		val start = calc.evaluate(head.range.start)
		val end = calc.evaluate(head.range.end)
		
		if(!(start instanceof Number)){
			error("For-Range needs numerical bounds but was given " + start, MGLangPackage.Literals.FOR_RANGE__START)
		}
		if(!(end instanceof Number)){
			error("For-Range needs numerical bounds but was given " + end, MGLangPackage.Literals.FOR_RANGE__END)
		}
		
		val castStart = start as Double
		val castEnd = end as Double
		if(castStart > castEnd){
			error("Limiting bound is less than starting value", MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE)
		}
	}
	
	@Check
	def checkForImportConclicts(Import imp){
		var imports = EcoreUtil2.getAllContentsOfType(MofgenModelUtils.getRootFile(imp), Import)
		imports.remove(imp)
		val duplicateClasses = checkImportsForDuplicates(imports, imp)
		if(!duplicateClasses.isEmpty){
			warning("Import conflict for classes with names" + duplicateClasses.toString, MGLangPackage.Literals.IMPORT__URI)
		}
	}
	
	def checkImportsForDuplicates(List<Import> imps, Import otherImp){
		val classes = MofgenModelUtils.getClassesFromImportList(imps)
		val otherClasses = MofgenModelUtils.getClassesFromImport(otherImp)
		var conflicts = newLinkedList()
		for(otherClass : otherClasses){
			if(classes.contains(otherClass)){
				conflicts.add(otherClass.name)
			}
		}
		return conflicts
	}
	
	@Check
	def matchingParameterArguments(PatternCall pc){
		var neededParams = 0
		var actualParams = 0
				
		if(pc.called.parameters !== null){
			neededParams = pc.called.parameters.length
		}
		if(pc.params !== null){
			actualParams = pc.params.length
		}
		
		if(neededParams != actualParams){
			error("Pattern " + pc.called.name + " expects " + neededParams + " parameters but was given " + actualParams, MGLangPackage.Literals.PATTERN_CALL__PARAMS)
		}
	}
	
	@Check
	def matchingParameterTypes(PatternCall pc){
		for(i : 0  ..< pc.params.length){
			val given = pc.params.get(i)
			val needed = pc.called.parameters.get(i)
			if(areTypesMatching(given, needed) == false){
				error("Given object " + given + " does not match needed type " + needed, MGLangPackage.Literals.PATTERN_CALL__PARAMS)				
			}
		}
	}

	def private areTypesMatching(ArithmeticExpression givenExpression, Parameter neededObj){
		val eval = calc.evaluate(givenExpression)
		
		if(eval instanceof EOperation){
			//val op = eval as EOperation
			return true;	//TODO Type checking with maps and lists? e.g. get? how to infer/keep track of type of collection? Or possibly only do this at runtime?
		}
		
		if(neededObj instanceof PrimitiveParameter){
			switch(neededObj.type){
				case INT: return eval instanceof Double && (Math.floor(eval as Double) == eval)
				case CHAR: return false //TODO
				case DOUBLE: return eval instanceof Double
				case STRING: return eval instanceof String
			}
		}
		if(neededObj instanceof ParameterNode){
			//TODO
		}
		return false
	}
	
	
}
