/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.validation

import com.google.inject.Inject
import org.eclipse.emf.ecore.EOperation
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.mofgen.interpreter.Calculator
import org.mofgen.mGLang.ArithmeticExpression
import org.mofgen.mGLang.Import
import org.mofgen.mGLang.MGLangPackage
import org.mofgen.mGLang.PatternCall
import org.mofgen.utils.MofgenModelUtils
import org.mofgen.mGLang.RefOrCall
import org.mofgen.mGLang.Assignment
import org.eclipse.emf.ecore.EAttribute
import org.mofgen.interpreter.MismatchingTypesException
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.mofgen.mGLang.RangeForHead
import org.mofgen.mGLang.ForBody
import org.mofgen.interpreter.TypeCalculator
import org.mofgen.typeModel.TypeModelPackage
import org.eclipse.emf.ecore.EcorePackage
import org.eclipse.emf.ecore.EClass
import org.mofgen.interpreter.TypeRegistry
import org.mofgen.mGLang.List
import org.mofgen.mGLang.Map
import org.mofgen.mGLang.ParamManipulation
import org.mofgen.mGLang.PatternNodeReference
import org.mofgen.mGLang.Case

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGLangValidator extends AbstractMGLangValidator {

	@Inject Calculator calc
	@Inject TypeCalculator typeChecker

	/**
	 * Checks for a valid for range.
	 */
	@Check
	def validForRange(RangeForHead head) {
		val forRange = head.range
		if (forRange !== null) {
			if (forRange.start !== null && forRange.end !== null) {
				val start = forRange.start
				val end = forRange.end
				val check1 = checkForNumber(forRange.start, forRange, MGLangPackage.Literals.FOR_RANGE__START)
				val check2 = checkForNumber(forRange.end, forRange, MGLangPackage.Literals.FOR_RANGE__END)
				if (check1 && check2) {
					val castStart = calc.evaluate(start) as Double
					val castEnd = calc.evaluate(end) as Double
					if (castStart > castEnd) {
						error("Limiting bound is less than starting value",
							MGLangPackage.Literals.RANGE_FOR_HEAD__RANGE)
					}
				}
			}
		}
	}

	/**
	 * Error at errorLoc if the given obj does not evaluate to a numerical value.
	 */
	def private checkForNumber(ArithmeticExpression expr, EObject obj, EReference errorLoc) {
		try {
			val eval = typeChecker.evaluate(expr)
			if (eval !== TypeModelPackage.Literals.NUMBER && !(eval instanceof EObject)) {
				error("For-Range needs numerical bounds but was given type " + eval.name, obj, errorLoc)
				return false
			}else{
				return true
			}
		} catch (MismatchingTypesException e) {
			error(e.message, obj, errorLoc)
		}
	}

	@Check
	def checkCaseCompleteness(Case caze){
		if(!caze.caseSet && !caze.whenSet){
			error("at least one 'case'- or 'when'-expression expected.", caze, MGLangPackage.Literals.CASE__BODY)
		}
	}

	/**
	 * Warns for empty for-loops.
	 */
	@Check
	def warnEmptyForLoop(ForBody body) {
		if (body.commands.empty) {
			warning("empty for-loop", body.eContainer, MGLangPackage.Literals.FOR_STATEMENT__HEAD)
		}
	}

	/** 
	 * Checks whether the value given in a when-expression is boolean.
	 */
	@Check
	def checkBooleanWhen(Case caze) {
		if (caze.when !== null) {
			try {
				val res = typeChecker.evaluate(caze.when)
				if (res !== TypeModelPackage.Literals.BOOLEAN) {
					error("Needs boolean value for conditional expression", caze, MGLangPackage.Literals.CASE__WHEN)
				}
			} catch (MismatchingTypesException e) {
				error(e.message, caze, MGLangPackage.Literals.CASE__WHEN)
			}
		}
	}

	/**
	 * Warns for imported models with conflicting class names.
	 */
	@Check
	def checkForImportConflicts(Import imp) {
		var imports = EcoreUtil2.getAllContentsOfType(MofgenModelUtils.getRootFile(imp), Import)
		imports.remove(imp)
		val duplicateClasses = checkImportsForDuplicates(imports, imp)
		if (!duplicateClasses.isEmpty) {
			warning("Import conflict for classes with names" + duplicateClasses.toString,
				MGLangPackage.Literals.IMPORT__URI)
		}
	}

	def checkImportsForDuplicates(java.util.List<Import> imps, Import otherImp) {
		var conflicts = newLinkedList()

		if(imps.isEmpty) return conflicts

		val classes = MofgenModelUtils.getClassesFromImportList(imps)
		val otherClasses = MofgenModelUtils.getClassesFromImport(otherImp)
		for (otherClass : otherClasses) {
			if (classes.contains(otherClass)) {
				conflicts.add(otherClass.name)
			}
		}
		return conflicts
	}

	/**
	 * Forbid attributes and references with multiplicity 1. Still allowed are additions to *-references by adding them to the collection.
	 */
	@Check
	def checkParamManipulation(ParamManipulation manip) {
		val refsAssigns = manip.content.refsAssigns
		for (refAssign : refsAssigns) {
			switch refAssign {
				Assignment:
					error("No assignments to attributes of parameter node allowed.", refAssign,
						MGLangPackage.Literals.ASSIGNMENT__TARGET)
				PatternNodeReference: {
					if (refAssign.type.upperBound == 1) {
						error("No assignments to 1-edges/-references of parameter nodes allowed.", refAssign,
							MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE)
					}
				}
			}
		}
	}

	@Check
	def checkAttributeType(Assignment ass) {
		val trg = ass.target
		if (trg instanceof EAttribute) {
			val attribute = trg as EAttribute
			val attributeType = MofgenModelUtils.getEClassForInternalModel(attribute.EAttributeType)

			try {
				val assignedValue = MofgenModelUtils.getEClassForInternalModel(typeChecker.evaluate(ass.value))
				if (assignedValue != TypeModelPackage.Literals.ENUM_LITERAL &&
					attributeType == TypeModelPackage.Literals.ENUM) {
					error("Can only assign enum values to enum attribute " + attribute.name,
						MGLangPackage.Literals.ASSIGNMENT__VALUE)
				} else {
					if (assignedValue == TypeModelPackage.Literals.ENUM_LITERAL &&
						attributeType != TypeModelPackage.Literals.ENUM) {
						error("Cannot assign enum value to non-enum attribute " + attribute.name,
							MGLangPackage.Literals.ASSIGNMENT__VALUE)
					}
				}
			} catch (MismatchingTypesException e) {
				error(e.message, ass, MGLangPackage.Literals.ASSIGNMENT__VALUE)
			}
		}
	}

	@Check
	def matchingParameters_pc(PatternCall pc) {
		// check parameter count
		var neededParams = 0
		var actualParams = 0

		if (pc.called.parameters !== null) {
			neededParams = pc.called.parameters.length
		}
		if (pc.params.params !== null) {
			actualParams = pc.params.params.length
		}

		if (neededParams != actualParams) {
			error("Pattern " + pc.called.name + " expects " + neededParams + " parameters but was given " +
				actualParams, MGLangPackage.Literals.PATTERN_CALL__PARAMS)
			return;
		}

		// check parameter types
		for (i : 0 ..< pc.params.params.length) {
			val givenParameterExpression = pc.params.params.get(i)
			val neededParameter = pc.called.parameters.get(i)

			val givenParameterType = typeChecker.evaluate(givenParameterExpression)
			val neededParameterType = MofgenModelUtils.getInternalParameterType(neededParameter)

			if (givenParameterType instanceof EClass && neededParameterType instanceof EClass &&
				!(neededParameterType.isSuperTypeOf(givenParameterType))) {
				// TODO Is it right that any object fits into an eobject parameter?
				if (neededParameterType !== EcorePackage.Literals.EOBJECT) {
					if (givenParameterType !== neededParameterType) {
						error("Given type " + givenParameterType.name + " does not match needed type " +
							neededParameterType.name, MGLangPackage.Literals.PATTERN_CALL__PARAMS)
					}
				}
			}
		}
	}

	@Check
	def matchingParameters_roc(RefOrCall roc) {
		if (roc.ref instanceof EOperation) {
			if (!roc.bracesSet) {
				error("Missing parameter list", MGLangPackage.Literals.REF_OR_CALL__PARAMS)
				return;
			} else {
				val op = roc.ref as EOperation
				val givenParams = roc.params.params
				var neededParams = newLinkedList()

				if (op == TypeModelPackage.Literals.LIST___INDEX_OF__EOBJECT ||
					op == TypeModelPackage.Literals.LIST___ADD__EOBJECT ||
					op == TypeModelPackage.Literals.LIST___REMOVE__EOBJECT ||
					op == TypeModelPackage.Literals.LIST___CONTAINS__EOBJECT) {
					neededParams.add(TypeRegistry.getListType(roc.target.ref as List))
				} else if (op == TypeModelPackage.Literals.MAP___CONTAINS_KEY__EOBJECT ||
					op == TypeModelPackage.Literals.MAP___GET__EOBJECT) {
					neededParams.add(TypeRegistry.getMapKeyType(roc.target.ref as Map))
				} else if (op == TypeModelPackage.Literals.MAP___CONTAINS_VALUE__EOBJECT ||
					op == TypeModelPackage.Literals.MAP___GET_KEY_TO_ENTRY__EOBJECT) {
					neededParams.add(TypeRegistry.getMapEntryType(roc.target.ref as Map))
				} else if (op == TypeModelPackage.Literals.MAP___PUT__EOBJECT_EOBJECT) {
					neededParams.add(TypeRegistry.getMapKeyType(roc.target.ref as Map))
					neededParams.add(TypeRegistry.getMapEntryType(roc.target.ref as Map))
				} else {
					neededParams.addAll(op.EParameters.map[x|x.EType])
				}

				// Check parameter count
				if (givenParams.size != neededParams.size) {
					error("Method " + op.name + " expects " + neededParams.size + " parameters but was given " +
						givenParams.size, MGLangPackage.Literals.REF_OR_CALL__PARAMS)
					return;
				}

				// Check parameter types
				for (var i = 0; i < givenParams.size; i++) {
					try {
						val givenParameterType = MofgenModelUtils.getEClassForInternalModel(
							typeChecker.evaluate(givenParams.get(i)))
						val neededParameterType = MofgenModelUtils.getEClassForInternalModel(neededParams.get(i))

						if (!(givenParameterType instanceof EClass && neededParameterType instanceof EClass &&
							neededParameterType.isSuperTypeOf(givenParameterType))) {
							// TODO Is it right that any object fits into an eobject parameter?
							if (neededParameterType !== EcorePackage.Literals.EOBJECT) {
								if (givenParameterType !== neededParameterType) {
									error(
										"Given parameter type " + givenParameterType.name +
											" does not match needed parameter type " + neededParameterType.name,
										MGLangPackage.Literals.REF_OR_CALL__PARAMS)
								}
							}
						}
					} catch (MismatchingTypesException e) {
						error(e.message, MGLangPackage.Literals.REF_OR_CALL__PARAMS)
					}
				}
			}
		} else {
			if (roc.bracesSet) {
				error(roc.ref + " is not a method", MGLangPackage.Literals.REF_OR_CALL__BRACES_SET) // TODO Correct highlighting?
				return;
			}
		}
	}

}
