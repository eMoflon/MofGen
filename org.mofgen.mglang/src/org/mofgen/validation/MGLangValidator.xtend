/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.validation

import com.google.inject.Inject
import java.util.List
import org.eclipse.emf.ecore.EOperation
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.mofgen.interpreter.Calculator
import org.mofgen.mGLang.ArithmeticExpression
import org.mofgen.mGLang.GeneralForHead
import org.mofgen.mGLang.Import
import org.mofgen.mGLang.MGLangPackage
import org.mofgen.mGLang.Parameter
import org.mofgen.mGLang.PatternCall
import org.mofgen.mGLang.PrimitiveParameter
import org.mofgen.utils.MofgenModelUtils
import org.mofgen.mGLang.ParameterNode
import org.mofgen.mGLang.CaseWithCast
import org.mofgen.mGLang.RefOrCall
import org.mofgen.mGLang.Node
import org.mofgen.mGLang.Collection
import org.mofgen.mGLang.Assignment
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EEnumLiteral
import org.mofgen.interpreter.MismatchingTypesException
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MGLangValidator extends AbstractMGLangValidator {

	@Inject Calculator calc

	// TODO Check if there are sufficient null checks so no strange errors occur in the editor
	@Check
	def validForRange(GeneralForHead head) {

		val forRange = head.range
		val castStart = checkForNumber(head.range.start, forRange, MGLangPackage.Literals.FOR_RANGE__START) as Double
		val castEnd = checkForNumber(head.range.end, forRange, MGLangPackage.Literals.FOR_RANGE__END) as Double
		
		if (castStart > castEnd) {
			error("Limiting bound is less than starting value", MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE)
		}
	}

	def private checkForNumber(ArithmeticExpression expr, EObject obj, EReference errorLoc) {
			val eval = tryEvaluation(expr, obj, errorLoc)
			if (!(eval instanceof Number)) {
				error("For-Range needs numerical bounds but was given type " + eval.class.name, obj, errorLoc)
			}
			return eval
	}

	@Check
	def checkBooleanWhen(CaseWithCast caze) {
		if (caze.when !== null) {
			try{
			val res = tryEvaluation(caze.when, caze, MGLangPackage.Literals.CASE_WITH_CAST__WHEN) 
			if (!(res instanceof Boolean)) {
				error("Needed boolean value for conditional expression", MGLangPackage.Literals.CASE_WITH_CAST__WHEN)
			}
			}catch(MismatchingTypesException e){
				error(e.message, caze, MGLangPackage.Literals.CASE_WITH_CAST__WHEN)
			}
		}
	}

	@Check
	def checkForImportConclicts(Import imp) {
		var imports = EcoreUtil2.getAllContentsOfType(MofgenModelUtils.getRootFile(imp), Import)
		imports.remove(imp)
		val duplicateClasses = checkImportsForDuplicates(imports, imp)
		if (!duplicateClasses.isEmpty) {
			warning("Import conflict for classes with names" + duplicateClasses.toString,
				MGLangPackage.Literals.IMPORT__URI)
		}
	}

	def checkImportsForDuplicates(List<Import> imps, Import otherImp) {
		var conflicts = newLinkedList()

		if(imps.isEmpty) return conflicts

		val classes = MofgenModelUtils.getClassesFromImportList(imps)
		val otherClasses = MofgenModelUtils.getClassesFromImport(otherImp)
		for (otherClass : otherClasses) {
			if (classes.contains(otherClass)) {
				conflicts.add(otherClass.name)
			}
		}
		return conflicts
	}

	@Check
	def checkAttributeType(Assignment ass) {
		val trg = ass.target
		val assignedValue = tryEvaluation(ass.value, ass, MGLangPackage.Literals.ASSIGNMENT__VALUE)

		if (trg instanceof EAttribute) {
			val attribute = trg as EAttribute
			val attributeType = attribute.EAttributeType
			if (attributeType instanceof EEnum) {
				if (!(assignedValue instanceof EEnumLiteral)) {
					error("Can only assign enum values to enum attribute " + attribute.name,
						MGLangPackage.Literals.ASSIGNMENT__VALUE)
				}
			} else {
				if (assignedValue instanceof EEnumLiteral) {
					error("Cannot assign enum value to non-enum attribute " + attribute.name,
						MGLangPackage.Literals.ASSIGNMENT__VALUE)
				}
			}
		}
	}


	@Check
	def matchingParameterArguments(PatternCall pc) {
		var neededParams = 0
		var actualParams = 0

		if (pc.called.parameters !== null) {
			neededParams = pc.called.parameters.length
		}
		if (pc.params !== null) {
			actualParams = pc.params.length
		}

		if (neededParams != actualParams) {
			error("Pattern " + pc.called.name + " expects " + neededParams + " parameters but was given " +
				actualParams, MGLangPackage.Literals.PATTERN_CALL__PARAMS)
		}
	}

	@Check
	def matchingParameterTypes(PatternCall pc) {
		for (i : 0 ..< pc.params.length) {
			val given = pc.params.get(i)
			val needed = pc.called.parameters.get(i)
			if (isTypeMatchingWithParameter(given, needed, pc, MGLangPackage.Literals.PATTERN_CALL__PARAMS) == false) {
				error("Given object " + given + " does not match needed type " + needed,
					MGLangPackage.Literals.PATTERN_CALL__PARAMS)
			}
		}
	}

	@Check
	def matchingParameterArguments_roc(RefOrCall roc) {
		if (roc.ref instanceof EOperation && !roc.bracesSet) {
			error("Missing parameter list", MGLangPackage.Literals.REF_OR_CALL__PARAMS)
			return;
		}
		if (roc.ref instanceof EOperation) {
			val op = roc.ref as EOperation
			val givenParams = roc.params.params
			val neededParams = op.EParameters

			// Check parameter count
			if (givenParams.size != neededParams.size) {
				error("Method " + op.name + " expects " + neededParams.size + " parameters but was given " +
					givenParams.size, MGLangPackage.Literals.REF_OR_CALL__PARAMS)
				return;
			}

		// TODO Check parameter types ?
		}
	}
		
	def tryEvaluation(ArithmeticExpression expr, EObject errorObj, EReference errorLoc){
		try{
			val eval = calc.evaluate(expr)
			return eval
		} catch (MismatchingTypesException e){
			error(e.message, errorObj, errorLoc)
		}
	}

	def private isTypeMatchingWithParameter(ArithmeticExpression givenExpression, Parameter neededObj, EObject errorObj, EReference errorLoc) {
		val eval = tryEvaluation(givenExpression, errorObj, errorLoc) 
		
		if (eval instanceof EOperation) {
			// val op = eval as EOperation
			return true; // TODO Type checking with maps and lists? e.g. get? how to infer/keep track of type of collection? ==> Possible do this only at runtime and fall back to EObject in the case of conflicts
		}
		if (eval instanceof PatternCall) {
			return true; // TODO Type Checking for pattern calls? --> Even allow pattern calls in parameter lists or need to separate return-value into variable?
		}

		if (neededObj instanceof PrimitiveParameter) {
			switch (neededObj.type) {
				case INT: return eval instanceof Double && (Math.floor(eval as Double) == eval)
				case DOUBLE: return eval instanceof Double
				case STRING: return eval instanceof String
				case CHAR: return eval instanceof Character || eval instanceof String && (eval as String).length == 1
			}
		}
		if (neededObj instanceof ParameterNode) {
			return eval instanceof Node || eval instanceof ParameterNode
		}
		if (neededObj instanceof Collection) {
			return eval instanceof Collection
		}

	}

}
