/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mofgen.mGLang.And;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.BooleanExpression;
import org.mofgen.mGLang.BooleanLiteral;
import org.mofgen.mGLang.Concat;
import org.mofgen.mGLang.ForEachCollection;
import org.mofgen.mGLang.ForLoop;
import org.mofgen.mGLang.ForRange;
import org.mofgen.mGLang.GenPatternCall;
import org.mofgen.mGLang.Generator;
import org.mofgen.mGLang.Import;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.MethodCall;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.NegatedBoolean;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.NodeAttributeCall;
import org.mofgen.mGLang.NodeConstructor;
import org.mofgen.mGLang.NumberLiteral;
import org.mofgen.mGLang.ObjectParameter;
import org.mofgen.mGLang.Or;
import org.mofgen.mGLang.ParameterRef;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternCall;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.PatternObject;
import org.mofgen.mGLang.PatternObjectCreation;
import org.mofgen.mGLang.PatternReturn;
import org.mofgen.mGLang.PrimitiveParameter;
import org.mofgen.mGLang.STRING;
import org.mofgen.mGLang.Xor;
import org.mofgen.services.MGLangGrammarAccess;

@SuppressWarnings("all")
public class MGLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGLangPackage.AND:
				sequence_BooleanAnd(context, (And) semanticObject); 
				return; 
			case MGLangPackage.ASSIGNMENT:
				if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_Assignment_NodeReferenceOrAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.BOOLEAN_EXPRESSION:
				sequence_RelationExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case MGLangPackage.BOOLEAN_LITERAL:
				sequence_BaseBoolean(context, (BooleanLiteral) semanticObject); 
				return; 
			case MGLangPackage.CONCAT:
				sequence_StringConcatenation(context, (Concat) semanticObject); 
				return; 
			case MGLangPackage.FOR_EACH_COLLECTION:
				sequence_ForEachCollection(context, (ForEachCollection) semanticObject); 
				return; 
			case MGLangPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case MGLangPackage.FOR_RANGE:
				sequence_ForRange(context, (ForRange) semanticObject); 
				return; 
			case MGLangPackage.GEN_PATTERN_CALL:
				sequence_GenPatternCall(context, (GenPatternCall) semanticObject); 
				return; 
			case MGLangPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case MGLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MGLangPackage.METHOD_CALL:
				sequence_MethodCall(context, (MethodCall) semanticObject); 
				return; 
			case MGLangPackage.MOFGEN_FILE:
				sequence_MofgenFile(context, (MofgenFile) semanticObject); 
				return; 
			case MGLangPackage.NEGATED_BOOLEAN:
				sequence_BaseBoolean(context, (NegatedBoolean) semanticObject); 
				return; 
			case MGLangPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MGLangPackage.NODE_ATTRIBUTE_CALL:
				sequence_NodeAttributeCall(context, (NodeAttributeCall) semanticObject); 
				return; 
			case MGLangPackage.NODE_CONSTRUCTOR:
				sequence_NodeConstructor(context, (NodeConstructor) semanticObject); 
				return; 
			case MGLangPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case MGLangPackage.OBJECT_PARAMETER:
				sequence_ObjectParameter(context, (ObjectParameter) semanticObject); 
				return; 
			case MGLangPackage.OR:
				sequence_BooleanOr(context, (Or) semanticObject); 
				return; 
			case MGLangPackage.PARAMETER_REF:
				sequence_ParameterRef(context, (ParameterRef) semanticObject); 
				return; 
			case MGLangPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_CALL:
				sequence_PatternCall(context, (PatternCall) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_REFERENCE:
				if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_NodeReferenceOrAssignment_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternNodeReferenceRule()) {
					sequence_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.PATTERN_OBJECT:
				sequence_PatternObject(context, (PatternObject) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_OBJECT_CREATION:
				sequence_PatternObjectCreation(context, (PatternObjectCreation) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_RETURN:
				sequence_PatternReturn(context, (PatternReturn) semanticObject); 
				return; 
			case MGLangPackage.PRIMITIVE_PARAMETER:
				sequence_PrimitiveParameter(context, (PrimitiveParameter) semanticObject); 
				return; 
			case MGLangPackage.STRING:
				sequence_StringLiteral(context, (STRING) semanticObject); 
				return; 
			case MGLangPackage.XOR:
				sequence_BooleanXor(context, (Xor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=StringExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetEAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.ASSIGNMENT__TARGET, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getValueStringExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=StringExpression condition=BooleanExpression?)
	 */
	protected void sequence_Assignment_NodeReferenceOrAssignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanLiteral
	 *     BooleanOr returns BooleanLiteral
	 *     BooleanOr.Or_1_0 returns BooleanLiteral
	 *     BooleanXor returns BooleanLiteral
	 *     BooleanXor.Xor_1_0 returns BooleanLiteral
	 *     BooleanAnd returns BooleanLiteral
	 *     BooleanAnd.And_1_0 returns BooleanLiteral
	 *     BaseBoolean returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_BaseBoolean(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseBooleanAccess().getValueBooleanEnumRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns NegatedBoolean
	 *     BooleanOr returns NegatedBoolean
	 *     BooleanOr.Or_1_0 returns NegatedBoolean
	 *     BooleanXor returns NegatedBoolean
	 *     BooleanXor.Xor_1_0 returns NegatedBoolean
	 *     BooleanAnd returns NegatedBoolean
	 *     BooleanAnd.And_1_0 returns NegatedBoolean
	 *     BaseBoolean returns NegatedBoolean
	 *
	 * Constraint:
	 *     expr=BooleanExpression
	 */
	protected void sequence_BaseBoolean(ISerializationContext context, NegatedBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NEGATED_BOOLEAN__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NEGATED_BOOLEAN__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseBooleanAccess().getExprBooleanExpressionParserRuleCall_0_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns And
	 *     BooleanOr returns And
	 *     BooleanOr.Or_1_0 returns And
	 *     BooleanXor returns And
	 *     BooleanXor.Xor_1_0 returns And
	 *     BooleanAnd returns And
	 *     BooleanAnd.And_1_0 returns And
	 *     BaseBoolean returns And
	 *
	 * Constraint:
	 *     (left=BooleanAnd_And_1_0 right=BaseBoolean)
	 */
	protected void sequence_BooleanAnd(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanAndAccess().getRightBaseBooleanParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Or
	 *     BooleanOr returns Or
	 *     BooleanOr.Or_1_0 returns Or
	 *     BooleanXor returns Or
	 *     BooleanXor.Xor_1_0 returns Or
	 *     BooleanAnd returns Or
	 *     BooleanAnd.And_1_0 returns Or
	 *     BaseBoolean returns Or
	 *
	 * Constraint:
	 *     (left=BooleanOr_Or_1_0 right=BooleanXor)
	 */
	protected void sequence_BooleanOr(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanOrAccess().getRightBooleanXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Xor
	 *     BooleanOr returns Xor
	 *     BooleanOr.Or_1_0 returns Xor
	 *     BooleanXor returns Xor
	 *     BooleanXor.Xor_1_0 returns Xor
	 *     BooleanAnd returns Xor
	 *     BooleanAnd.And_1_0 returns Xor
	 *     BaseBoolean returns Xor
	 *
	 * Constraint:
	 *     (left=BooleanXor_Xor_1_0 right=BooleanAnd)
	 */
	protected void sequence_BooleanXor(ISerializationContext context, Xor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanXorAccess().getXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBooleanXorAccess().getRightBooleanAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForEachCollection
	 *     ForEachCollection returns ForEachCollection
	 *
	 * Constraint:
	 *     coll=NodeAttributeCall
	 */
	protected void sequence_ForEachCollection(ISerializationContext context, ForEachCollection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachCollectionAccess().getCollNodeAttributeCallParserRuleCall_0(), semanticObject.getColl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (iteratorVar=ID iteratingCondition=ForCondition commands+=GeneratorCommand*)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForRange
	 *     ForRange returns ForRange
	 *
	 * Constraint:
	 *     (start=INT end=INT)
	 */
	protected void sequence_ForRange(ISerializationContext context, ForRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForRangeAccess().getStartINTTerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getForRangeAccess().getEndINTTerminalRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenPatternCall returns GenPatternCall
	 *
	 * Constraint:
	 *     (calledPattern=[Pattern|ID] params+=PatternObject*)
	 */
	protected void sequence_GenPatternCall(ISerializationContext context, GenPatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     commands+=GeneratorElement*
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=STRING alias=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImportAccess().getAliasIDTerminalRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterOrMethodCall returns MethodCall
	 *     MethodCall returns MethodCall
	 *
	 * Constraint:
	 *     (calledNode=[Node|ID] method=[EOperation|ID])
	 */
	protected void sequence_MethodCall(ISerializationContext context, MethodCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.METHOD_CALL__CALLED_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.METHOD_CALL__CALLED_NODE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.METHOD_CALL__METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.METHOD_CALL__METHOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodCallAccess().getCalledNodeNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.METHOD_CALL__CALLED_NODE, false));
		feeder.accept(grammarAccess.getMethodCallAccess().getMethodEOperationIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.METHOD_CALL__METHOD, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MofgenFile returns MofgenFile
	 *
	 * Constraint:
	 *     (imports+=Import+ | (imports+=Import+ (patterns+=Pattern | generators+=Generator)+))?
	 */
	protected void sequence_MofgenFile(ISerializationContext context, MofgenFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeAttributeCall returns NodeAttributeCall
	 *
	 * Constraint:
	 *     (node=[Node|ID] attribute=[EAttribute|ID])
	 */
	protected void sequence_NodeAttributeCall(ISerializationContext context, NodeAttributeCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getNodeNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE, false));
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getAttributeEAttributeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeConstructor returns NodeConstructor
	 *
	 * Constraint:
	 *     refsAssigns+=NodeReferenceOrAssignment*
	 */
	protected void sequence_NodeConstructor(ISerializationContext context, NodeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID] condition=BooleanExpression?)
	 */
	protected void sequence_NodeReferenceOrAssignment_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (type=[EClass|ID] name=ID (createdBy=NodeConstructor | createdBy=PatternCall)?)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNUMBERTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns ObjectParameter
	 *     ObjectParameter returns ObjectParameter
	 *
	 * Constraint:
	 *     (type=[EClassifier|ID] name=ID)
	 */
	protected void sequence_ObjectParameter(ISerializationContext context, ObjectParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.OBJECT_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.OBJECT_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectParameterAccess().getTypeEClassifierIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.OBJECT_PARAMETER__TYPE, false));
		feeder.accept(grammarAccess.getObjectParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterOrMethodCall returns ParameterRef
	 *     ParameterRef returns ParameterRef
	 *
	 * Constraint:
	 *     ref=[Parameter|ID]
	 */
	protected void sequence_ParameterRef(ISerializationContext context, ParameterRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterRefAccess().getRefParameterIDTerminalRuleCall_0_1(), semanticObject.eGet(MGLangPackage.Literals.PARAMETER_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCall returns PatternCall
	 *     GeneratorElement returns PatternCall
	 *     GeneratorCommand returns PatternCall
	 *
	 * Constraint:
	 *     (called=[Pattern|ID] params+=StringExpression*)
	 */
	protected void sequence_PatternCall(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternNodeReference returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID])
	 */
	protected void sequence_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTypeEReferenceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTargetNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns PatternObjectCreation
	 *     GeneratorCommand returns PatternObjectCreation
	 *     PatternObjectCreation returns PatternObjectCreation
	 *
	 * Constraint:
	 *     (pObject=PatternObject patternCall=PatternCall)
	 */
	protected void sequence_PatternObjectCreation(ISerializationContext context, PatternObjectCreation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPObjectPatternObjectParserRuleCall_0_0(), semanticObject.getPObject());
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPatternCallPatternCallParserRuleCall_2_0(), semanticObject.getPatternCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternObject returns PatternObject
	 *
	 * Constraint:
	 *     (type=[Pattern|ID] name=ID)
	 */
	protected void sequence_PatternObject(ISerializationContext context, PatternObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectAccess().getTypePatternIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_OBJECT__TYPE, false));
		feeder.accept(grammarAccess.getPatternObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternReturn returns PatternReturn
	 *
	 * Constraint:
	 *     returnValue=[Node|ID]?
	 */
	protected void sequence_PatternReturn(ISerializationContext context, PatternReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? nodes+=Node* return=PatternReturn?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns PrimitiveParameter
	 *     PrimitiveParameter returns PrimitiveParameter
	 *
	 * Constraint:
	 *     (type=PrimitiveType name=ID)
	 */
	protected void sequence_PrimitiveParameter(ISerializationContext context, PrimitiveParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getTypePrimitiveTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns BooleanExpression
	 *     RelationExpression returns BooleanExpression
	 *     BooleanOr returns BooleanExpression
	 *     BooleanOr.Or_1_0 returns BooleanExpression
	 *     BooleanXor returns BooleanExpression
	 *     BooleanXor.Xor_1_0 returns BooleanExpression
	 *     BooleanAnd returns BooleanExpression
	 *     BooleanAnd.And_1_0 returns BooleanExpression
	 *     BaseBoolean returns BooleanExpression
	 *
	 * Constraint:
	 *     (lhs=ParameterOrMethodCall relation=RelationalOp rhs=ParameterOrMethodCall)
	 */
	protected void sequence_RelationExpression(ISerializationContext context, BooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__LHS));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__RELATION));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.BOOLEAN_EXPRESSION__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationExpressionAccess().getLhsParameterOrMethodCallParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelationRelationalOpEnumRuleCall_1_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRhsParameterOrMethodCallParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringExpression returns Concat
	 *     StringConcatenation returns Concat
	 *
	 * Constraint:
	 *     (left=StringConcatenation_Concat_1_0 right=StringConcatenation)
	 */
	protected void sequence_StringConcatenation(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CONCAT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CONCAT__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CONCAT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CONCAT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConcatenationAccess().getConcatLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getStringConcatenationAccess().getRightStringConcatenationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringExpression returns STRING
	 *     StringConcatenation returns STRING
	 *     StringConcatenation.Concat_1_0 returns STRING
	 *     StringLiteral returns STRING
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, STRING semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
