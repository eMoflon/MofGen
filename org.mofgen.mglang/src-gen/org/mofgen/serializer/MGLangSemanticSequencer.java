/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.BooleanLiteral;
import org.mofgen.mGLang.Condition;
import org.mofgen.mGLang.ForEachCollection;
import org.mofgen.mGLang.ForLoop;
import org.mofgen.mGLang.ForRange;
import org.mofgen.mGLang.Generator;
import org.mofgen.mGLang.Import;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.NodeAttributeCall;
import org.mofgen.mGLang.NodeConstructor;
import org.mofgen.mGLang.NumberLiteral;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternCall;
import org.mofgen.mGLang.PatternNodeCreation;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.PatternObject;
import org.mofgen.mGLang.PatternObjectCreation;
import org.mofgen.mGLang.PatternReturn;
import org.mofgen.mGLang.StringLiteral;
import org.mofgen.services.MGLangGrammarAccess;

@SuppressWarnings("all")
public class MGLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGLangPackage.ASSIGNMENT:
				if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_Assignment_NodeReferenceOrAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.BOOLEAN_LITERAL:
				sequence_LiteralExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case MGLangPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MGLangPackage.FOR_EACH_COLLECTION:
				sequence_ForEachCollection(context, (ForEachCollection) semanticObject); 
				return; 
			case MGLangPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case MGLangPackage.FOR_RANGE:
				sequence_ForRange(context, (ForRange) semanticObject); 
				return; 
			case MGLangPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case MGLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MGLangPackage.MOFGEN_FILE:
				sequence_MofgenFile(context, (MofgenFile) semanticObject); 
				return; 
			case MGLangPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MGLangPackage.NODE_ATTRIBUTE_CALL:
				sequence_NodeAttributeCall(context, (NodeAttributeCall) semanticObject); 
				return; 
			case MGLangPackage.NODE_CONSTRUCTOR:
				sequence_NodeConstructor(context, (NodeConstructor) semanticObject); 
				return; 
			case MGLangPackage.NUMBER_LITERAL:
				sequence_LiteralExpression(context, (NumberLiteral) semanticObject); 
				return; 
			case MGLangPackage.PARAMETER:
				sequence_Parameter(context, (org.mofgen.mGLang.Parameter) semanticObject); 
				return; 
			case MGLangPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_CALL:
				sequence_PatternCall(context, (PatternCall) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_CREATION:
				sequence_PatternNodeCreation(context, (PatternNodeCreation) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_REFERENCE:
				if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_NodeReferenceOrAssignment_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternNodeReferenceRule()) {
					sequence_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.PATTERN_OBJECT:
				sequence_PatternObject(context, (PatternObject) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_OBJECT_CREATION:
				sequence_PatternObjectCreation(context, (PatternObjectCreation) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_RETURN:
				sequence_PatternReturn(context, (PatternReturn) semanticObject); 
				return; 
			case MGLangPackage.STRING_LITERAL:
				sequence_LiteralExpression(context, (StringLiteral) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=NodeAttributeCall value=LiteralExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetNodeAttributeCallParserRuleCall_0_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueLiteralExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns Assignment
	 *
	 * Constraint:
	 *     (target=NodeAttributeCall value=LiteralExpression condition=Condition?)
	 */
	protected void sequence_Assignment_NodeReferenceOrAssignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (lhs=[Parameter|ID] (relation=EditorRelation rhs=[Parameter|ID])?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForEachCollection
	 *     ForEachCollection returns ForEachCollection
	 *
	 * Constraint:
	 *     coll=NodeAttributeCall
	 */
	protected void sequence_ForEachCollection(ISerializationContext context, ForEachCollection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachCollectionAccess().getCollNodeAttributeCallParserRuleCall_0(), semanticObject.getColl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (iteratorVar=ID iteratingCondition=ForCondition commands+=GeneratorCommand*)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForRange
	 *     ForRange returns ForRange
	 *
	 * Constraint:
	 *     (start=INT end=INT)
	 */
	protected void sequence_ForRange(ISerializationContext context, ForRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForRangeAccess().getStartINTTerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getForRangeAccess().getEndINTTerminalRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     (name=ID commands+=GeneratorElement*)
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=STRING alias=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImportAccess().getAliasIDTerminalRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     {NumberLiteral}
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MofgenFile returns MofgenFile
	 *
	 * Constraint:
	 *     (imports+=Import+ | (imports+=Import+ (patterns+=Pattern | generators+=Generator)+))?
	 */
	protected void sequence_MofgenFile(ISerializationContext context, MofgenFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeAttributeCall returns NodeAttributeCall
	 *
	 * Constraint:
	 *     (object=[Node|ID] attribute=[EAttribute|ID])
	 */
	protected void sequence_NodeAttributeCall(ISerializationContext context, NodeAttributeCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__OBJECT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getObjectNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__OBJECT, false));
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getAttributeEAttributeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeConstructor returns NodeConstructor
	 *
	 * Constraint:
	 *     params+=LiteralExpression*
	 */
	protected void sequence_NodeConstructor(ISerializationContext context, NodeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns PatternNodeReference
	 *
	 * Constraint:
	 *     (source=[Node|ID] type=[EReference|ID] target=[Node|ID] condition=Condition?)
	 */
	protected void sequence_NodeReferenceOrAssignment_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (type=[EClass|ID] name=ID)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAccess().getTypeEClassIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE__TYPE, false));
		feeder.accept(grammarAccess.getNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=[EClassifier|ID])
	 */
	protected void sequence_Parameter(ISerializationContext context, org.mofgen.mGLang.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeEClassifierIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PARAMETER__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns PatternCall
	 *     GeneratorCommand returns PatternCall
	 *     PatternCall returns PatternCall
	 *
	 * Constraint:
	 *     (calledPattern=[Pattern|ID] params+=PatternObject*)
	 */
	protected void sequence_PatternCall(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternNodeCreation returns PatternNodeCreation
	 *
	 * Constraint:
	 *     (node=Node constructor=NodeConstructor?)
	 */
	protected void sequence_PatternNodeCreation(ISerializationContext context, PatternNodeCreation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternNodeReference returns PatternNodeReference
	 *
	 * Constraint:
	 *     (source=[Node|ID] type=[EReference|ID] target=[Node|ID])
	 */
	protected void sequence_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getSourceNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__SOURCE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTypeEReferenceIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTargetNodeIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns PatternObjectCreation
	 *     GeneratorCommand returns PatternObjectCreation
	 *     PatternObjectCreation returns PatternObjectCreation
	 *
	 * Constraint:
	 *     (pObject=PatternObject patternCall=PatternCall)
	 */
	protected void sequence_PatternObjectCreation(ISerializationContext context, PatternObjectCreation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPObjectPatternObjectParserRuleCall_0_0(), semanticObject.getPObject());
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPatternCallPatternCallParserRuleCall_2_0(), semanticObject.getPatternCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternObject returns PatternObject
	 *
	 * Constraint:
	 *     (type=[Pattern|ID] name=ID)
	 */
	protected void sequence_PatternObject(ISerializationContext context, PatternObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectAccess().getTypePatternIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_OBJECT__TYPE, false));
		feeder.accept(grammarAccess.getPatternObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternReturn returns PatternReturn
	 *
	 * Constraint:
	 *     thisUsed?='this'
	 */
	protected void sequence_PatternReturn(ISerializationContext context, PatternReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_RETURN__THIS_USED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_RETURN__THIS_USED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternReturnAccess().getThisUsedThisKeyword_1_0(), semanticObject.isThisUsed());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (nodes+=PatternNodeCreation | refsAssigns+=NodeReferenceOrAssignment)* 
	 *         return=PatternReturn
	 *     )
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
