/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.BooleanLiteral;
import org.mofgen.mGLang.CaseBody;
import org.mofgen.mGLang.CaseWithCast;
import org.mofgen.mGLang.CaseWithoutCast;
import org.mofgen.mGLang.Config;
import org.mofgen.mGLang.ForBody;
import org.mofgen.mGLang.ForEachHead;
import org.mofgen.mGLang.ForRange;
import org.mofgen.mGLang.ForStatement;
import org.mofgen.mGLang.FunctionCall;
import org.mofgen.mGLang.GeneralForHead;
import org.mofgen.mGLang.Generator;
import org.mofgen.mGLang.IfElseCase;
import org.mofgen.mGLang.IfElseSwitch;
import org.mofgen.mGLang.Import;
import org.mofgen.mGLang.List;
import org.mofgen.mGLang.ListAdHoc;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.Map;
import org.mofgen.mGLang.MapAdHoc;
import org.mofgen.mGLang.MapTupel;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.NegationExpression;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.NodeContent;
import org.mofgen.mGLang.NumberLiteral;
import org.mofgen.mGLang.ParamManipulation;
import org.mofgen.mGLang.ParameterNode;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternCall;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.PatternReturn;
import org.mofgen.mGLang.PatternVariable;
import org.mofgen.mGLang.Primary;
import org.mofgen.mGLang.PrimitiveParameter;
import org.mofgen.mGLang.RefOrCall;
import org.mofgen.mGLang.RefParams;
import org.mofgen.mGLang.Rel;
import org.mofgen.mGLang.Secondary;
import org.mofgen.mGLang.StringLiteral;
import org.mofgen.mGLang.SwitchCase;
import org.mofgen.mGLang.Tertiary;
import org.mofgen.mGLang.Variable;
import org.mofgen.services.MGLangGrammarAccess;

@SuppressWarnings("all")
public class MGLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGLangPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MGLangPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case MGLangPackage.CASE_BODY:
				sequence_CaseBody(context, (CaseBody) semanticObject); 
				return; 
			case MGLangPackage.CASE_WITH_CAST:
				sequence_CaseWithCast(context, (CaseWithCast) semanticObject); 
				return; 
			case MGLangPackage.CASE_WITHOUT_CAST:
				sequence_CaseWithoutCast(context, (CaseWithoutCast) semanticObject); 
				return; 
			case MGLangPackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case MGLangPackage.FOR_BODY:
				sequence_ForBody(context, (ForBody) semanticObject); 
				return; 
			case MGLangPackage.FOR_EACH_HEAD:
				sequence_ForEachHead(context, (ForEachHead) semanticObject); 
				return; 
			case MGLangPackage.FOR_RANGE:
				sequence_ForRange(context, (ForRange) semanticObject); 
				return; 
			case MGLangPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MGLangPackage.FUNCTION_CALL:
				sequence_BaseExpr(context, (FunctionCall) semanticObject); 
				return; 
			case MGLangPackage.GENERAL_FOR_HEAD:
				sequence_GeneralForHead(context, (GeneralForHead) semanticObject); 
				return; 
			case MGLangPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case MGLangPackage.IF_ELSE_CASE:
				sequence_IfElseCase(context, (IfElseCase) semanticObject); 
				return; 
			case MGLangPackage.IF_ELSE_SWITCH:
				sequence_IfElseSwitch(context, (IfElseSwitch) semanticObject); 
				return; 
			case MGLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MGLangPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case MGLangPackage.LIST_AD_HOC:
				sequence_ListAdHoc(context, (ListAdHoc) semanticObject); 
				return; 
			case MGLangPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case MGLangPackage.MAP_AD_HOC:
				sequence_MapAdHoc(context, (MapAdHoc) semanticObject); 
				return; 
			case MGLangPackage.MAP_TUPEL:
				sequence_MapTupel(context, (MapTupel) semanticObject); 
				return; 
			case MGLangPackage.MOFGEN_FILE:
				sequence_MofgenFile(context, (MofgenFile) semanticObject); 
				return; 
			case MGLangPackage.NEGATION_EXPRESSION:
				sequence_BaseExpr(context, (NegationExpression) semanticObject); 
				return; 
			case MGLangPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MGLangPackage.NODE_CONTENT:
				sequence_NodeContent(context, (NodeContent) semanticObject); 
				return; 
			case MGLangPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case MGLangPackage.PARAM_MANIPULATION:
				sequence_ParamManipulation(context, (ParamManipulation) semanticObject); 
				return; 
			case MGLangPackage.PARAMETER_NODE:
				sequence_ParameterNode(context, (ParameterNode) semanticObject); 
				return; 
			case MGLangPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_CALL:
				sequence_PatternCall(context, (PatternCall) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_REFERENCE:
				sequence_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_RETURN:
				sequence_PatternReturn(context, (PatternReturn) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_VARIABLE:
				sequence_PatternVariable(context, (PatternVariable) semanticObject); 
				return; 
			case MGLangPackage.PRIMARY:
				sequence_PrimaryExpr(context, (Primary) semanticObject); 
				return; 
			case MGLangPackage.PRIMITIVE_PARAMETER:
				sequence_PrimitiveParameter(context, (PrimitiveParameter) semanticObject); 
				return; 
			case MGLangPackage.REF_OR_CALL:
				sequence_RefOrCall(context, (RefOrCall) semanticObject); 
				return; 
			case MGLangPackage.REF_PARAMS:
				sequence_RefParams(context, (RefParams) semanticObject); 
				return; 
			case MGLangPackage.REL:
				sequence_RelationExpression(context, (Rel) semanticObject); 
				return; 
			case MGLangPackage.SECONDARY:
				sequence_SecondaryExpression(context, (Secondary) semanticObject); 
				return; 
			case MGLangPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MGLangPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case MGLangPackage.TERTIARY:
				sequence_TertiaryExpression(context, (Tertiary) semanticObject); 
				return; 
			case MGLangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignmentOrControlFlow returns Assignment
	 *     Assignment returns Assignment
	 *     SwitchExpression returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=ArithmeticExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetEAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.ASSIGNMENT__TARGET, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getValueArithmeticExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns FunctionCall
	 *     TertiaryExpression returns FunctionCall
	 *     TertiaryExpression.Tertiary_1_0 returns FunctionCall
	 *     SecondaryExpression returns FunctionCall
	 *     SecondaryExpression.Secondary_1_0 returns FunctionCall
	 *     PrimaryExpr returns FunctionCall
	 *     PrimaryExpr.Primary_1_0 returns FunctionCall
	 *     RelationExpression returns FunctionCall
	 *     RelationExpression.Rel_1_0 returns FunctionCall
	 *     BaseExpr returns FunctionCall
	 *
	 * Constraint:
	 *     (func=MathFunc expr=ArithmeticExpression)
	 */
	protected void sequence_BaseExpr(ISerializationContext context, FunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__FUNC));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExprAccess().getFuncMathFuncEnumRuleCall_2_1_0(), semanticObject.getFunc());
		feeder.accept(grammarAccess.getBaseExprAccess().getExprArithmeticExpressionParserRuleCall_2_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns NegationExpression
	 *     TertiaryExpression returns NegationExpression
	 *     TertiaryExpression.Tertiary_1_0 returns NegationExpression
	 *     SecondaryExpression returns NegationExpression
	 *     SecondaryExpression.Secondary_1_0 returns NegationExpression
	 *     PrimaryExpr returns NegationExpression
	 *     PrimaryExpr.Primary_1_0 returns NegationExpression
	 *     RelationExpression returns NegationExpression
	 *     RelationExpression.Rel_1_0 returns NegationExpression
	 *     BaseExpr returns NegationExpression
	 *
	 * Constraint:
	 *     expr=BaseExpr
	 */
	protected void sequence_BaseExpr(ISerializationContext context, NegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NEGATION_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NEGATION_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExprAccess().getExprBaseExprParserRuleCall_1_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns BooleanLiteral
	 *     TertiaryExpression returns BooleanLiteral
	 *     TertiaryExpression.Tertiary_1_0 returns BooleanLiteral
	 *     SecondaryExpression returns BooleanLiteral
	 *     SecondaryExpression.Secondary_1_0 returns BooleanLiteral
	 *     PrimaryExpr returns BooleanLiteral
	 *     PrimaryExpr.Primary_1_0 returns BooleanLiteral
	 *     RelationExpression returns BooleanLiteral
	 *     RelationExpression.Rel_1_0 returns BooleanLiteral
	 *     BaseExpr returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (val=TRUE | val=FALSE)
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Default returns CaseBody
	 *     CaseBody returns CaseBody
	 *
	 * Constraint:
	 *     (expressions+=SwitchExpression+ | expressions+=SwitchExpression)?
	 */
	protected void sequence_CaseBody(ISerializationContext context, CaseBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns CaseWithCast
	 *     CaseWithCast returns CaseWithCast
	 *
	 * Constraint:
	 *     (node=Node when=ArithmeticExpression? body=CaseBody)
	 */
	protected void sequence_CaseWithCast(ISerializationContext context, CaseWithCast semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns CaseWithoutCast
	 *     CaseWithoutCast returns CaseWithoutCast
	 *
	 * Constraint:
	 *     (val=ArithmeticExpression body=CaseBody)
	 */
	protected void sequence_CaseWithoutCast(ISerializationContext context, CaseWithoutCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CASE_WITHOUT_CAST__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CASE_WITHOUT_CAST__VAL));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseWithoutCastAccess().getValArithmeticExpressionParserRuleCall_1_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getCaseWithoutCastAccess().getBodyCaseBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Config
	 *
	 * Constraint:
	 *     expressions+=ConfigExpression*
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForBody returns ForBody
	 *
	 * Constraint:
	 *     commands+=GeneratorExpression*
	 */
	protected void sequence_ForBody(ISerializationContext context, ForBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForHead returns ForEachHead
	 *     ForEachHead returns ForEachHead
	 *
	 * Constraint:
	 *     (src=RefOrCall eref=[EReference|ID] iteratorVar=ID)
	 */
	protected void sequence_ForEachHead(ISerializationContext context, ForEachHead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__SRC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__SRC));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__EREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__EREF));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachHeadAccess().getSrcRefOrCallParserRuleCall_0_0(), semanticObject.getSrc());
		feeder.accept(grammarAccess.getForEachHeadAccess().getErefEReferenceIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.FOR_EACH_HEAD__EREF, false));
		feeder.accept(grammarAccess.getForEachHeadAccess().getIteratorVarIDTerminalRuleCall_4_0(), semanticObject.getIteratorVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForRange returns ForRange
	 *
	 * Constraint:
	 *     (start=ArithmeticExpression end=ArithmeticExpression)
	 */
	protected void sequence_ForRange(ISerializationContext context, ForRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForRangeAccess().getStartArithmeticExpressionParserRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getForRangeAccess().getEndArithmeticExpressionParserRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns ForStatement
	 *     ForStatement returns ForStatement
	 *     SwitchExpression returns ForStatement
	 *
	 * Constraint:
	 *     (head=ForHead body=ForBody)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__HEAD));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getHeadForHeadParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getForStatementAccess().getBodyForBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForHead returns GeneralForHead
	 *     GeneralForHead returns GeneralForHead
	 *
	 * Constraint:
	 *     (iteratorVar=ID range=ForRange)
	 */
	protected void sequence_GeneralForHead(ISerializationContext context, GeneralForHead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralForHeadAccess().getIteratorVarIDTerminalRuleCall_0_0(), semanticObject.getIteratorVar());
		feeder.accept(grammarAccess.getGeneralForHeadAccess().getRangeForRangeParserRuleCall_2_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FileCommand returns Generator
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     (params+=Parameter* commands+=GeneratorExpression*)
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfElseCase returns IfElseCase
	 *
	 * Constraint:
	 *     (val=ArithmeticExpression body=CaseBody)
	 */
	protected void sequence_IfElseCase(ISerializationContext context, IfElseCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__VAL));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfElseCaseAccess().getValArithmeticExpressionParserRuleCall_1_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getIfElseCaseAccess().getBodyCaseBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns IfElseSwitch
	 *     NodeReferenceOrAssignmentOrControlFlow returns IfElseSwitch
	 *     GeneratorExpression returns IfElseSwitch
	 *     SwitchExpression returns IfElseSwitch
	 *     Switch returns IfElseSwitch
	 *     IfElseSwitch returns IfElseSwitch
	 *
	 * Constraint:
	 *     (cases+=IfElseCase+ default=Default?)
	 */
	protected void sequence_IfElseSwitch(ISerializationContext context, IfElseSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (uri=STRING name=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__URI));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getUriSTRINGTerminalRuleCall_1_0(), semanticObject.getUri());
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListAssignment returns ListAdHoc
	 *     ListAdHoc returns ListAdHoc
	 *
	 * Constraint:
	 *     (elements+=Literal elements+=Literal*)
	 */
	protected void sequence_ListAdHoc(ISerializationContext context, ListAdHoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns List
	 *     GeneratorExpression returns List
	 *     RefType returns List
	 *     SwitchExpression returns List
	 *     Collection returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     (name=ID createdBy=ListAssignment?)
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapAssignment returns MapAdHoc
	 *     MapAdHoc returns MapAdHoc
	 *
	 * Constraint:
	 *     (entries+=MapTupel entries+=MapTupel*)
	 */
	protected void sequence_MapAdHoc(ISerializationContext context, MapAdHoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapTupel returns MapTupel
	 *
	 * Constraint:
	 *     (key=Literal value=ArithmeticExpression)
	 */
	protected void sequence_MapTupel(ISerializationContext context, MapTupel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.MAP_TUPEL__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.MAP_TUPEL__KEY));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.MAP_TUPEL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.MAP_TUPEL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTupelAccess().getKeyLiteralParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapTupelAccess().getValueArithmeticExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns Map
	 *     GeneratorExpression returns Map
	 *     RefType returns Map
	 *     SwitchExpression returns Map
	 *     Collection returns Map
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (name=ID createdBy=MapAssignment?)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MofgenFile returns MofgenFile
	 *
	 * Constraint:
	 *     (imports+=Import* config=Config commands+=FileCommand*)
	 */
	protected void sequence_MofgenFile(ISerializationContext context, MofgenFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeContent returns NodeContent
	 *
	 * Constraint:
	 *     refsAssigns+=NodeReferenceOrAssignmentOrControlFlow*
	 */
	protected void sequence_NodeContent(ISerializationContext context, NodeContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns Node
	 *     Node returns Node
	 *     RefType returns Node
	 *
	 * Constraint:
	 *     (type=[EClass|ID] name=ID (createdBy=NodeContent | createdBy=PatternCall)?)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns NumberLiteral
	 *     TertiaryExpression returns NumberLiteral
	 *     TertiaryExpression.Tertiary_1_0 returns NumberLiteral
	 *     SecondaryExpression returns NumberLiteral
	 *     SecondaryExpression.Secondary_1_0 returns NumberLiteral
	 *     PrimaryExpr returns NumberLiteral
	 *     PrimaryExpr.Primary_1_0 returns NumberLiteral
	 *     RelationExpression returns NumberLiteral
	 *     RelationExpression.Rel_1_0 returns NumberLiteral
	 *     BaseExpr returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     val=DOUBLE
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NUMBER_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NUMBER_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValDOUBLETerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns ParamManipulation
	 *     ParamManipulation returns ParamManipulation
	 *
	 * Constraint:
	 *     (param=[ParameterNode|ID] content=NodeContent)
	 */
	protected void sequence_ParamManipulation(ISerializationContext context, ParamManipulation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__PARAM));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamManipulationAccess().getParamParameterNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PARAM_MANIPULATION__PARAM, false));
		feeder.accept(grammarAccess.getParamManipulationAccess().getContentNodeContentParserRuleCall_1_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns ParameterNode
	 *     ParameterNode returns ParameterNode
	 *     RefType returns ParameterNode
	 *
	 * Constraint:
	 *     (srcModel=[Import|ID]? type=[EClassifier|ID] name=ID)
	 */
	protected void sequence_ParameterNode(ISerializationContext context, ParameterNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternCall returns PatternCall
	 *     GeneratorExpression returns PatternCall
	 *     SwitchExpression returns PatternCall
	 *
	 * Constraint:
	 *     (called=[Pattern|ID] (params+=ArithmeticExpression params+=ArithmeticExpression*)?)
	 */
	protected void sequence_PatternCall(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignmentOrControlFlow returns PatternNodeReference
	 *     PatternNodeReference returns PatternNodeReference
	 *     SwitchExpression returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID])
	 */
	protected void sequence_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTypeEReferenceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTargetNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternReturn returns PatternReturn
	 *
	 * Constraint:
	 *     returnValue=[Node|ID]?
	 */
	protected void sequence_PatternReturn(ISerializationContext context, PatternReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns PatternVariable
	 *     PatternVariable returns PatternVariable
	 *     SwitchExpression returns PatternVariable
	 *
	 * Constraint:
	 *     (type=[Pattern|ID] name=ID patternCall=PatternCall)
	 */
	protected void sequence_PatternVariable(ISerializationContext context, PatternVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__PATTERN_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_VARIABLE__PATTERN_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternVariableAccess().getTypePatternIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_VARIABLE__TYPE, false));
		feeder.accept(grammarAccess.getPatternVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPatternVariableAccess().getPatternCallPatternCallParserRuleCall_3_0(), semanticObject.getPatternCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FileCommand returns Pattern
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? commands+=PatternCommand* return=PatternReturn?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Primary
	 *     TertiaryExpression returns Primary
	 *     TertiaryExpression.Tertiary_1_0 returns Primary
	 *     SecondaryExpression returns Primary
	 *     SecondaryExpression.Secondary_1_0 returns Primary
	 *     PrimaryExpr returns Primary
	 *     PrimaryExpr.Primary_1_0 returns Primary
	 *     RelationExpression returns Primary
	 *     RelationExpression.Rel_1_0 returns Primary
	 *     BaseExpr returns Primary
	 *
	 * Constraint:
	 *     (left=PrimaryExpr_Primary_1_0 op=PrimaryOp right=RelationExpression)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Primary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getOpPrimaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getRightRelationExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns PrimitiveParameter
	 *     PrimitiveParameter returns PrimitiveParameter
	 *     RefType returns PrimitiveParameter
	 *
	 * Constraint:
	 *     (type=PrimitiveType name=ID)
	 */
	protected void sequence_PrimitiveParameter(ISerializationContext context, PrimitiveParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getTypePrimitiveTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefOrCall returns RefOrCall
	 *     RefOrCall.RefOrCall_1_0 returns RefOrCall
	 *     ListAssignment returns RefOrCall
	 *     MapAssignment returns RefOrCall
	 *     ArithmeticExpression returns RefOrCall
	 *     TertiaryExpression returns RefOrCall
	 *     TertiaryExpression.Tertiary_1_0 returns RefOrCall
	 *     SecondaryExpression returns RefOrCall
	 *     SecondaryExpression.Secondary_1_0 returns RefOrCall
	 *     PrimaryExpr returns RefOrCall
	 *     PrimaryExpr.Primary_1_0 returns RefOrCall
	 *     RelationExpression returns RefOrCall
	 *     RelationExpression.Rel_1_0 returns RefOrCall
	 *     BaseExpr returns RefOrCall
	 *
	 * Constraint:
	 *     (ref=[RefType|ID] | (target=RefOrCall_RefOrCall_1_0 ref=[ETypedElement|ID] params=RefParams?))
	 */
	protected void sequence_RefOrCall(ISerializationContext context, RefOrCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RefParams returns RefParams
	 *
	 * Constraint:
	 *     (params+=ArithmeticExpression params+=ArithmeticExpression*)
	 */
	protected void sequence_RefParams(ISerializationContext context, RefParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Rel
	 *     TertiaryExpression returns Rel
	 *     TertiaryExpression.Tertiary_1_0 returns Rel
	 *     SecondaryExpression returns Rel
	 *     SecondaryExpression.Secondary_1_0 returns Rel
	 *     PrimaryExpr returns Rel
	 *     PrimaryExpr.Primary_1_0 returns Rel
	 *     RelationExpression returns Rel
	 *     RelationExpression.Rel_1_0 returns Rel
	 *     BaseExpr returns Rel
	 *
	 * Constraint:
	 *     (left=RelationExpression_Rel_1_0 relation=RelationalOp right=BaseExpr)
	 */
	protected void sequence_RelationExpression(ISerializationContext context, Rel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__RELATION));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelationRelationalOpEnumRuleCall_1_1_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRightBaseExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Secondary
	 *     TertiaryExpression returns Secondary
	 *     TertiaryExpression.Tertiary_1_0 returns Secondary
	 *     SecondaryExpression returns Secondary
	 *     SecondaryExpression.Secondary_1_0 returns Secondary
	 *     PrimaryExpr returns Secondary
	 *     PrimaryExpr.Primary_1_0 returns Secondary
	 *     RelationExpression returns Secondary
	 *     RelationExpression.Rel_1_0 returns Secondary
	 *     BaseExpr returns Secondary
	 *
	 * Constraint:
	 *     (left=SecondaryExpression_Secondary_1_0 op=SecondaryOp right=PrimaryExpr)
	 */
	protected void sequence_SecondaryExpression(ISerializationContext context, Secondary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getSecondaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getOpSecondaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getRightPrimaryExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns StringLiteral
	 *     TertiaryExpression returns StringLiteral
	 *     TertiaryExpression.Tertiary_1_0 returns StringLiteral
	 *     SecondaryExpression returns StringLiteral
	 *     SecondaryExpression.Secondary_1_0 returns StringLiteral
	 *     PrimaryExpr returns StringLiteral
	 *     PrimaryExpr.Primary_1_0 returns StringLiteral
	 *     RelationExpression returns StringLiteral
	 *     RelationExpression.Rel_1_0 returns StringLiteral
	 *     BaseExpr returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCommand returns SwitchCase
	 *     NodeReferenceOrAssignmentOrControlFlow returns SwitchCase
	 *     GeneratorExpression returns SwitchCase
	 *     SwitchExpression returns SwitchCase
	 *     Switch returns SwitchCase
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     (attribute=RefOrCall cases+=Case+ default=Default?)
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Tertiary
	 *     TertiaryExpression returns Tertiary
	 *     TertiaryExpression.Tertiary_1_0 returns Tertiary
	 *     SecondaryExpression returns Tertiary
	 *     SecondaryExpression.Secondary_1_0 returns Tertiary
	 *     PrimaryExpr returns Tertiary
	 *     PrimaryExpr.Primary_1_0 returns Tertiary
	 *     RelationExpression returns Tertiary
	 *     RelationExpression.Rel_1_0 returns Tertiary
	 *     BaseExpr returns Tertiary
	 *
	 * Constraint:
	 *     (left=TertiaryExpression_Tertiary_1_0 op=TertiaryOp right=SecondaryExpression)
	 */
	protected void sequence_TertiaryExpression(ISerializationContext context, Tertiary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getTertiaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getOpTertiaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getRightSecondaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns Variable
	 *     Variable returns Variable
	 *     RefType returns Variable
	 *
	 * Constraint:
	 *     (name=ID value=ArithmeticExpression)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getValueArithmeticExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
