/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.BooleanLiteral;
import org.mofgen.mGLang.Concat;
import org.mofgen.mGLang.Condition;
import org.mofgen.mGLang.ForEachCollection;
import org.mofgen.mGLang.ForLoop;
import org.mofgen.mGLang.ForRange;
import org.mofgen.mGLang.GenPatternCall;
import org.mofgen.mGLang.Generator;
import org.mofgen.mGLang.Import;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.NodeAttributeCall;
import org.mofgen.mGLang.NodeConstructor;
import org.mofgen.mGLang.NumberLiteral;
import org.mofgen.mGLang.ObjectParameter;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternCall;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.PatternObject;
import org.mofgen.mGLang.PatternObjectCreation;
import org.mofgen.mGLang.PatternReturn;
import org.mofgen.mGLang.PrimitiveParameter;
import org.mofgen.mGLang.STRING;
import org.mofgen.mGLang.StringLiteral;
import org.mofgen.services.MGLangGrammarAccess;

@SuppressWarnings("all")
public class MGLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGLangPackage.ASSIGNMENT:
				if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_Assignment_NodeReferenceOrAssignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.BOOLEAN_LITERAL:
				sequence_LiteralExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case MGLangPackage.CONCAT:
				sequence_StringConcatenation(context, (Concat) semanticObject); 
				return; 
			case MGLangPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case MGLangPackage.FOR_EACH_COLLECTION:
				sequence_ForEachCollection(context, (ForEachCollection) semanticObject); 
				return; 
			case MGLangPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case MGLangPackage.FOR_RANGE:
				sequence_ForRange(context, (ForRange) semanticObject); 
				return; 
			case MGLangPackage.GEN_PATTERN_CALL:
				sequence_GenPatternCall(context, (GenPatternCall) semanticObject); 
				return; 
			case MGLangPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case MGLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MGLangPackage.MOFGEN_FILE:
				sequence_MofgenFile(context, (MofgenFile) semanticObject); 
				return; 
			case MGLangPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MGLangPackage.NODE_ATTRIBUTE_CALL:
				sequence_NodeAttributeCall(context, (NodeAttributeCall) semanticObject); 
				return; 
			case MGLangPackage.NODE_CONSTRUCTOR:
				sequence_NodeConstructor(context, (NodeConstructor) semanticObject); 
				return; 
			case MGLangPackage.NUMBER_LITERAL:
				sequence_LiteralExpression(context, (NumberLiteral) semanticObject); 
				return; 
			case MGLangPackage.OBJECT_PARAMETER:
				sequence_ObjectParameter(context, (ObjectParameter) semanticObject); 
				return; 
			case MGLangPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_CALL:
				sequence_PatternCall(context, (PatternCall) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_REFERENCE:
				if (rule == grammarAccess.getNodeReferenceOrAssignmentRule()) {
					sequence_NodeReferenceOrAssignment_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPatternNodeReferenceRule()) {
					sequence_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.PATTERN_OBJECT:
				sequence_PatternObject(context, (PatternObject) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_OBJECT_CREATION:
				sequence_PatternObjectCreation(context, (PatternObjectCreation) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_RETURN:
				sequence_PatternReturn(context, (PatternReturn) semanticObject); 
				return; 
			case MGLangPackage.PRIMITIVE_PARAMETER:
				sequence_PrimitiveParameter(context, (PrimitiveParameter) semanticObject); 
				return; 
			case MGLangPackage.STRING:
				sequence_StringLiteral(context, (STRING) semanticObject); 
				return; 
			case MGLangPackage.STRING_LITERAL:
				sequence_LiteralExpression(context, (StringLiteral) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=LiteralExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetEAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.ASSIGNMENT__TARGET, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getValueLiteralExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=LiteralExpression condition=Condition?)
	 */
	protected void sequence_Assignment_NodeReferenceOrAssignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (lhs=[Parameter|ID] (relation=EditorRelation rhs=[Parameter|ID])?)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForEachCollection
	 *     ForEachCollection returns ForEachCollection
	 *
	 * Constraint:
	 *     coll=NodeAttributeCall
	 */
	protected void sequence_ForEachCollection(ISerializationContext context, ForEachCollection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_COLLECTION__COLL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachCollectionAccess().getCollNodeAttributeCallParserRuleCall_0(), semanticObject.getColl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (iteratorVar=ID iteratingCondition=ForCondition commands+=GeneratorCommand*)
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForCondition returns ForRange
	 *     ForRange returns ForRange
	 *
	 * Constraint:
	 *     (start=INT end=INT)
	 */
	protected void sequence_ForRange(ISerializationContext context, ForRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForRangeAccess().getStartINTTerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getForRangeAccess().getEndINTTerminalRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GenPatternCall returns GenPatternCall
	 *
	 * Constraint:
	 *     (calledPattern=[Pattern|ID] params+=PatternObject*)
	 */
	protected void sequence_GenPatternCall(ISerializationContext context, GenPatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     commands+=GeneratorElement*
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=STRING alias=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImportAccess().getAliasIDTerminalRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     value='-'?
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=StringConcatenation
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueStringConcatenationParserRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MofgenFile returns MofgenFile
	 *
	 * Constraint:
	 *     (imports+=Import+ | (imports+=Import+ (patterns+=Pattern | generators+=Generator)+))?
	 */
	protected void sequence_MofgenFile(ISerializationContext context, MofgenFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeAttributeCall returns NodeAttributeCall
	 *
	 * Constraint:
	 *     (node=[Node|ID] attribute=[EAttribute|ID])
	 */
	protected void sequence_NodeAttributeCall(ISerializationContext context, NodeAttributeCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getNodeNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__NODE, false));
		feeder.accept(grammarAccess.getNodeAttributeCallAccess().getAttributeEAttributeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.NODE_ATTRIBUTE_CALL__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeConstructor returns NodeConstructor
	 *
	 * Constraint:
	 *     refsAssigns+=NodeReferenceOrAssignment*
	 */
	protected void sequence_NodeConstructor(ISerializationContext context, NodeConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID] condition=Condition?)
	 */
	protected void sequence_NodeReferenceOrAssignment_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (type=[EClass|ID] name=ID (createdBy=NodeConstructor | createdBy=PatternCall)?)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns ObjectParameter
	 *     ObjectParameter returns ObjectParameter
	 *
	 * Constraint:
	 *     (type=[EClassifier|ID] name=ID)
	 */
	protected void sequence_ObjectParameter(ISerializationContext context, ObjectParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.OBJECT_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.OBJECT_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectParameterAccess().getTypeEClassifierIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.OBJECT_PARAMETER__TYPE, false));
		feeder.accept(grammarAccess.getObjectParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCall returns PatternCall
	 *     GeneratorElement returns PatternCall
	 *     GeneratorCommand returns PatternCall
	 *
	 * Constraint:
	 *     (called=[Pattern|ID] params+=LiteralExpression*)
	 */
	protected void sequence_PatternCall(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternNodeReference returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID])
	 */
	protected void sequence_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTypeEReferenceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTargetNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorElement returns PatternObjectCreation
	 *     GeneratorCommand returns PatternObjectCreation
	 *     PatternObjectCreation returns PatternObjectCreation
	 *
	 * Constraint:
	 *     (pObject=PatternObject patternCall=PatternCall)
	 */
	protected void sequence_PatternObjectCreation(ISerializationContext context, PatternObjectCreation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPObjectPatternObjectParserRuleCall_0_0(), semanticObject.getPObject());
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPatternCallPatternCallParserRuleCall_2_0(), semanticObject.getPatternCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternObject returns PatternObject
	 *
	 * Constraint:
	 *     (type=[Pattern|ID] name=ID)
	 */
	protected void sequence_PatternObject(ISerializationContext context, PatternObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectAccess().getTypePatternIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_OBJECT__TYPE, false));
		feeder.accept(grammarAccess.getPatternObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternReturn returns PatternReturn
	 *
	 * Constraint:
	 *     returnValue=[Node|ID]?
	 */
	protected void sequence_PatternReturn(ISerializationContext context, PatternReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? nodes+=Node* return=PatternReturn?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns PrimitiveParameter
	 *     PrimitiveParameter returns PrimitiveParameter
	 *
	 * Constraint:
	 *     (type=PrimitiveType name=ID)
	 */
	protected void sequence_PrimitiveParameter(ISerializationContext context, PrimitiveParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getTypePrimitiveTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringConcatenation returns Concat
	 *
	 * Constraint:
	 *     (left=StringConcatenation_Concat_1_0 right=StringConcatenation)
	 */
	protected void sequence_StringConcatenation(ISerializationContext context, Concat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CONCAT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CONCAT__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.CONCAT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.CONCAT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConcatenationAccess().getConcatLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getStringConcatenationAccess().getRightStringConcatenationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringConcatenation returns STRING
	 *     StringConcatenation.Concat_1_0 returns STRING
	 *     StringLiteral returns STRING
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, STRING semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
