/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mofgen.mGLang.Assignment;
import org.mofgen.mGLang.Case;
import org.mofgen.mGLang.CaseBody;
import org.mofgen.mGLang.ForBody;
import org.mofgen.mGLang.ForEachHead;
import org.mofgen.mGLang.ForRange;
import org.mofgen.mGLang.ForStatement;
import org.mofgen.mGLang.FunctionCall;
import org.mofgen.mGLang.GeneralForHead;
import org.mofgen.mGLang.Generator;
import org.mofgen.mGLang.IfElseCase;
import org.mofgen.mGLang.IfElseSwitch;
import org.mofgen.mGLang.Import;
import org.mofgen.mGLang.List;
import org.mofgen.mGLang.ListAdHoc;
import org.mofgen.mGLang.Literal;
import org.mofgen.mGLang.MGLangPackage;
import org.mofgen.mGLang.Map;
import org.mofgen.mGLang.MapAdHoc;
import org.mofgen.mGLang.MapTupel;
import org.mofgen.mGLang.MofgenFile;
import org.mofgen.mGLang.NegationExpression;
import org.mofgen.mGLang.Node;
import org.mofgen.mGLang.NodeContent;
import org.mofgen.mGLang.ParamManipulation;
import org.mofgen.mGLang.ParameterNode;
import org.mofgen.mGLang.Pattern;
import org.mofgen.mGLang.PatternCall;
import org.mofgen.mGLang.PatternNodeReference;
import org.mofgen.mGLang.PatternObject;
import org.mofgen.mGLang.PatternObjectCreation;
import org.mofgen.mGLang.PatternReturn;
import org.mofgen.mGLang.Primary;
import org.mofgen.mGLang.PrimitiveParameter;
import org.mofgen.mGLang.RefOrCall;
import org.mofgen.mGLang.RefOrCall2;
import org.mofgen.mGLang.Rel;
import org.mofgen.mGLang.Secondary;
import org.mofgen.mGLang.SwitchCase;
import org.mofgen.mGLang.Tertiary;
import org.mofgen.services.MGLangGrammarAccess;

@SuppressWarnings("all")
public class MGLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MGLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MGLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MGLangPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MGLangPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case MGLangPackage.CASE_BODY:
				sequence_CaseBody(context, (CaseBody) semanticObject); 
				return; 
			case MGLangPackage.FOR_BODY:
				sequence_ForBody(context, (ForBody) semanticObject); 
				return; 
			case MGLangPackage.FOR_EACH_HEAD:
				sequence_ForEachHead(context, (ForEachHead) semanticObject); 
				return; 
			case MGLangPackage.FOR_RANGE:
				sequence_ForRange(context, (ForRange) semanticObject); 
				return; 
			case MGLangPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MGLangPackage.FUNCTION_CALL:
				sequence_BaseExpr(context, (FunctionCall) semanticObject); 
				return; 
			case MGLangPackage.GENERAL_FOR_HEAD:
				sequence_GeneralForHead(context, (GeneralForHead) semanticObject); 
				return; 
			case MGLangPackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case MGLangPackage.IF_ELSE_CASE:
				sequence_IfElseCase(context, (IfElseCase) semanticObject); 
				return; 
			case MGLangPackage.IF_ELSE_SWITCH:
				sequence_IfElseSwitch(context, (IfElseSwitch) semanticObject); 
				return; 
			case MGLangPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MGLangPackage.LIST:
				if (rule == grammarAccess.getGeneratorExpressionRule()
						|| rule == grammarAccess.getRefTypeRule()
						|| rule == grammarAccess.getCollectionRule()) {
					sequence_List_ListAdHoc_RefOrCall(context, (List) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getListRule()) {
					sequence_List_ListAdHoc_RefOrCall(context, (List) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.LIST_AD_HOC:
				sequence_ListAdHoc(context, (ListAdHoc) semanticObject); 
				return; 
			case MGLangPackage.LITERAL:
				sequence_BaseExpr(context, (Literal) semanticObject); 
				return; 
			case MGLangPackage.MAP:
				if (rule == grammarAccess.getGeneratorExpressionRule()
						|| rule == grammarAccess.getRefTypeRule()
						|| rule == grammarAccess.getCollectionRule()) {
					sequence_Map_MapAdHoc_RefOrCall(context, (Map) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapRule()) {
					sequence_Map_MapAdHoc_RefOrCall(context, (Map) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.MAP_AD_HOC:
				sequence_MapAdHoc(context, (MapAdHoc) semanticObject); 
				return; 
			case MGLangPackage.MAP_TUPEL:
				sequence_MapTupel(context, (MapTupel) semanticObject); 
				return; 
			case MGLangPackage.MOFGEN_FILE:
				sequence_MofgenFile(context, (MofgenFile) semanticObject); 
				return; 
			case MGLangPackage.NEGATION_EXPRESSION:
				sequence_BaseExpr(context, (NegationExpression) semanticObject); 
				return; 
			case MGLangPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case MGLangPackage.NODE_CONTENT:
				sequence_NodeContent(context, (NodeContent) semanticObject); 
				return; 
			case MGLangPackage.PARAM_MANIPULATION:
				sequence_ParamManipulation(context, (ParamManipulation) semanticObject); 
				return; 
			case MGLangPackage.PARAMETER_NODE:
				sequence_ParameterNode(context, (ParameterNode) semanticObject); 
				return; 
			case MGLangPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_CALL:
				sequence_PatternCall(context, (PatternCall) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_NODE_REFERENCE:
				sequence_PatternNodeReference(context, (PatternNodeReference) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_OBJECT:
				sequence_PatternObject(context, (PatternObject) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_OBJECT_CREATION:
				sequence_PatternObjectCreation(context, (PatternObjectCreation) semanticObject); 
				return; 
			case MGLangPackage.PATTERN_RETURN:
				sequence_PatternReturn(context, (PatternReturn) semanticObject); 
				return; 
			case MGLangPackage.PRIMARY:
				sequence_PrimaryExpr(context, (Primary) semanticObject); 
				return; 
			case MGLangPackage.PRIMITIVE_PARAMETER:
				sequence_PrimitiveParameter(context, (PrimitiveParameter) semanticObject); 
				return; 
			case MGLangPackage.REF_OR_CALL:
				if (rule == grammarAccess.getRefOrCall2Rule()
						|| action == grammarAccess.getRefOrCall2Access().getRefOrCallTargetAction_1_0()) {
					sequence_RefOrCall2(context, (RefOrCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRefOrCallRule()
						|| action == grammarAccess.getRefOrCallAccess().getRefOrCallTargetAction_1_0()
						|| rule == grammarAccess.getListAssignmentRule()
						|| rule == grammarAccess.getMapAssignmentRule()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| rule == grammarAccess.getTertiaryExpressionRule()
						|| action == grammarAccess.getTertiaryExpressionAccess().getTertiaryLeftAction_1_0()
						|| rule == grammarAccess.getSecondaryExpressionRule()
						|| action == grammarAccess.getSecondaryExpressionAccess().getSecondaryLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryExprRule()
						|| action == grammarAccess.getPrimaryExprAccess().getPrimaryLeftAction_1_0()
						|| rule == grammarAccess.getRelationExpressionRule()
						|| action == grammarAccess.getRelationExpressionAccess().getRelLeftAction_1_0()
						|| rule == grammarAccess.getBaseExprRule()) {
					sequence_RefOrCall(context, (RefOrCall) semanticObject); 
					return; 
				}
				else break;
			case MGLangPackage.REF_OR_CALL2:
				sequence_RefOrCall2(context, (RefOrCall2) semanticObject); 
				return; 
			case MGLangPackage.REL:
				sequence_RelationExpression(context, (Rel) semanticObject); 
				return; 
			case MGLangPackage.SECONDARY:
				sequence_SecondaryExpression(context, (Secondary) semanticObject); 
				return; 
			case MGLangPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case MGLangPackage.TERTIARY:
				sequence_TertiaryExpression(context, (Tertiary) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (target=[EAttribute|ID] value=ArithmeticExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTargetEAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.ASSIGNMENT__TARGET, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getValueArithmeticExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns FunctionCall
	 *     TertiaryExpression returns FunctionCall
	 *     TertiaryExpression.Tertiary_1_0 returns FunctionCall
	 *     SecondaryExpression returns FunctionCall
	 *     SecondaryExpression.Secondary_1_0 returns FunctionCall
	 *     PrimaryExpr returns FunctionCall
	 *     PrimaryExpr.Primary_1_0 returns FunctionCall
	 *     RelationExpression returns FunctionCall
	 *     RelationExpression.Rel_1_0 returns FunctionCall
	 *     BaseExpr returns FunctionCall
	 *
	 * Constraint:
	 *     (func=MathFunc expr=ArithmeticExpression)
	 */
	protected void sequence_BaseExpr(ISerializationContext context, FunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__FUNC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__FUNC));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FUNCTION_CALL__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExprAccess().getFuncMathFuncEnumRuleCall_2_1_0(), semanticObject.getFunc());
		feeder.accept(grammarAccess.getBaseExprAccess().getExprArithmeticExpressionParserRuleCall_2_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Literal
	 *     TertiaryExpression returns Literal
	 *     TertiaryExpression.Tertiary_1_0 returns Literal
	 *     SecondaryExpression returns Literal
	 *     SecondaryExpression.Secondary_1_0 returns Literal
	 *     PrimaryExpr returns Literal
	 *     PrimaryExpr.Primary_1_0 returns Literal
	 *     RelationExpression returns Literal
	 *     RelationExpression.Rel_1_0 returns Literal
	 *     BaseExpr returns Literal
	 *
	 * Constraint:
	 *     {Literal}
	 */
	protected void sequence_BaseExpr(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns NegationExpression
	 *     TertiaryExpression returns NegationExpression
	 *     TertiaryExpression.Tertiary_1_0 returns NegationExpression
	 *     SecondaryExpression returns NegationExpression
	 *     SecondaryExpression.Secondary_1_0 returns NegationExpression
	 *     PrimaryExpr returns NegationExpression
	 *     PrimaryExpr.Primary_1_0 returns NegationExpression
	 *     RelationExpression returns NegationExpression
	 *     RelationExpression.Rel_1_0 returns NegationExpression
	 *     BaseExpr returns NegationExpression
	 *
	 * Constraint:
	 *     expr=BaseExpr
	 */
	protected void sequence_BaseExpr(ISerializationContext context, NegationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.NEGATION_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.NEGATION_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseExprAccess().getExprBaseExprParserRuleCall_1_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Default returns CaseBody
	 *     CaseBody returns CaseBody
	 *
	 * Constraint:
	 *     (expressions+=GeneratorExpression+ | expressions+=GeneratorExpression)?
	 */
	protected void sequence_CaseBody(ISerializationContext context, CaseBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (node=Node when=ArithmeticExpression? body=CaseBody)
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForBody returns ForBody
	 *
	 * Constraint:
	 *     commands+=GeneratorExpression*
	 */
	protected void sequence_ForBody(ISerializationContext context, ForBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForHead returns ForEachHead
	 *     ForEachHead returns ForEachHead
	 *
	 * Constraint:
	 *     (src=RefOrCall eref=[EReference|ID] iteratorVar=ID)
	 */
	protected void sequence_ForEachHead(ISerializationContext context, ForEachHead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__SRC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__SRC));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__EREF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_EACH_HEAD__EREF));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachHeadAccess().getSrcRefOrCallParserRuleCall_0_0(), semanticObject.getSrc());
		feeder.accept(grammarAccess.getForEachHeadAccess().getErefEReferenceIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.FOR_EACH_HEAD__EREF, false));
		feeder.accept(grammarAccess.getForEachHeadAccess().getIteratorVarIDTerminalRuleCall_4_0(), semanticObject.getIteratorVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForRange returns ForRange
	 *
	 * Constraint:
	 *     (start=INT end=INT)
	 */
	protected void sequence_ForRange(ISerializationContext context, ForRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__START));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_RANGE__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_RANGE__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForRangeAccess().getStartINTTerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getForRangeAccess().getEndINTTerminalRuleCall_2_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (head=ForHead body=ForBody)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__HEAD));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getHeadForHeadParserRuleCall_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getForStatementAccess().getBodyForBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForHead returns GeneralForHead
	 *     GeneralForHead returns GeneralForHead
	 *
	 * Constraint:
	 *     (iteratorVar=ID range=ForRange)
	 */
	protected void sequence_GeneralForHead(ISerializationContext context, GeneralForHead semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.FOR_HEAD__ITERATOR_VAR));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.GENERAL_FOR_HEAD__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGeneralForHeadAccess().getIteratorVarIDTerminalRuleCall_0_0(), semanticObject.getIteratorVar());
		feeder.accept(grammarAccess.getGeneralForHeadAccess().getRangeForRangeParserRuleCall_2_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     (params+=Parameter* commands+=GeneratorExpression*)
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfElseCase returns IfElseCase
	 *
	 * Constraint:
	 *     (val=ArithmeticExpression body=CaseBody)
	 */
	protected void sequence_IfElseCase(ISerializationContext context, IfElseCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__VAL));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IF_ELSE_CASE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfElseCaseAccess().getValArithmeticExpressionParserRuleCall_1_0(), semanticObject.getVal());
		feeder.accept(grammarAccess.getIfElseCaseAccess().getBodyCaseBodyParserRuleCall_3_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns IfElseSwitch
	 *     Switch returns IfElseSwitch
	 *     IfElseSwitch returns IfElseSwitch
	 *
	 * Constraint:
	 *     (cases+=IfElseCase+ default=Default?)
	 */
	protected void sequence_IfElseSwitch(ISerializationContext context, IfElseSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (name=STRING alias=ID)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__NAME));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.IMPORT__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getImportAccess().getAliasIDTerminalRuleCall_3_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListAssignment returns ListAdHoc
	 *     ListAdHoc returns ListAdHoc
	 *
	 * Constraint:
	 *     (elements+=Literal elements+=Literal*)
	 */
	protected void sequence_ListAdHoc(ISerializationContext context, ListAdHoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns List
	 *     RefType returns List
	 *     Collection returns List
	 *
	 * Constraint:
	 *     (name=ID (ref=[RefType|ID] | (elements+=Literal elements+=Literal*)))
	 */
	protected void sequence_List_ListAdHoc_RefOrCall(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     List returns List
	//
	// Constraint:
	//     (
	//         name=ID 
	//         (ref=[RefType|ID] | (target=RefOrCall_RefOrCall_1_0 ref=[ETypedElement|ID] (params+=Node params+=Node*)?) | (elements+=Literal elements+=Literal*))
	//     )
	//
	// protected void sequence_List_ListAdHoc_RefOrCall(ISerializationContext context, List semanticObject) { }
	
	/**
	 * Contexts:
	 *     MapAssignment returns MapAdHoc
	 *     MapAdHoc returns MapAdHoc
	 *
	 * Constraint:
	 *     (entries+=MapTupel entries+=MapTupel*)
	 */
	protected void sequence_MapAdHoc(ISerializationContext context, MapAdHoc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapTupel returns MapTupel
	 *
	 * Constraint:
	 *     (key=Literal value=ArithmeticExpression)
	 */
	protected void sequence_MapTupel(ISerializationContext context, MapTupel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.MAP_TUPEL__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.MAP_TUPEL__KEY));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.MAP_TUPEL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.MAP_TUPEL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTupelAccess().getKeyLiteralParserRuleCall_1_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMapTupelAccess().getValueArithmeticExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns Map
	 *     RefType returns Map
	 *     Collection returns Map
	 *
	 * Constraint:
	 *     (name=ID (ref=[RefType|ID] | (entries+=MapTupel entries+=MapTupel*)))
	 */
	protected void sequence_Map_MapAdHoc_RefOrCall(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     Map returns Map
	//
	// Constraint:
	//     (
	//         name=ID 
	//         (ref=[RefType|ID] | (target=RefOrCall_RefOrCall_1_0 ref=[ETypedElement|ID] (params+=Node params+=Node*)?) | (entries+=MapTupel entries+=MapTupel*))
	//     )
	//
	// protected void sequence_Map_MapAdHoc_RefOrCall(ISerializationContext context, Map semanticObject) { }
	
	/**
	 * Contexts:
	 *     MofgenFile returns MofgenFile
	 *
	 * Constraint:
	 *     (imports+=Import* config=Config (patterns+=Pattern | generators+=Generator)*)
	 */
	protected void sequence_MofgenFile(ISerializationContext context, MofgenFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeContent returns NodeContent
	 *
	 * Constraint:
	 *     refsAssigns+=NodeReferenceOrAssignment*
	 */
	protected void sequence_NodeContent(ISerializationContext context, NodeContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *     RefType returns Node
	 *
	 * Constraint:
	 *     (type=[EClass|ID] name=ID (createdBy=NodeContent | createdBy=PatternCall)?)
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamManipulation returns ParamManipulation
	 *
	 * Constraint:
	 *     (param=[ParameterNode|ID] content=NodeContent)
	 */
	protected void sequence_ParamManipulation(ISerializationContext context, ParamManipulation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__PARAM));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAM_MANIPULATION__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamManipulationAccess().getParamParameterNodeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PARAM_MANIPULATION__PARAM, false));
		feeder.accept(grammarAccess.getParamManipulationAccess().getContentNodeContentParserRuleCall_1_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns ParameterNode
	 *     ParameterNode returns ParameterNode
	 *     RefType returns ParameterNode
	 *
	 * Constraint:
	 *     (type=[EClassifier|ID] name=ID)
	 */
	protected void sequence_ParameterNode(ISerializationContext context, ParameterNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PARAMETER_NODE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PARAMETER_NODE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterNodeAccess().getTypeEClassifierIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PARAMETER_NODE__TYPE, false));
		feeder.accept(grammarAccess.getParameterNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternCall returns PatternCall
	 *     GeneratorExpression returns PatternCall
	 *
	 * Constraint:
	 *     (called=[Pattern|ID] params+=ArithmeticExpression*)
	 */
	protected void sequence_PatternCall(ISerializationContext context, PatternCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeReferenceOrAssignment returns PatternNodeReference
	 *     PatternNodeReference returns PatternNodeReference
	 *
	 * Constraint:
	 *     (type=[EReference|ID] target=[Node|ID])
	 */
	protected void sequence_PatternNodeReference(ISerializationContext context, PatternNodeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTypeEReferenceIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TYPE, false));
		feeder.accept(grammarAccess.getPatternNodeReferenceAccess().getTargetNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_NODE_REFERENCE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns PatternObjectCreation
	 *     PatternObjectCreation returns PatternObjectCreation
	 *
	 * Constraint:
	 *     (pObject=PatternObject patternCall=PatternCall)
	 */
	protected void sequence_PatternObjectCreation(ISerializationContext context, PatternObjectCreation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__POBJECT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT_CREATION__PATTERN_CALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPObjectPatternObjectParserRuleCall_0_0(), semanticObject.getPObject());
		feeder.accept(grammarAccess.getPatternObjectCreationAccess().getPatternCallPatternCallParserRuleCall_2_0(), semanticObject.getPatternCall());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternObject returns PatternObject
	 *
	 * Constraint:
	 *     (type=[Pattern|ID] name=ID)
	 */
	protected void sequence_PatternObject(ISerializationContext context, PatternObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PATTERN_OBJECT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternObjectAccess().getTypePatternIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.PATTERN_OBJECT__TYPE, false));
		feeder.accept(grammarAccess.getPatternObjectAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternReturn returns PatternReturn
	 *
	 * Constraint:
	 *     returnValue=[Node|ID]?
	 */
	protected void sequence_PatternReturn(ISerializationContext context, PatternReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         (colls+=Collection | nodes+=Node | paramManipulations+=ParamManipulation | switches+=Switch)* 
	 *         return=PatternReturn?
	 *     )
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Primary
	 *     TertiaryExpression returns Primary
	 *     TertiaryExpression.Tertiary_1_0 returns Primary
	 *     SecondaryExpression returns Primary
	 *     SecondaryExpression.Secondary_1_0 returns Primary
	 *     PrimaryExpr returns Primary
	 *     PrimaryExpr.Primary_1_0 returns Primary
	 *     RelationExpression returns Primary
	 *     RelationExpression.Rel_1_0 returns Primary
	 *     BaseExpr returns Primary
	 *
	 * Constraint:
	 *     (left=PrimaryExpr_Primary_1_0 op=PrimaryOp right=RelationExpression)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, Primary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getOpPrimaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getRightRelationExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns PrimitiveParameter
	 *     PrimitiveParameter returns PrimitiveParameter
	 *     RefType returns PrimitiveParameter
	 *
	 * Constraint:
	 *     (type=PrimitiveType name=ID)
	 */
	protected void sequence_PrimitiveParameter(ISerializationContext context, PrimitiveParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.PRIMITIVE_PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getTypePrimitiveTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPrimitiveParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefOrCall2 returns RefOrCall
	 *     RefOrCall2.RefOrCall_1_0 returns RefOrCall
	 *
	 * Constraint:
	 *     (target=RefOrCall2_RefOrCall_1_0 ref=[ETypedElement|ID])
	 */
	protected void sequence_RefOrCall2(ISerializationContext context, RefOrCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_OR_CALL__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_OR_CALL__TARGET));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_OR_CALL2__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_OR_CALL2__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefOrCall2Access().getRefOrCallTargetAction_1_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getRefOrCall2Access().getRefETypedElementIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(MGLangPackage.Literals.REF_OR_CALL2__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefOrCall2 returns RefOrCall2
	 *     RefOrCall2.RefOrCall_1_0 returns RefOrCall2
	 *
	 * Constraint:
	 *     ref=[RefType|ID]
	 */
	protected void sequence_RefOrCall2(ISerializationContext context, RefOrCall2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REF_OR_CALL2__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REF_OR_CALL2__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefOrCall2Access().getRefRefTypeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(MGLangPackage.Literals.REF_OR_CALL2__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RefOrCall returns RefOrCall
	 *     RefOrCall.RefOrCall_1_0 returns RefOrCall
	 *     ListAssignment returns RefOrCall
	 *     MapAssignment returns RefOrCall
	 *     ArithmeticExpression returns RefOrCall
	 *     TertiaryExpression returns RefOrCall
	 *     TertiaryExpression.Tertiary_1_0 returns RefOrCall
	 *     SecondaryExpression returns RefOrCall
	 *     SecondaryExpression.Secondary_1_0 returns RefOrCall
	 *     PrimaryExpr returns RefOrCall
	 *     PrimaryExpr.Primary_1_0 returns RefOrCall
	 *     RelationExpression returns RefOrCall
	 *     RelationExpression.Rel_1_0 returns RefOrCall
	 *     BaseExpr returns RefOrCall
	 *
	 * Constraint:
	 *     (ref=[RefType|ID] | (target=RefOrCall_RefOrCall_1_0 ref=[ETypedElement|ID] (params+=Node params+=Node*)?))
	 */
	protected void sequence_RefOrCall(ISerializationContext context, RefOrCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Rel
	 *     TertiaryExpression returns Rel
	 *     TertiaryExpression.Tertiary_1_0 returns Rel
	 *     SecondaryExpression returns Rel
	 *     SecondaryExpression.Secondary_1_0 returns Rel
	 *     PrimaryExpr returns Rel
	 *     PrimaryExpr.Primary_1_0 returns Rel
	 *     RelationExpression returns Rel
	 *     RelationExpression.Rel_1_0 returns Rel
	 *     BaseExpr returns Rel
	 *
	 * Constraint:
	 *     (left=RelationExpression_Rel_1_0 relation=RelationalOp right=BaseExpr)
	 */
	protected void sequence_RelationExpression(ISerializationContext context, Rel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__RELATION));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.REL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.REL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRelationRelationalOpEnumRuleCall_1_1_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getRelationExpressionAccess().getRightBaseExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Secondary
	 *     TertiaryExpression returns Secondary
	 *     TertiaryExpression.Tertiary_1_0 returns Secondary
	 *     SecondaryExpression returns Secondary
	 *     SecondaryExpression.Secondary_1_0 returns Secondary
	 *     PrimaryExpr returns Secondary
	 *     PrimaryExpr.Primary_1_0 returns Secondary
	 *     RelationExpression returns Secondary
	 *     RelationExpression.Rel_1_0 returns Secondary
	 *     BaseExpr returns Secondary
	 *
	 * Constraint:
	 *     (left=SecondaryExpression_Secondary_1_0 op=SecondaryOp right=PrimaryExpr)
	 */
	protected void sequence_SecondaryExpression(ISerializationContext context, Secondary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.SECONDARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.SECONDARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getSecondaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getOpSecondaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSecondaryExpressionAccess().getRightPrimaryExprParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GeneratorExpression returns SwitchCase
	 *     Switch returns SwitchCase
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     (attribute=RefOrCall cases+=Case+ default=Default?)
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns Tertiary
	 *     TertiaryExpression returns Tertiary
	 *     TertiaryExpression.Tertiary_1_0 returns Tertiary
	 *     SecondaryExpression returns Tertiary
	 *     SecondaryExpression.Secondary_1_0 returns Tertiary
	 *     PrimaryExpr returns Tertiary
	 *     PrimaryExpr.Primary_1_0 returns Tertiary
	 *     RelationExpression returns Tertiary
	 *     RelationExpression.Rel_1_0 returns Tertiary
	 *     BaseExpr returns Tertiary
	 *
	 * Constraint:
	 *     (left=TertiaryExpression_Tertiary_1_0 op=TertiaryOp right=SecondaryExpression)
	 */
	protected void sequence_TertiaryExpression(ISerializationContext context, Tertiary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__OP));
			if (transientValues.isValueTransient(semanticObject, MGLangPackage.Literals.TERTIARY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MGLangPackage.Literals.TERTIARY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getTertiaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getOpTertiaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTertiaryExpressionAccess().getRightSecondaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
