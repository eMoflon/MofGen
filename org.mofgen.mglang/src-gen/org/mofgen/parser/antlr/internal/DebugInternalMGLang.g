/*
 * generated by Xtext 2.20.0
 */
grammar DebugInternalMGLang;

// Rule MofgenFile
ruleMofgenFile:
	ruleImport
	*
	ruleConfig
	(
		rulePattern
		    |
		ruleGenerator
	)*
;

// Rule Import
ruleImport:
	'import'
	RULE_STRING
	'as'
	RULE_ID
;

// Rule Config
ruleConfig:
	'config'
	'('
	')'
	'{'
	ruleConfigExpression
	*
	'}'
;

// Rule ConfigExpression
ruleConfigExpression:
	'test'
;

// Rule Pattern
rulePattern:
	'pattern'
	RULE_ID
	'('
	(
		ruleParameter
		(
			','
			ruleParameter
		)*
	)?
	')'
	'{'
	(ruleCollection
	*
	    |
	ruleNode
	*
	    |
	ruleParamManipulation
	*
	    |
	ruleSwitch
	*
	)*
	'}'
	rulePatternReturn
	?
;

// Rule PatternReturn
rulePatternReturn:
	'return'
	'this'
	(
		'.'
		RULE_ID
	)?
;

// Rule ParamManipulation
ruleParamManipulation:
	RULE_ID
	ruleNodeContent
;

// Rule Node
ruleNode:
	RULE_ID
	RULE_ID
	(
		ruleNodeContent
		    |
		RULE_ASSIGNMENT_OP
		rulePatternCall
	)?
;

// Rule NodeContent
ruleNodeContent:
	'{'
	ruleNodeReferenceOrAssignmentOrControlFlow
	*
	'}'
;

// Rule PatternCall
rulePatternCall:
	RULE_ID
	'('
	(
		ruleArithmeticExpression
		(
			','
			ruleArithmeticExpression
		)*
	)?
	')'
;

// Rule NodeReferenceOrAssignmentOrControlFlow
ruleNodeReferenceOrAssignmentOrControlFlow:
	(
		rulePatternNodeReference
		    |
		ruleAssignment
		    |
		ruleSwitch
	)
;

// Rule PatternNodeReference
rulePatternNodeReference:
	RULE_ID
	'->'
	RULE_ID
;

// Rule Assignment
ruleAssignment:
	RULE_ID
	RULE_ASSIGNMENT_OP
	ruleArithmeticExpression
;

// Rule Parameter
ruleParameter:
	(
		rulePrimitiveParameter
		    |
		ruleParameterNode
	)
;

// Rule PrimitiveParameter
rulePrimitiveParameter:
	rulePrimitiveType
	RULE_ID
;

// Rule ParameterNode
ruleParameterNode:
	RULE_ID
	RULE_ID
;

// Rule RefOrCall
ruleRefOrCall:
	RULE_ID
	(
		'.'
		RULE_ID
		(
			'('
			ruleRefParams
			?
			')'
		)?
	)*
;

// Rule RefParams
ruleRefParams:
	ruleArithmeticExpression
	(
		','
		ruleArithmeticExpression
	)*
;

// Rule Generator
ruleGenerator:
	'gen'
	'('
	ruleParameter
	*
	')'
	'{'
	ruleGeneratorExpression
	*
	'}'
;

// Rule GeneratorExpression
ruleGeneratorExpression:
	(
		ruleForStatement
		    |
		ruleSwitch
		    |
		ruleCollection
		    |
		rulePatternCall
		    |
		rulePatternVariable
	)
;

// Rule PatternVariable
rulePatternVariable:
	RULE_ID
	RULE_ID
	RULE_ASSIGNMENT_OP
	rulePatternCall
;

// Rule ForStatement
ruleForStatement:
	'for'
	ruleForHead
	'{'
	ruleForBody
	'}'
;

// Rule ForHead
ruleForHead:
	(
		ruleGeneralForHead
		    |
		ruleForEachHead
	)
;

// Rule GeneralForHead
ruleGeneralForHead:
	RULE_ID
	'in'
	ruleForRange
;

// Rule ForEachHead
ruleForEachHead:
	ruleRefOrCall
	'-'
	RULE_ID
	'->'
	RULE_ID
;

// Rule ForBody
ruleForBody:
	ruleGeneratorExpression
	*
;

// Rule SwitchExpression
ruleSwitchExpression:
	(
		ruleForStatement
		    |
		ruleCollection
		    |
		rulePatternCall
		    |
		rulePatternVariable
		    |
		ruleNodeReferenceOrAssignmentOrControlFlow
	)
;

// Rule Switch
ruleSwitch:
	(
		ruleIfElseSwitch
		    |
		ruleSwitchCase
	)
;

// Rule IfElseSwitch
ruleIfElseSwitch:
	'switch'
	'{'
	ruleIfElseCase
	+
	ruleDefault
	?
	'}'
;

// Rule IfElseCase
ruleIfElseCase:
	'case'
	ruleArithmeticExpression
	':'
	ruleCaseBody
;

// Rule Default
ruleDefault:
	'default'
	':'
	ruleCaseBody
;

// Rule SwitchCase
ruleSwitchCase:
	'switch'
	'('
	ruleRefOrCall
	')'
	'{'
	ruleCase
	+
	ruleDefault
	?
	'}'
;

// Rule Case
ruleCase:
	(
		ruleCaseWithCast
		    |
		ruleCaseWithoutCast
	)
;

// Rule CaseWithCast
ruleCaseWithCast:
	'case'
	ruleNode
	(
		'when'
		ruleArithmeticExpression
	)?
	':'
	ruleCaseBody
;

// Rule CaseWithoutCast
ruleCaseWithoutCast:
	'case'
	ruleArithmeticExpression
	':'
	ruleCaseBody
;

// Rule CaseBody
ruleCaseBody:
	(
		'{'
		ruleSwitchExpression
		*
		'}'
		    |
		ruleSwitchExpression
		RULE_NEWLINE
	)
;

// Rule Collection
ruleCollection:
	(
		ruleList
		    |
		ruleMap
	)
;

// Rule List
ruleList:
	'List'
	RULE_ID
	(
		RULE_ASSIGNMENT_OP
		ruleListAssignment
	)?
;

// Rule ListAssignment
ruleListAssignment:
	(
		ruleListAdHoc
		    |
		ruleRefOrCall
	)
;

// Rule ListAdHoc
ruleListAdHoc:
	'['
	ruleLiteral
	(
		','
		ruleLiteral
	)*
	']'
;

// Rule Map
ruleMap:
	'Map'
	RULE_ID
	(
		RULE_ASSIGNMENT_OP
		ruleMapAssignment
	)?
;

// Rule MapAssignment
ruleMapAssignment:
	(
		ruleMapAdHoc
		    |
		ruleRefOrCall
	)
;

// Rule MapAdHoc
ruleMapAdHoc:
	'['
	ruleMapTupel
	(
		','
		ruleMapTupel
	)*
	']'
;

// Rule MapTupel
ruleMapTupel:
	'('
	ruleLiteral
	','
	ruleArithmeticExpression
	')'
;

// Rule ForRange
ruleForRange:
	ruleArithmeticExpression
	':'
	ruleArithmeticExpression
;

// Rule ArithmeticExpression
ruleArithmeticExpression:
	ruleTertiaryExpression
;

// Rule TertiaryExpression
ruleTertiaryExpression:
	ruleSecondaryExpression
	(
		ruleTertiaryOp
		ruleSecondaryExpression
	)*
;

// Rule SecondaryExpression
ruleSecondaryExpression:
	rulePrimaryExpr
	(
		ruleSecondaryOp
		rulePrimaryExpr
	)*
;

// Rule PrimaryExpr
rulePrimaryExpr:
	ruleRelationExpression
	(
		rulePrimaryOp
		ruleRelationExpression
	)*
;

// Rule RelationExpression
ruleRelationExpression:
	ruleBaseExpr
	(
		ruleRelationalOp
		ruleBaseExpr
	)*
;

// Rule BaseExpr
ruleBaseExpr:
	(
		'('
		ruleArithmeticExpression
		')'
		    |
		'!'
		ruleBaseExpr
		    |
		ruleMathFunc
		'('
		ruleArithmeticExpression
		')'
		    |
		ruleLiteral
		    |
		ruleRefOrCall
	)
;

// Rule Literal
ruleLiteral:
	(
		ruleBooleanLiteral
		    |
		ruleStringLiteral
		    |
		ruleNumberLiteral
	)
;

// Rule BooleanLiteral
ruleBooleanLiteral:
	(
		RULE_TRUE
		    |RULE_FALSE
	)
;

// Rule StringLiteral
ruleStringLiteral:
	RULE_STRING
;

// Rule NumberLiteral
ruleNumberLiteral:
	RULE_DOUBLE
;

// Rule MathFunc
ruleMathFunc:
	(
		'sqrt'
		    |
		'abs'
	)
;

// Rule PrimitiveType
rulePrimitiveType:
	(
		'int'
		    |
		'char'
		    |
		'double'
		    |
		'String'
	)
;

// Rule RelationalOp
ruleRelationalOp:
	(
		'>'
		    |
		'>='
		    |
		'=='
		    |
		'!='
		    |
		'<='
		    |
		'<'
	)
;

// Rule TertiaryOp
ruleTertiaryOp:
	(
		'+'
		    |
		'-'
		    |
		'||'
	)
;

// Rule SecondaryOp
ruleSecondaryOp:
	(
		'%'
		    |
		'^'
	)
;

// Rule PrimaryOp
rulePrimaryOp:
	(
		'*'
		    |
		'/'
		    |
		'&&'
	)
;

RULE_DOUBLE : RULE_INT ('.' RULE_INT)?;

RULE_TRUE : 'true';

RULE_FALSE : 'false';

RULE_ASSIGNMENT_OP : '=';

RULE_NEWLINE : '\n';

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

fragment RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/' {skip();};

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')? {skip();};

RULE_WS : (' '|'\t'|'\r'|'\n')+ {skip();};

RULE_ANY_OTHER : .;
