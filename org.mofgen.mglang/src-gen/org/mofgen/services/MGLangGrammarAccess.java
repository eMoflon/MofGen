/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MGLangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MofgenFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MofgenFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPatternsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPatternsPatternParserRuleCall_1_0_0 = (RuleCall)cPatternsAssignment_1_0.eContents().get(0);
		private final Assignment cGeneratorsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cGeneratorsGeneratorParserRuleCall_1_1_0 = (RuleCall)cGeneratorsAssignment_1_1.eContents().get(0);
		
		//// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es ben√∂tigt wird?
		//MofgenFile:
		//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+=Import* (patterns+=Pattern | generators+=Generator)*
		public Group getGroup() { return cGroup; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }
		
		//(patterns+=Pattern | generators+=Generator)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//patterns+=Pattern
		public Assignment getPatternsAssignment_1_0() { return cPatternsAssignment_1_0; }
		
		//Pattern
		public RuleCall getPatternsPatternParserRuleCall_1_0_0() { return cPatternsPatternParserRuleCall_1_0_0; }
		
		//generators+=Generator
		public Assignment getGeneratorsAssignment_1_1() { return cGeneratorsAssignment_1_1; }
		
		//Generator
		public RuleCall getGeneratorsGeneratorParserRuleCall_1_1_0() { return cGeneratorsGeneratorParserRuleCall_1_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAliasAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAliasIDTerminalRuleCall_3_0 = (RuleCall)cAliasAssignment_3.eContents().get(0);
		
		//Import:
		//	'import' name=STRING 'as' alias=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=STRING 'as' alias=ID
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//alias=ID
		public Assignment getAliasAssignment_3() { return cAliasAssignment_3; }
		
		//ID
		public RuleCall getAliasIDTerminalRuleCall_3_0() { return cAliasIDTerminalRuleCall_3_0; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPatternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cNodesAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cNodesPatternNodeCreationParserRuleCall_4_0_0 = (RuleCall)cNodesAssignment_4_0.eContents().get(0);
		private final Assignment cRefsAssignsAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_4_1_0 = (RuleCall)cRefsAssignsAssignment_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnPatternReturnParserRuleCall_6_0 = (RuleCall)cReturnAssignment_6.eContents().get(0);
		
		//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
		//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (nodes+=PatternNodeCreation |
		//	refsAssigns+=NodeReferenceOrAssignment)* //TODO: Validate order of node creation and assignments?
		//	'}' return=PatternReturn;
		@Override public ParserRule getRule() { return rule; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (nodes+=PatternNodeCreation |
		//refsAssigns+=NodeReferenceOrAssignment)* //TODO: Validate order of node creation and assignments?
		//'}' return=PatternReturn
		public Group getGroup() { return cGroup; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern'
		public Keyword getPatternKeyword_0() { return cPatternKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0_0() { return cParametersParameterParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(nodes+=PatternNodeCreation | refsAssigns+=NodeReferenceOrAssignment)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//nodes+=PatternNodeCreation
		public Assignment getNodesAssignment_4_0() { return cNodesAssignment_4_0; }
		
		//PatternNodeCreation
		public RuleCall getNodesPatternNodeCreationParserRuleCall_4_0_0() { return cNodesPatternNodeCreationParserRuleCall_4_0_0; }
		
		//refsAssigns+=NodeReferenceOrAssignment
		public Assignment getRefsAssignsAssignment_4_1() { return cRefsAssignsAssignment_4_1; }
		
		//NodeReferenceOrAssignment
		public RuleCall getRefsAssignsNodeReferenceOrAssignmentParserRuleCall_4_1_0() { return cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_4_1_0; }
		
		////TODO: Validate order of node creation and assignments?
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
		
		//return=PatternReturn
		public Assignment getReturnAssignment_6() { return cReturnAssignment_6; }
		
		//PatternReturn
		public RuleCall getReturnPatternReturnParserRuleCall_6_0() { return cReturnPatternReturnParserRuleCall_6_0; }
	}
	public class PatternReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternReturn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cThisUsedAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cThisUsedThisKeyword_1_0 = (Keyword)cThisUsedAssignment_1.eContents().get(0);
		
		//PatternReturn: //Is a return obligatory? TODO
		//	'return' thisUsed?='this' // ('.' returnValue=[Node])? TODO
		//	// TODO Is a this obligatory? And what does it do exactly?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////Is a return obligatory? TODO
		//'return' thisUsed?='this'
		public Group getGroup() { return cGroup; }
		
		////Is a return obligatory? TODO
		//'return'
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }
		
		//thisUsed?='this'
		public Assignment getThisUsedAssignment_1() { return cThisUsedAssignment_1; }
		
		//'this'
		public Keyword getThisUsedThisKeyword_1_0() { return cThisUsedThisKeyword_1_0; }
	}
	public class PatternNodeCreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternNodeCreation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNodeNodeParserRuleCall_0_0 = (RuleCall)cNodeAssignment_0.eContents().get(0);
		private final Assignment cConstructorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstructorNodeConstructorParserRuleCall_1_0 = (RuleCall)cConstructorAssignment_1.eContents().get(0);
		
		//// Nodes
		//PatternNodeCreation:
		//	node=Node constructor=NodeConstructor?;
		@Override public ParserRule getRule() { return rule; }
		
		//node=Node constructor=NodeConstructor?
		public Group getGroup() { return cGroup; }
		
		//node=Node
		public Assignment getNodeAssignment_0() { return cNodeAssignment_0; }
		
		//Node
		public RuleCall getNodeNodeParserRuleCall_0_0() { return cNodeNodeParserRuleCall_0_0; }
		
		//constructor=NodeConstructor?
		public Assignment getConstructorAssignment_1() { return cConstructorAssignment_1; }
		
		//NodeConstructor
		public RuleCall getConstructorNodeConstructorParserRuleCall_1_0() { return cConstructorNodeConstructorParserRuleCall_1_0; }
	}
	public class NodeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeConstructorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamsLiteralExpressionParserRuleCall_2_0 = (RuleCall)cParamsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//NodeConstructor:
		//	{NodeConstructor} '(' params+=LiteralExpression* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodeConstructor} '(' params+=LiteralExpression* ')'
		public Group getGroup() { return cGroup; }
		
		//{NodeConstructor}
		public Action getNodeConstructorAction_0() { return cNodeConstructorAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//params+=LiteralExpression*
		public Assignment getParamsAssignment_2() { return cParamsAssignment_2; }
		
		//LiteralExpression
		public RuleCall getParamsLiteralExpressionParserRuleCall_2_0() { return cParamsLiteralExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class NodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Node");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Node:
		//	type=[ecore::EClass] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClass] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_0_0() { return cTypeEClassCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_0_0_1() { return cTypeEClassIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class NodeReferenceOrAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeReferenceOrAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cPatternNodeReferenceParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConditionConditionParserRuleCall_1_1_0 = (RuleCall)cConditionAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//NodeReferenceOrAssignment:
		//	(PatternNodeReference | Assignment) ('[' condition=Condition ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//(PatternNodeReference | Assignment) ('[' condition=Condition ']')?
		public Group getGroup() { return cGroup; }
		
		//(PatternNodeReference | Assignment)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//PatternNodeReference
		public RuleCall getPatternNodeReferenceParserRuleCall_0_0() { return cPatternNodeReferenceParserRuleCall_0_0; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_0_1() { return cAssignmentParserRuleCall_0_1; }
		
		//('[' condition=Condition ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//condition=Condition
		public Assignment getConditionAssignment_1_1() { return cConditionAssignment_1_1; }
		
		//Condition
		public RuleCall getConditionConditionParserRuleCall_1_1_0() { return cConditionConditionParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class ConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Condition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLhsParameterCrossReference_0_0 = (CrossReference)cLhsAssignment_0.eContents().get(0);
		private final RuleCall cLhsParameterIDTerminalRuleCall_0_0_1 = (RuleCall)cLhsParameterCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cRelationAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cRelationEditorRelationEnumRuleCall_1_0_0 = (RuleCall)cRelationAssignment_1_0.eContents().get(0);
		private final Assignment cRhsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cRhsParameterCrossReference_1_1_0 = (CrossReference)cRhsAssignment_1_1.eContents().get(0);
		private final RuleCall cRhsParameterIDTerminalRuleCall_1_1_0_1 = (RuleCall)cRhsParameterCrossReference_1_1_0.eContents().get(1);
		
		//Condition:
		//	lhs=[Parameter] (relation=EditorRelation rhs=[Parameter])?;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=[Parameter] (relation=EditorRelation rhs=[Parameter])?
		public Group getGroup() { return cGroup; }
		
		//lhs=[Parameter]
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//[Parameter]
		public CrossReference getLhsParameterCrossReference_0_0() { return cLhsParameterCrossReference_0_0; }
		
		//ID
		public RuleCall getLhsParameterIDTerminalRuleCall_0_0_1() { return cLhsParameterIDTerminalRuleCall_0_0_1; }
		
		//(relation=EditorRelation rhs=[Parameter])?
		public Group getGroup_1() { return cGroup_1; }
		
		//relation=EditorRelation
		public Assignment getRelationAssignment_1_0() { return cRelationAssignment_1_0; }
		
		//EditorRelation
		public RuleCall getRelationEditorRelationEnumRuleCall_1_0_0() { return cRelationEditorRelationEnumRuleCall_1_0_0; }
		
		//rhs=[Parameter]
		public Assignment getRhsAssignment_1_1() { return cRhsAssignment_1_1; }
		
		//[Parameter]
		public CrossReference getRhsParameterCrossReference_1_1_0() { return cRhsParameterCrossReference_1_1_0; }
		
		//ID
		public RuleCall getRhsParameterIDTerminalRuleCall_1_1_0_1() { return cRhsParameterIDTerminalRuleCall_1_1_0_1; }
	}
	public class PatternNodeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternNodeReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSourceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSourceNodeCrossReference_0_0 = (CrossReference)cSourceAssignment_0.eContents().get(0);
		private final RuleCall cSourceNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cSourceNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeEReferenceCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeEReferenceCrossReference_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTargetNodeCrossReference_4_0 = (CrossReference)cTargetAssignment_4.eContents().get(0);
		private final RuleCall cTargetNodeIDTerminalRuleCall_4_0_1 = (RuleCall)cTargetNodeCrossReference_4_0.eContents().get(1);
		
		//PatternNodeReference:
		//	source=[Node] '-' type=[ecore::EReference] '->' target=[Node];
		@Override public ParserRule getRule() { return rule; }
		
		//source=[Node] '-' type=[ecore::EReference] '->' target=[Node]
		public Group getGroup() { return cGroup; }
		
		//source=[Node]
		public Assignment getSourceAssignment_0() { return cSourceAssignment_0; }
		
		//[Node]
		public CrossReference getSourceNodeCrossReference_0_0() { return cSourceNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getSourceNodeIDTerminalRuleCall_0_0_1() { return cSourceNodeIDTerminalRuleCall_0_0_1; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_2_0() { return cTypeEReferenceCrossReference_2_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_2_0_1() { return cTypeEReferenceIDTerminalRuleCall_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//target=[Node]
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }
		
		//[Node]
		public CrossReference getTargetNodeCrossReference_4_0() { return cTargetNodeCrossReference_4_0; }
		
		//ID
		public RuleCall getTargetNodeIDTerminalRuleCall_4_0_1() { return cTargetNodeIDTerminalRuleCall_4_0_1; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTargetAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTargetNodeAttributeCallParserRuleCall_0_0 = (RuleCall)cTargetAssignment_0.eContents().get(0);
		private final RuleCall cPATTERN_ASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueLiteralExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		////TODO: "doc -entries-> entry" f√ºgt einen entry in entries hinzu oder weist entries objekt entry zu? Das f√ºhrt zu zweideutigkeiten so
		//Assignment:
		//	target=NodeAttributeCall PATTERN_ASSIGNMENT_OP value=LiteralExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//target=NodeAttributeCall PATTERN_ASSIGNMENT_OP value=LiteralExpression
		public Group getGroup() { return cGroup; }
		
		//target=NodeAttributeCall
		public Assignment getTargetAssignment_0() { return cTargetAssignment_0; }
		
		//NodeAttributeCall
		public RuleCall getTargetNodeAttributeCallParserRuleCall_0_0() { return cTargetNodeAttributeCallParserRuleCall_0_0; }
		
		//PATTERN_ASSIGNMENT_OP
		public RuleCall getPATTERN_ASSIGNMENT_OPTerminalRuleCall_1() { return cPATTERN_ASSIGNMENT_OPTerminalRuleCall_1; }
		
		//value=LiteralExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//LiteralExpression
		public RuleCall getValueLiteralExpressionParserRuleCall_2_0() { return cValueLiteralExpressionParserRuleCall_2_0; }
	}
	public class NodeAttributeCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeAttributeCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cObjectAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cObjectNodeCrossReference_0_0 = (CrossReference)cObjectAssignment_0.eContents().get(0);
		private final RuleCall cObjectNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cObjectNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cAttributeEAttributeCrossReference_2_0 = (CrossReference)cAttributeAssignment_2.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_2_0_1 = (RuleCall)cAttributeEAttributeCrossReference_2_0.eContents().get(1);
		
		//NodeAttributeCall:
		//	object=[Node] '.' attribute=[ecore::EAttribute];
		@Override public ParserRule getRule() { return rule; }
		
		//object=[Node] '.' attribute=[ecore::EAttribute]
		public Group getGroup() { return cGroup; }
		
		//object=[Node]
		public Assignment getObjectAssignment_0() { return cObjectAssignment_0; }
		
		//[Node]
		public CrossReference getObjectNodeCrossReference_0_0() { return cObjectNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getObjectNodeIDTerminalRuleCall_0_0_1() { return cObjectNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_2_0() { return cAttributeEAttributeCrossReference_2_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_2_0_1() { return cAttributeEAttributeIDTerminalRuleCall_2_0_1; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeEClassifierCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_2_0_1 = (RuleCall)cTypeEClassifierCrossReference_2_0.eContents().get(1);
		
		//Parameter:
		//	name=ID ':' type=[ecore::EClassifier];
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=[ecore::EClassifier]
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_2_0() { return cTypeEClassifierCrossReference_2_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_2_0_1() { return cTypeEClassifierIDTerminalRuleCall_2_0_1; }
	}
	public class GeneratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Generator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGeneratorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCommandsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommandsGeneratorElementParserRuleCall_5_0 = (RuleCall)cCommandsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Generator:
		//	'generator' name=ID '('
		//	// TODO	
		//	')' '{' commands+=GeneratorElement* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'generator' name=ID '(' // TODO	
		//')' '{' commands+=GeneratorElement* '}'
		public Group getGroup() { return cGroup; }
		
		//'generator'
		public Keyword getGeneratorKeyword_0() { return cGeneratorKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//// TODO	
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//commands+=GeneratorElement*
		public Assignment getCommandsAssignment_5() { return cCommandsAssignment_5; }
		
		//GeneratorElement
		public RuleCall getCommandsGeneratorElementParserRuleCall_5_0() { return cCommandsGeneratorElementParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class GeneratorElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGeneratorCommandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GeneratorElement:
		//	GeneratorCommand | ForLoop;
		@Override public ParserRule getRule() { return rule; }
		
		//GeneratorCommand | ForLoop
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GeneratorCommand
		public RuleCall getGeneratorCommandParserRuleCall_0() { return cGeneratorCommandParserRuleCall_0; }
		
		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }
	}
	public class GeneratorCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPatternCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPatternObjectCreationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GeneratorCommand:
		//	PatternCall | PatternObjectCreation;
		@Override public ParserRule getRule() { return rule; }
		
		////Only serves as super class for all possible commands within generator
		//PatternCall | PatternObjectCreation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////Only serves as super class for all possible commands within generator
		//PatternCall
		public RuleCall getPatternCallParserRuleCall_0() { return cPatternCallParserRuleCall_0; }
		
		//PatternObjectCreation
		public RuleCall getPatternObjectCreationParserRuleCall_1() { return cPatternObjectCreationParserRuleCall_1; }
	}
	public class PatternCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledPatternAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledPatternPatternCrossReference_0_0 = (CrossReference)cCalledPatternAssignment_0.eContents().get(0);
		private final RuleCall cCalledPatternPatternIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledPatternPatternCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsPatternObjectParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" erm√∂glichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject √ºbersetzen?
		//PatternCall:
		//	calledPattern=[Pattern] ('(' params+=PatternObject* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//calledPattern=[Pattern] ('(' params+=PatternObject* ')')?
		public Group getGroup() { return cGroup; }
		
		//calledPattern=[Pattern]
		public Assignment getCalledPatternAssignment_0() { return cCalledPatternAssignment_0; }
		
		//[Pattern]
		public CrossReference getCalledPatternPatternCrossReference_0_0() { return cCalledPatternPatternCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledPatternPatternIDTerminalRuleCall_0_0_1() { return cCalledPatternPatternIDTerminalRuleCall_0_0_1; }
		
		//('(' params+=PatternObject* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//params+=PatternObject*
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//PatternObject
		public RuleCall getParamsPatternObjectParserRuleCall_1_1_0() { return cParamsPatternObjectParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class PatternObjectCreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObjectCreation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPObjectAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPObjectPatternObjectParserRuleCall_0_0 = (RuleCall)cPObjectAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cPatternCallAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternCallPatternCallParserRuleCall_2_0 = (RuleCall)cPatternCallAssignment_2.eContents().get(0);
		
		//PatternObjectCreation:
		//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
		@Override public ParserRule getRule() { return rule; }
		
		//pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall
		public Group getGroup() { return cGroup; }
		
		//pObject=PatternObject
		public Assignment getPObjectAssignment_0() { return cPObjectAssignment_0; }
		
		//PatternObject
		public RuleCall getPObjectPatternObjectParserRuleCall_0_0() { return cPObjectPatternObjectParserRuleCall_0_0; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//patternCall=PatternCall
		public Assignment getPatternCallAssignment_2() { return cPatternCallAssignment_2; }
		
		//PatternCall
		public RuleCall getPatternCallPatternCallParserRuleCall_2_0() { return cPatternCallPatternCallParserRuleCall_2_0; }
	}
	public class PatternObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypePatternCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypePatternIDTerminalRuleCall_0_0_1 = (RuleCall)cTypePatternCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PatternObject:
		//	type=[Pattern] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Pattern] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[Pattern]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Pattern]
		public CrossReference getTypePatternCrossReference_0_0() { return cTypePatternCrossReference_0_0; }
		
		//ID
		public RuleCall getTypePatternIDTerminalRuleCall_0_0_1() { return cTypePatternIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIteratorVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIteratorVarIDTerminalRuleCall_1_0 = (RuleCall)cIteratorVarAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIteratingConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIteratingConditionForConditionParserRuleCall_3_0 = (RuleCall)cIteratingConditionAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCommandsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommandsGeneratorCommandParserRuleCall_5_0 = (RuleCall)cCommandsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ForLoop:
		//	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
		//	commands+=GeneratorCommand*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{' commands+=GeneratorCommand* '}'
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_1() { return cIteratorVarAssignment_1; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_1_0() { return cIteratorVarIDTerminalRuleCall_1_0; }
		
		//'in'
		public Keyword getInKeyword_2() { return cInKeyword_2; }
		
		//iteratingCondition=ForCondition
		public Assignment getIteratingConditionAssignment_3() { return cIteratingConditionAssignment_3; }
		
		//ForCondition
		public RuleCall getIteratingConditionForConditionParserRuleCall_3_0() { return cIteratingConditionForConditionParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//commands+=GeneratorCommand*
		public Assignment getCommandsAssignment_5() { return cCommandsAssignment_5; }
		
		//GeneratorCommand
		public RuleCall getCommandsGeneratorCommandParserRuleCall_5_0() { return cCommandsGeneratorCommandParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ForConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForEachCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForRangeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ForCondition:
		//	ForEachCollection | ForRange;
		@Override public ParserRule getRule() { return rule; }
		
		//ForEachCollection | ForRange
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForEachCollection
		public RuleCall getForEachCollectionParserRuleCall_0() { return cForEachCollectionParserRuleCall_0; }
		
		//ForRange
		public RuleCall getForRangeParserRuleCall_1() { return cForRangeParserRuleCall_1; }
	}
	public class ForEachCollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForEachCollection");
		private final Assignment cCollAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCollNodeAttributeCallParserRuleCall_0 = (RuleCall)cCollAssignment.eContents().get(0);
		
		//ForEachCollection:
		//	coll=NodeAttributeCall;
		@Override public ParserRule getRule() { return rule; }
		
		//coll=NodeAttributeCall
		public Assignment getCollAssignment() { return cCollAssignment; }
		
		//NodeAttributeCall
		public RuleCall getCollNodeAttributeCallParserRuleCall_0() { return cCollNodeAttributeCallParserRuleCall_0; }
	}
	public class ForRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForRange");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartINTTerminalRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndINTTerminalRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//ForRange:
		//	start=INT ':' end=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//start=INT ':' end=INT
		public Group getGroup() { return cGroup; }
		
		//start=INT
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//INT
		public RuleCall getStartINTTerminalRuleCall_0_0() { return cStartINTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//end=INT
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//INT
		public RuleCall getEndINTTerminalRuleCall_2_0() { return cEndINTTerminalRuleCall_2_0; }
	}
	public class LiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.LiteralExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBooleanLiteralAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cValueAlternatives_0_1_0 = (Alternatives)cValueAssignment_0_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_0_1_0_0 = (Keyword)cValueAlternatives_0_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_0_1_0_1 = (Keyword)cValueAlternatives_0_1_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumberLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final RuleCall cNumberLiteralParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cStringLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		
		//LiteralExpression:
		//	{BooleanLiteral} value=('true' | 'false') | {NumberLiteral} NumberLiteral | {StringLiteral} value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//{BooleanLiteral} value=('true' | 'false') | {NumberLiteral} NumberLiteral | {StringLiteral} value=STRING
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{BooleanLiteral} value=('true' | 'false')
		public Group getGroup_0() { return cGroup_0; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_0_0() { return cBooleanLiteralAction_0_0; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_0_1_0() { return cValueAlternatives_0_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_0_1_0_0() { return cValueTrueKeyword_0_1_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_0_1_0_1() { return cValueFalseKeyword_0_1_0_1; }
		
		//{NumberLiteral} NumberLiteral
		public Group getGroup_1() { return cGroup_1; }
		
		//{NumberLiteral}
		public Action getNumberLiteralAction_1_0() { return cNumberLiteralAction_1_0; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_1_1() { return cNumberLiteralParserRuleCall_1_1; }
		
		//{StringLiteral} value=STRING
		public Group getGroup_2() { return cGroup_2; }
		
		//{StringLiteral}
		public Action getStringLiteralAction_2_0() { return cStringLiteralAction_2_0; }
		
		//value=STRING
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_2_1_0() { return cValueSTRINGTerminalRuleCall_2_1_0; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NumberLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//NumberLiteral:
		//	'-'? INT ('.' INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT ('.' INT)?
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//('.' INT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'.'
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2_1() { return cINTTerminalRuleCall_2_1; }
	}
	
	public class EditorRelationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.EditorRelation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLER_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cSMALLER_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLEREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cSMALLERLessThanSignKeyword_5_0 = (Keyword)cSMALLEREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum EditorRelation:
		//	GREATER='>' |
		//	GREATER_OR_EQUAL='>=' |
		//	EQUAL='==' |
		//	UNEQUAL='!=' |
		//	SMALLER_OR_EQUAL='<=' |
		//	SMALLER='<';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' | GREATER_OR_EQUAL='>=' | EQUAL='==' | UNEQUAL='!=' | SMALLER_OR_EQUAL='<=' | SMALLER='<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }
		
		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }
		
		//UNEQUAL='!='
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_3() { return cUNEQUALEnumLiteralDeclaration_3; }
		
		//'!='
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_3_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_3_0; }
		
		//SMALLER_OR_EQUAL='<='
		public EnumLiteralDeclaration getSMALLER_OR_EQUALEnumLiteralDeclaration_4() { return cSMALLER_OR_EQUALEnumLiteralDeclaration_4; }
		
		//'<='
		public Keyword getSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
		
		//SMALLER='<'
		public EnumLiteralDeclaration getSMALLEREnumLiteralDeclaration_5() { return cSMALLEREnumLiteralDeclaration_5; }
		
		//'<'
		public Keyword getSMALLERLessThanSignKeyword_5_0() { return cSMALLERLessThanSignKeyword_5_0; }
	}
	
	private final MofgenFileElements pMofgenFile;
	private final ImportElements pImport;
	private final PatternElements pPattern;
	private final PatternReturnElements pPatternReturn;
	private final PatternNodeCreationElements pPatternNodeCreation;
	private final NodeConstructorElements pNodeConstructor;
	private final NodeElements pNode;
	private final NodeReferenceOrAssignmentElements pNodeReferenceOrAssignment;
	private final ConditionElements pCondition;
	private final PatternNodeReferenceElements pPatternNodeReference;
	private final AssignmentElements pAssignment;
	private final NodeAttributeCallElements pNodeAttributeCall;
	private final ParameterElements pParameter;
	private final GeneratorElements pGenerator;
	private final GeneratorElementElements pGeneratorElement;
	private final GeneratorCommandElements pGeneratorCommand;
	private final PatternCallElements pPatternCall;
	private final PatternObjectCreationElements pPatternObjectCreation;
	private final PatternObjectElements pPatternObject;
	private final ForLoopElements pForLoop;
	private final ForConditionElements pForCondition;
	private final ForEachCollectionElements pForEachCollection;
	private final ForRangeElements pForRange;
	private final LiteralExpressionElements pLiteralExpression;
	private final NumberLiteralElements pNumberLiteral;
	private final EditorRelationElements eEditorRelation;
	private final TerminalRule tPATTERN_ASSIGNMENT_OP;
	private final TerminalRule tASSIGNMENT_OP;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MGLangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMofgenFile = new MofgenFileElements();
		this.pImport = new ImportElements();
		this.pPattern = new PatternElements();
		this.pPatternReturn = new PatternReturnElements();
		this.pPatternNodeCreation = new PatternNodeCreationElements();
		this.pNodeConstructor = new NodeConstructorElements();
		this.pNode = new NodeElements();
		this.pNodeReferenceOrAssignment = new NodeReferenceOrAssignmentElements();
		this.pCondition = new ConditionElements();
		this.pPatternNodeReference = new PatternNodeReferenceElements();
		this.pAssignment = new AssignmentElements();
		this.pNodeAttributeCall = new NodeAttributeCallElements();
		this.pParameter = new ParameterElements();
		this.pGenerator = new GeneratorElements();
		this.pGeneratorElement = new GeneratorElementElements();
		this.pGeneratorCommand = new GeneratorCommandElements();
		this.pPatternCall = new PatternCallElements();
		this.pPatternObjectCreation = new PatternObjectCreationElements();
		this.pPatternObject = new PatternObjectElements();
		this.pForLoop = new ForLoopElements();
		this.pForCondition = new ForConditionElements();
		this.pForEachCollection = new ForEachCollectionElements();
		this.pForRange = new ForRangeElements();
		this.pLiteralExpression = new LiteralExpressionElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.eEditorRelation = new EditorRelationElements();
		this.tPATTERN_ASSIGNMENT_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PATTERN_ASSIGNMENT_OP");
		this.tASSIGNMENT_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ASSIGNMENT_OP");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.mofgen.MGLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es ben√∂tigt wird?
	//MofgenFile:
	//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
	public MofgenFileElements getMofgenFileAccess() {
		return pMofgenFile;
	}
	
	public ParserRule getMofgenFileRule() {
		return getMofgenFileAccess().getRule();
	}
	
	//Import:
	//	'import' name=STRING 'as' alias=ID;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
	//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (nodes+=PatternNodeCreation |
	//	refsAssigns+=NodeReferenceOrAssignment)* //TODO: Validate order of node creation and assignments?
	//	'}' return=PatternReturn;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternReturn: //Is a return obligatory? TODO
	//	'return' thisUsed?='this' // ('.' returnValue=[Node])? TODO
	//	// TODO Is a this obligatory? And what does it do exactly?
	//;
	public PatternReturnElements getPatternReturnAccess() {
		return pPatternReturn;
	}
	
	public ParserRule getPatternReturnRule() {
		return getPatternReturnAccess().getRule();
	}
	
	//// Nodes
	//PatternNodeCreation:
	//	node=Node constructor=NodeConstructor?;
	public PatternNodeCreationElements getPatternNodeCreationAccess() {
		return pPatternNodeCreation;
	}
	
	public ParserRule getPatternNodeCreationRule() {
		return getPatternNodeCreationAccess().getRule();
	}
	
	//NodeConstructor:
	//	{NodeConstructor} '(' params+=LiteralExpression* ')';
	public NodeConstructorElements getNodeConstructorAccess() {
		return pNodeConstructor;
	}
	
	public ParserRule getNodeConstructorRule() {
		return getNodeConstructorAccess().getRule();
	}
	
	//Node:
	//	type=[ecore::EClass] name=ID;
	public NodeElements getNodeAccess() {
		return pNode;
	}
	
	public ParserRule getNodeRule() {
		return getNodeAccess().getRule();
	}
	
	//NodeReferenceOrAssignment:
	//	(PatternNodeReference | Assignment) ('[' condition=Condition ']')?;
	public NodeReferenceOrAssignmentElements getNodeReferenceOrAssignmentAccess() {
		return pNodeReferenceOrAssignment;
	}
	
	public ParserRule getNodeReferenceOrAssignmentRule() {
		return getNodeReferenceOrAssignmentAccess().getRule();
	}
	
	//Condition:
	//	lhs=[Parameter] (relation=EditorRelation rhs=[Parameter])?;
	public ConditionElements getConditionAccess() {
		return pCondition;
	}
	
	public ParserRule getConditionRule() {
		return getConditionAccess().getRule();
	}
	
	//PatternNodeReference:
	//	source=[Node] '-' type=[ecore::EReference] '->' target=[Node];
	public PatternNodeReferenceElements getPatternNodeReferenceAccess() {
		return pPatternNodeReference;
	}
	
	public ParserRule getPatternNodeReferenceRule() {
		return getPatternNodeReferenceAccess().getRule();
	}
	
	////TODO: "doc -entries-> entry" f√ºgt einen entry in entries hinzu oder weist entries objekt entry zu? Das f√ºhrt zu zweideutigkeiten so
	//Assignment:
	//	target=NodeAttributeCall PATTERN_ASSIGNMENT_OP value=LiteralExpression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//NodeAttributeCall:
	//	object=[Node] '.' attribute=[ecore::EAttribute];
	public NodeAttributeCallElements getNodeAttributeCallAccess() {
		return pNodeAttributeCall;
	}
	
	public ParserRule getNodeAttributeCallRule() {
		return getNodeAttributeCallAccess().getRule();
	}
	
	//Parameter:
	//	name=ID ':' type=[ecore::EClassifier];
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Generator:
	//	'generator' name=ID '('
	//	// TODO	
	//	')' '{' commands+=GeneratorElement* '}';
	public GeneratorElements getGeneratorAccess() {
		return pGenerator;
	}
	
	public ParserRule getGeneratorRule() {
		return getGeneratorAccess().getRule();
	}
	
	//GeneratorElement:
	//	GeneratorCommand | ForLoop;
	public GeneratorElementElements getGeneratorElementAccess() {
		return pGeneratorElement;
	}
	
	public ParserRule getGeneratorElementRule() {
		return getGeneratorElementAccess().getRule();
	}
	
	//GeneratorCommand:
	//	PatternCall | PatternObjectCreation;
	public GeneratorCommandElements getGeneratorCommandAccess() {
		return pGeneratorCommand;
	}
	
	public ParserRule getGeneratorCommandRule() {
		return getGeneratorCommandAccess().getRule();
	}
	
	////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" erm√∂glichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject √ºbersetzen?
	//PatternCall:
	//	calledPattern=[Pattern] ('(' params+=PatternObject* ')')?;
	public PatternCallElements getPatternCallAccess() {
		return pPatternCall;
	}
	
	public ParserRule getPatternCallRule() {
		return getPatternCallAccess().getRule();
	}
	
	//PatternObjectCreation:
	//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
	public PatternObjectCreationElements getPatternObjectCreationAccess() {
		return pPatternObjectCreation;
	}
	
	public ParserRule getPatternObjectCreationRule() {
		return getPatternObjectCreationAccess().getRule();
	}
	
	//PatternObject:
	//	type=[Pattern] name=ID;
	public PatternObjectElements getPatternObjectAccess() {
		return pPatternObject;
	}
	
	public ParserRule getPatternObjectRule() {
		return getPatternObjectAccess().getRule();
	}
	
	//ForLoop:
	//	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
	//	commands+=GeneratorCommand*
	//	'}';
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}
	
	//ForCondition:
	//	ForEachCollection | ForRange;
	public ForConditionElements getForConditionAccess() {
		return pForCondition;
	}
	
	public ParserRule getForConditionRule() {
		return getForConditionAccess().getRule();
	}
	
	//ForEachCollection:
	//	coll=NodeAttributeCall;
	public ForEachCollectionElements getForEachCollectionAccess() {
		return pForEachCollection;
	}
	
	public ParserRule getForEachCollectionRule() {
		return getForEachCollectionAccess().getRule();
	}
	
	//ForRange:
	//	start=INT ':' end=INT;
	public ForRangeElements getForRangeAccess() {
		return pForRange;
	}
	
	public ParserRule getForRangeRule() {
		return getForRangeAccess().getRule();
	}
	
	//LiteralExpression:
	//	{BooleanLiteral} value=('true' | 'false') | {NumberLiteral} NumberLiteral | {StringLiteral} value=STRING;
	public LiteralExpressionElements getLiteralExpressionAccess() {
		return pLiteralExpression;
	}
	
	public ParserRule getLiteralExpressionRule() {
		return getLiteralExpressionAccess().getRule();
	}
	
	//NumberLiteral:
	//	'-'? INT ('.' INT)?;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//enum EditorRelation:
	//	GREATER='>' |
	//	GREATER_OR_EQUAL='>=' |
	//	EQUAL='==' |
	//	UNEQUAL='!=' |
	//	SMALLER_OR_EQUAL='<=' |
	//	SMALLER='<';
	public EditorRelationElements getEditorRelationAccess() {
		return eEditorRelation;
	}
	
	public EnumRule getEditorRelationRule() {
		return getEditorRelationAccess().getRule();
	}
	
	//terminal PATTERN_ASSIGNMENT_OP:
	//	':=';
	public TerminalRule getPATTERN_ASSIGNMENT_OPRule() {
		return tPATTERN_ASSIGNMENT_OP;
	}
	
	//terminal ASSIGNMENT_OP:
	//	'=';
	public TerminalRule getASSIGNMENT_OPRule() {
		return tASSIGNMENT_OP;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
