/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MGLangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MofgenFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MofgenFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPatternsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPatternsPatternParserRuleCall_1_0_0 = (RuleCall)cPatternsAssignment_1_0.eContents().get(0);
		private final Assignment cGeneratorsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cGeneratorsGeneratorParserRuleCall_1_1_0 = (RuleCall)cGeneratorsAssignment_1_1.eContents().get(0);
		
		//// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es benötigt wird?
		//MofgenFile:
		//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+=Import* (patterns+=Pattern | generators+=Generator)*
		public Group getGroup() { return cGroup; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }
		
		//(patterns+=Pattern | generators+=Generator)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//patterns+=Pattern
		public Assignment getPatternsAssignment_1_0() { return cPatternsAssignment_1_0; }
		
		//Pattern
		public RuleCall getPatternsPatternParserRuleCall_1_0_0() { return cPatternsPatternParserRuleCall_1_0_0; }
		
		//generators+=Generator
		public Assignment getGeneratorsAssignment_1_1() { return cGeneratorsAssignment_1_1; }
		
		//Generator
		public RuleCall getGeneratorsGeneratorParserRuleCall_1_1_0() { return cGeneratorsGeneratorParserRuleCall_1_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAliasAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAliasIDTerminalRuleCall_3_0 = (RuleCall)cAliasAssignment_3.eContents().get(0);
		
		//Import:
		//	'import' name=STRING 'as' alias=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=STRING 'as' alias=ID
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//alias=ID
		public Assignment getAliasAssignment_3() { return cAliasAssignment_3; }
		
		//ID
		public RuleCall getAliasIDTerminalRuleCall_3_0() { return cAliasIDTerminalRuleCall_3_0; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPatternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cNodesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cNodesNodeParserRuleCall_4_0 = (RuleCall)cNodesAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnPatternReturnParserRuleCall_6_0 = (RuleCall)cReturnAssignment_6.eContents().get(0);
		
		//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
		//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' nodes+=Node* '}'
		//	return=PatternReturn?;
		@Override public ParserRule getRule() { return rule; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' nodes+=Node* '}'
		//return=PatternReturn?
		public Group getGroup() { return cGroup; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern'
		public Keyword getPatternKeyword_0() { return cPatternKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0_0() { return cParametersParameterParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//nodes+=Node*
		public Assignment getNodesAssignment_4() { return cNodesAssignment_4; }
		
		//Node
		public RuleCall getNodesNodeParserRuleCall_4_0() { return cNodesNodeParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
		
		//return=PatternReturn?
		public Assignment getReturnAssignment_6() { return cReturnAssignment_6; }
		
		//PatternReturn
		public RuleCall getReturnPatternReturnParserRuleCall_6_0() { return cReturnPatternReturnParserRuleCall_6_0; }
	}
	public class PatternReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternReturn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternReturnAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cThisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cFullStopKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReturnValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cReturnValueNodeCrossReference_3_1_0 = (CrossReference)cReturnValueAssignment_3_1.eContents().get(0);
		private final RuleCall cReturnValueNodeIDTerminalRuleCall_3_1_0_1 = (RuleCall)cReturnValueNodeCrossReference_3_1_0.eContents().get(1);
		
		//PatternReturn:
		//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?
		public Group getGroup() { return cGroup; }
		
		//{PatternReturn}
		public Action getPatternReturnAction_0() { return cPatternReturnAction_0; }
		
		//'return'
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }
		
		//'this'
		public Keyword getThisKeyword_2() { return cThisKeyword_2; }
		
		//('.' returnValue=[Node])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'.'
		public Keyword getFullStopKeyword_3_0() { return cFullStopKeyword_3_0; }
		
		//returnValue=[Node]
		public Assignment getReturnValueAssignment_3_1() { return cReturnValueAssignment_3_1; }
		
		//[Node]
		public CrossReference getReturnValueNodeCrossReference_3_1_0() { return cReturnValueNodeCrossReference_3_1_0; }
		
		//ID
		public RuleCall getReturnValueNodeIDTerminalRuleCall_3_1_0_1() { return cReturnValueNodeIDTerminalRuleCall_3_1_0_1; }
	}
	public class NodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Node");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cCreatedByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cCreatedByAlternatives_2_0 = (Alternatives)cCreatedByAssignment_2.eContents().get(0);
		private final RuleCall cCreatedByNodeConstructorParserRuleCall_2_0_0 = (RuleCall)cCreatedByAlternatives_2_0.eContents().get(0);
		private final RuleCall cCreatedByPatternCallParserRuleCall_2_0_1 = (RuleCall)cCreatedByAlternatives_2_0.eContents().get(1);
		
		//Node:
		//	type=[ecore::EClass] name=ID createdBy=(NodeConstructor | PatternCall)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClass] name=ID createdBy=(NodeConstructor | PatternCall)?
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_0_0() { return cTypeEClassCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_0_0_1() { return cTypeEClassIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//createdBy=(NodeConstructor | PatternCall)?
		public Assignment getCreatedByAssignment_2() { return cCreatedByAssignment_2; }
		
		//(NodeConstructor | PatternCall)
		public Alternatives getCreatedByAlternatives_2_0() { return cCreatedByAlternatives_2_0; }
		
		//NodeConstructor
		public RuleCall getCreatedByNodeConstructorParserRuleCall_2_0_0() { return cCreatedByNodeConstructorParserRuleCall_2_0_0; }
		
		//PatternCall
		public RuleCall getCreatedByPatternCallParserRuleCall_2_0_1() { return cCreatedByPatternCallParserRuleCall_2_0_1; }
	}
	public class NodeConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeConstructorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefsAssignsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0 = (RuleCall)cRefsAssignsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//NodeConstructor:
		//	{NodeConstructor} '{' refsAssigns+=NodeReferenceOrAssignment* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodeConstructor} '{' refsAssigns+=NodeReferenceOrAssignment* '}'
		public Group getGroup() { return cGroup; }
		
		//{NodeConstructor}
		public Action getNodeConstructorAction_0() { return cNodeConstructorAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//refsAssigns+=NodeReferenceOrAssignment*
		public Assignment getRefsAssignsAssignment_2() { return cRefsAssignsAssignment_2; }
		
		//NodeReferenceOrAssignment
		public RuleCall getRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0() { return cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class PatternCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledPatternCrossReference_0_0 = (CrossReference)cCalledAssignment_0.eContents().get(0);
		private final RuleCall cCalledPatternIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledPatternCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamsStringExpressionParserRuleCall_2_0 = (RuleCall)cParamsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PatternCall:
		//	called=[Pattern] '(' params+=StringExpression* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//called=[Pattern] '(' params+=StringExpression* ')'
		public Group getGroup() { return cGroup; }
		
		//called=[Pattern]
		public Assignment getCalledAssignment_0() { return cCalledAssignment_0; }
		
		//[Pattern]
		public CrossReference getCalledPatternCrossReference_0_0() { return cCalledPatternCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledPatternIDTerminalRuleCall_0_0_1() { return cCalledPatternIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//params+=StringExpression*
		public Assignment getParamsAssignment_2() { return cParamsAssignment_2; }
		
		//StringExpression
		public RuleCall getParamsStringExpressionParserRuleCall_2_0() { return cParamsStringExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class NodeReferenceOrAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeReferenceOrAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cPatternNodeReferenceParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConditionBooleanExpressionParserRuleCall_1_1_0 = (RuleCall)cConditionAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//NodeReferenceOrAssignment:
		//	(PatternNodeReference | Assignment) ('[' condition=BooleanExpression ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//(PatternNodeReference | Assignment) ('[' condition=BooleanExpression ']')?
		public Group getGroup() { return cGroup; }
		
		//(PatternNodeReference | Assignment)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//PatternNodeReference
		public RuleCall getPatternNodeReferenceParserRuleCall_0_0() { return cPatternNodeReferenceParserRuleCall_0_0; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_0_1() { return cAssignmentParserRuleCall_0_1; }
		
		//('[' condition=BooleanExpression ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//condition=BooleanExpression
		public Assignment getConditionAssignment_1_1() { return cConditionAssignment_1_1; }
		
		//BooleanExpression
		public RuleCall getConditionBooleanExpressionParserRuleCall_1_1_0() { return cConditionBooleanExpressionParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class PatternNodeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternNodeReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEReferenceCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEReferenceCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTargetNodeCrossReference_2_0 = (CrossReference)cTargetAssignment_2.eContents().get(0);
		private final RuleCall cTargetNodeIDTerminalRuleCall_2_0_1 = (RuleCall)cTargetNodeCrossReference_2_0.eContents().get(1);
		
		//PatternNodeReference:
		//	type=[ecore::EReference] '->' target=[Node];
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EReference] '->' target=[Node]
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_0_0() { return cTypeEReferenceCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_0_0_1() { return cTypeEReferenceIDTerminalRuleCall_0_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//target=[Node]
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }
		
		//[Node]
		public CrossReference getTargetNodeCrossReference_2_0() { return cTargetNodeCrossReference_2_0; }
		
		//ID
		public RuleCall getTargetNodeIDTerminalRuleCall_2_0_1() { return cTargetNodeIDTerminalRuleCall_2_0_1; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTargetAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTargetEAttributeCrossReference_0_0 = (CrossReference)cTargetAssignment_0.eContents().get(0);
		private final RuleCall cTargetEAttributeIDTerminalRuleCall_0_0_1 = (RuleCall)cTargetEAttributeCrossReference_0_0.eContents().get(1);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueStringExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		////TODO: "doc -entries-> entry" fügt einen entry in entries hinzu oder weist entries objekt entry zu? Das führt zu zweideutigkeiten so
		//Assignment:
		//	target=[ecore::EAttribute] ASSIGNMENT_OP value=StringExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//target=[ecore::EAttribute] ASSIGNMENT_OP value=StringExpression
		public Group getGroup() { return cGroup; }
		
		//target=[ecore::EAttribute]
		public Assignment getTargetAssignment_0() { return cTargetAssignment_0; }
		
		//[ecore::EAttribute]
		public CrossReference getTargetEAttributeCrossReference_0_0() { return cTargetEAttributeCrossReference_0_0; }
		
		//ID
		public RuleCall getTargetEAttributeIDTerminalRuleCall_0_0_1() { return cTargetEAttributeIDTerminalRuleCall_0_0_1; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//value=StringExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//StringExpression
		public RuleCall getValueStringExpressionParserRuleCall_2_0() { return cValueStringExpressionParserRuleCall_2_0; }
	}
	public class NodeAttributeCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeAttributeCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNodeNodeCrossReference_0_0 = (CrossReference)cNodeAssignment_0.eContents().get(0);
		private final RuleCall cNodeNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cNodeNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cAttributeEAttributeCrossReference_2_0 = (CrossReference)cAttributeAssignment_2.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_2_0_1 = (RuleCall)cAttributeEAttributeCrossReference_2_0.eContents().get(1);
		
		////TODO make Enum Assignments possible
		//NodeAttributeCall:
		//	node=[Node] '.' attribute=[ecore::EAttribute];
		@Override public ParserRule getRule() { return rule; }
		
		//node=[Node] '.' attribute=[ecore::EAttribute]
		public Group getGroup() { return cGroup; }
		
		//node=[Node]
		public Assignment getNodeAssignment_0() { return cNodeAssignment_0; }
		
		//[Node]
		public CrossReference getNodeNodeCrossReference_0_0() { return cNodeNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getNodeNodeIDTerminalRuleCall_0_0_1() { return cNodeNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_2_0() { return cAttributeEAttributeCrossReference_2_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_2_0_1() { return cAttributeEAttributeIDTerminalRuleCall_2_0_1; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Parameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObjectParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Parameter:
		//	PrimitiveParameter | ObjectParameter;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimitiveParameter | ObjectParameter
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimitiveParameter
		public RuleCall getPrimitiveParameterParserRuleCall_0() { return cPrimitiveParameterParserRuleCall_0; }
		
		//ObjectParameter
		public RuleCall getObjectParameterParserRuleCall_1() { return cObjectParameterParserRuleCall_1; }
	}
	public class PrimitiveParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypePrimitiveTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PrimitiveParameter:
		//	type=PrimitiveType name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=PrimitiveType name=ID
		public Group getGroup() { return cGroup; }
		
		//type=PrimitiveType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//PrimitiveType
		public RuleCall getTypePrimitiveTypeEnumRuleCall_0_0() { return cTypePrimitiveTypeEnumRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ObjectParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ObjectParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ObjectParameter:
		//	type=[ecore::EClassifier] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClassifier] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_0_0() { return cTypeEClassifierCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ParameterOrMethodCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterOrMethodCall");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ParameterOrMethodCall:
		//	ParameterRef | MethodCall;
		@Override public ParserRule getRule() { return rule; }
		
		//ParameterRef | MethodCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ParameterRef
		public RuleCall getParameterRefParserRuleCall_0() { return cParameterRefParserRuleCall_0; }
		
		//MethodCall
		public RuleCall getMethodCallParserRuleCall_1() { return cMethodCallParserRuleCall_1; }
	}
	public class ParameterRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterRef");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefParameterCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefParameterIDTerminalRuleCall_0_1 = (RuleCall)cRefParameterCrossReference_0.eContents().get(1);
		
		//ParameterRef:
		//	ref=[Parameter];
		@Override public ParserRule getRule() { return rule; }
		
		//ref=[Parameter]
		public Assignment getRefAssignment() { return cRefAssignment; }
		
		//[Parameter]
		public CrossReference getRefParameterCrossReference_0() { return cRefParameterCrossReference_0; }
		
		//ID
		public RuleCall getRefParameterIDTerminalRuleCall_0_1() { return cRefParameterIDTerminalRuleCall_0_1; }
	}
	public class MethodCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MethodCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledNodeNodeCrossReference_0_0 = (CrossReference)cCalledNodeAssignment_0.eContents().get(0);
		private final RuleCall cCalledNodeNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledNodeNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMethodAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cMethodEOperationCrossReference_2_0 = (CrossReference)cMethodAssignment_2.eContents().get(0);
		private final RuleCall cMethodEOperationIDTerminalRuleCall_2_0_1 = (RuleCall)cMethodEOperationCrossReference_2_0.eContents().get(1);
		
		//MethodCall:
		//	calledNode=[Node] '.' method=[ecore::EOperation];
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Scoping
		//calledNode=[Node] '.' method=[ecore::EOperation]
		public Group getGroup() { return cGroup; }
		
		////TODO Scoping
		//calledNode=[Node]
		public Assignment getCalledNodeAssignment_0() { return cCalledNodeAssignment_0; }
		
		//[Node]
		public CrossReference getCalledNodeNodeCrossReference_0_0() { return cCalledNodeNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledNodeNodeIDTerminalRuleCall_0_0_1() { return cCalledNodeNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//method=[ecore::EOperation]
		public Assignment getMethodAssignment_2() { return cMethodAssignment_2; }
		
		//[ecore::EOperation]
		public CrossReference getMethodEOperationCrossReference_2_0() { return cMethodEOperationCrossReference_2_0; }
		
		//ID
		public RuleCall getMethodEOperationIDTerminalRuleCall_2_0_1() { return cMethodEOperationIDTerminalRuleCall_2_0_1; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanExpression");
		private final RuleCall cBooleanOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//BooleanExpression:
		//	BooleanOr;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanOr
		public RuleCall getBooleanOrParserRuleCall() { return cBooleanOrParserRuleCall; }
	}
	public class RelationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsParameterOrMethodCallParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cRelationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationRelationalOpEnumRuleCall_1_0 = (RuleCall)cRelationAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsParameterOrMethodCallParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//RelationExpression BooleanExpression:
		//	lhs=ParameterOrMethodCall relation=RelationalOp rhs=ParameterOrMethodCall;
		@Override public ParserRule getRule() { return rule; }
		
		//lhs=ParameterOrMethodCall relation=RelationalOp rhs=ParameterOrMethodCall
		public Group getGroup() { return cGroup; }
		
		//lhs=ParameterOrMethodCall
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }
		
		//ParameterOrMethodCall
		public RuleCall getLhsParameterOrMethodCallParserRuleCall_0_0() { return cLhsParameterOrMethodCallParserRuleCall_0_0; }
		
		//relation=RelationalOp
		public Assignment getRelationAssignment_1() { return cRelationAssignment_1; }
		
		//RelationalOp
		public RuleCall getRelationRelationalOpEnumRuleCall_1_0() { return cRelationRelationalOpEnumRuleCall_1_0; }
		
		//rhs=ParameterOrMethodCall
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }
		
		//ParameterOrMethodCall
		public RuleCall getRhsParameterOrMethodCallParserRuleCall_2_0() { return cRhsParameterOrMethodCallParserRuleCall_2_0; }
	}
	public class BooleanOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanXorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanXorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BooleanOr BooleanExpression:
		//	BooleanXor ({Or.left=current} '||' right=BooleanXor)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanXor ({Or.left=current} '||' right=BooleanXor)*
		public Group getGroup() { return cGroup; }
		
		//BooleanXor
		public RuleCall getBooleanXorParserRuleCall_0() { return cBooleanXorParserRuleCall_0; }
		
		//({Or.left=current} '||' right=BooleanXor)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }
		
		//right=BooleanXor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BooleanXor
		public RuleCall getRightBooleanXorParserRuleCall_1_2_0() { return cRightBooleanXorParserRuleCall_1_2_0; }
	}
	public class BooleanXorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanXor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cXorLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BooleanXor BooleanExpression:
		//	BooleanAnd ({Xor.left=current} '^' right=BooleanAnd)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanAnd ({Xor.left=current} '^' right=BooleanAnd)*
		public Group getGroup() { return cGroup; }
		
		//BooleanAnd
		public RuleCall getBooleanAndParserRuleCall_0() { return cBooleanAndParserRuleCall_0; }
		
		//({Xor.left=current} '^' right=BooleanAnd)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Xor.left=current}
		public Action getXorLeftAction_1_0() { return cXorLeftAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//right=BooleanAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BooleanAnd
		public RuleCall getRightBooleanAndParserRuleCall_1_2_0() { return cRightBooleanAndParserRuleCall_1_2_0; }
	}
	public class BooleanAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseBooleanParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBaseBooleanParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//BooleanAnd BooleanExpression:
		//	BaseBoolean ({And.left=current} '&&' right=BaseBoolean)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BaseBoolean ({And.left=current} '&&' right=BaseBoolean)*
		public Group getGroup() { return cGroup; }
		
		//BaseBoolean
		public RuleCall getBaseBooleanParserRuleCall_0() { return cBaseBooleanParserRuleCall_0; }
		
		//({And.left=current} '&&' right=BaseBoolean)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//'&&'
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }
		
		//right=BaseBoolean
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BaseBoolean
		public RuleCall getRightBaseBooleanParserRuleCall_1_2_0() { return cRightBaseBooleanParserRuleCall_1_2_0; }
	}
	public class BaseBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BaseBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cNegatedBooleanAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cExprAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cExprBooleanExpressionParserRuleCall_0_3_0 = (RuleCall)cExprAssignment_0_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBooleanExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueBooleanEnumRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final RuleCall cRelationExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//BaseBoolean BooleanExpression:
		//	{NegatedBoolean} '!' '(' expr=BooleanExpression ')' | '(' BooleanExpression ')' | {BooleanLiteral} value=Boolean |
		//	RelationExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//{NegatedBoolean} '!' '(' expr=BooleanExpression ')' | '(' BooleanExpression ')' | {BooleanLiteral} value=Boolean |
		//RelationExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{NegatedBoolean} '!' '(' expr=BooleanExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//{NegatedBoolean}
		public Action getNegatedBooleanAction_0_0() { return cNegatedBooleanAction_0_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_0_1() { return cExclamationMarkKeyword_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_2() { return cLeftParenthesisKeyword_0_2; }
		
		//expr=BooleanExpression
		public Assignment getExprAssignment_0_3() { return cExprAssignment_0_3; }
		
		//BooleanExpression
		public RuleCall getExprBooleanExpressionParserRuleCall_0_3_0() { return cExprBooleanExpressionParserRuleCall_0_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_4() { return cRightParenthesisKeyword_0_4; }
		
		//'(' BooleanExpression ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_1_1() { return cBooleanExpressionParserRuleCall_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
		
		//{BooleanLiteral} value=Boolean
		public Group getGroup_2() { return cGroup_2; }
		
		//{BooleanLiteral}
		public Action getBooleanLiteralAction_2_0() { return cBooleanLiteralAction_2_0; }
		
		//value=Boolean
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//Boolean
		public RuleCall getValueBooleanEnumRuleCall_2_1_0() { return cValueBooleanEnumRuleCall_2_1_0; }
		
		//RelationExpression
		public RuleCall getRelationExpressionParserRuleCall_3() { return cRelationExpressionParserRuleCall_3; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NumberLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueNUMBERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumberLiteral:
		//	value=NUMBER;
		@Override public ParserRule getRule() { return rule; }
		
		//value=NUMBER
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//NUMBER
		public RuleCall getValueNUMBERTerminalRuleCall_0() { return cValueNUMBERTerminalRuleCall_0; }
	}
	public class StringExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.StringExpression");
		private final RuleCall cStringConcatenationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StringExpression:
		//	StringConcatenation;
		@Override public ParserRule getRule() { return rule; }
		
		//StringConcatenation
		public RuleCall getStringConcatenationParserRuleCall() { return cStringConcatenationParserRuleCall; }
	}
	public class StringConcatenationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.StringConcatenation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConcatLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightStringConcatenationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//StringConcatenation STRING:
		//	StringLiteral ({Concat.left=current} '+' right=StringConcatenation)?;
		@Override public ParserRule getRule() { return rule; }
		
		//StringLiteral ({Concat.left=current} '+' right=StringConcatenation)?
		public Group getGroup() { return cGroup; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_0() { return cStringLiteralParserRuleCall_0; }
		
		//({Concat.left=current} '+' right=StringConcatenation)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{Concat.left=current}
		public Action getConcatLeftAction_1_0() { return cConcatLeftAction_1_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }
		
		//right=StringConcatenation
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//StringConcatenation
		public RuleCall getRightStringConcatenationParserRuleCall_1_2_0() { return cRightStringConcatenationParserRuleCall_1_2_0; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteral STRING:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class GeneratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Generator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGeneratorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCommandsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommandsGeneratorElementParserRuleCall_5_0 = (RuleCall)cCommandsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Generator:
		//	{Generator} 'gen' '('
		//	// TODO	
		//	')' '{' commands+=GeneratorElement* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Generator} 'gen' '(' // TODO	
		//')' '{' commands+=GeneratorElement* '}'
		public Group getGroup() { return cGroup; }
		
		//{Generator}
		public Action getGeneratorAction_0() { return cGeneratorAction_0; }
		
		//'gen'
		public Keyword getGenKeyword_1() { return cGenKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//// TODO	
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//commands+=GeneratorElement*
		public Assignment getCommandsAssignment_5() { return cCommandsAssignment_5; }
		
		//GeneratorElement
		public RuleCall getCommandsGeneratorElementParserRuleCall_5_0() { return cCommandsGeneratorElementParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class GeneratorElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGeneratorCommandParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForLoopParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GeneratorElement:
		//	GeneratorCommand | ForLoop;
		@Override public ParserRule getRule() { return rule; }
		
		//GeneratorCommand | ForLoop
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GeneratorCommand
		public RuleCall getGeneratorCommandParserRuleCall_0() { return cGeneratorCommandParserRuleCall_0; }
		
		//ForLoop
		public RuleCall getForLoopParserRuleCall_1() { return cForLoopParserRuleCall_1; }
	}
	public class GeneratorCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPatternCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPatternObjectCreationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GeneratorCommand:
		//	PatternCall | PatternObjectCreation;
		@Override public ParserRule getRule() { return rule; }
		
		////Only serves as super class for all possible commands within generator
		//PatternCall | PatternObjectCreation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////Only serves as super class for all possible commands within generator
		//PatternCall
		public RuleCall getPatternCallParserRuleCall_0() { return cPatternCallParserRuleCall_0; }
		
		//PatternObjectCreation
		public RuleCall getPatternObjectCreationParserRuleCall_1() { return cPatternObjectCreationParserRuleCall_1; }
	}
	public class GenPatternCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GenPatternCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledPatternAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledPatternPatternCrossReference_0_0 = (CrossReference)cCalledPatternAssignment_0.eContents().get(0);
		private final RuleCall cCalledPatternPatternIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledPatternPatternCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsPatternObjectParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermöglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject übersetzen?
		//GenPatternCall:
		//	calledPattern=[Pattern] ('(' params+=PatternObject* ')')?;
		@Override public ParserRule getRule() { return rule; }
		
		//calledPattern=[Pattern] ('(' params+=PatternObject* ')')?
		public Group getGroup() { return cGroup; }
		
		//calledPattern=[Pattern]
		public Assignment getCalledPatternAssignment_0() { return cCalledPatternAssignment_0; }
		
		//[Pattern]
		public CrossReference getCalledPatternPatternCrossReference_0_0() { return cCalledPatternPatternCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledPatternPatternIDTerminalRuleCall_0_0_1() { return cCalledPatternPatternIDTerminalRuleCall_0_0_1; }
		
		//('(' params+=PatternObject* ')')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//params+=PatternObject*
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//PatternObject
		public RuleCall getParamsPatternObjectParserRuleCall_1_1_0() { return cParamsPatternObjectParserRuleCall_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}
	public class PatternObjectCreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObjectCreation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPObjectAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPObjectPatternObjectParserRuleCall_0_0 = (RuleCall)cPObjectAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cPatternCallAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternCallPatternCallParserRuleCall_2_0 = (RuleCall)cPatternCallAssignment_2.eContents().get(0);
		
		//PatternObjectCreation:
		//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
		@Override public ParserRule getRule() { return rule; }
		
		//pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall
		public Group getGroup() { return cGroup; }
		
		//pObject=PatternObject
		public Assignment getPObjectAssignment_0() { return cPObjectAssignment_0; }
		
		//PatternObject
		public RuleCall getPObjectPatternObjectParserRuleCall_0_0() { return cPObjectPatternObjectParserRuleCall_0_0; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//patternCall=PatternCall
		public Assignment getPatternCallAssignment_2() { return cPatternCallAssignment_2; }
		
		//PatternCall
		public RuleCall getPatternCallPatternCallParserRuleCall_2_0() { return cPatternCallPatternCallParserRuleCall_2_0; }
	}
	public class PatternObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypePatternCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypePatternIDTerminalRuleCall_0_0_1 = (RuleCall)cTypePatternCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PatternObject:
		//	type=[Pattern] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Pattern] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[Pattern]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Pattern]
		public CrossReference getTypePatternCrossReference_0_0() { return cTypePatternCrossReference_0_0; }
		
		//ID
		public RuleCall getTypePatternIDTerminalRuleCall_0_0_1() { return cTypePatternIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ForLoopElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForLoop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIteratorVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIteratorVarIDTerminalRuleCall_1_0 = (RuleCall)cIteratorVarAssignment_1.eContents().get(0);
		private final Keyword cInKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIteratingConditionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIteratingConditionForConditionParserRuleCall_3_0 = (RuleCall)cIteratingConditionAssignment_3.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCommandsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCommandsGeneratorCommandParserRuleCall_5_0 = (RuleCall)cCommandsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ForLoop:
		//	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
		//	commands+=GeneratorCommand*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{' commands+=GeneratorCommand* '}'
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_1() { return cIteratorVarAssignment_1; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_1_0() { return cIteratorVarIDTerminalRuleCall_1_0; }
		
		//'in'
		public Keyword getInKeyword_2() { return cInKeyword_2; }
		
		//iteratingCondition=ForCondition
		public Assignment getIteratingConditionAssignment_3() { return cIteratingConditionAssignment_3; }
		
		//ForCondition
		public RuleCall getIteratingConditionForConditionParserRuleCall_3_0() { return cIteratingConditionForConditionParserRuleCall_3_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//commands+=GeneratorCommand*
		public Assignment getCommandsAssignment_5() { return cCommandsAssignment_5; }
		
		//GeneratorCommand
		public RuleCall getCommandsGeneratorCommandParserRuleCall_5_0() { return cCommandsGeneratorCommandParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ForConditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForCondition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForEachCollectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForRangeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ForCondition:
		//	ForEachCollection | ForRange;
		@Override public ParserRule getRule() { return rule; }
		
		//ForEachCollection | ForRange
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForEachCollection
		public RuleCall getForEachCollectionParserRuleCall_0() { return cForEachCollectionParserRuleCall_0; }
		
		//ForRange
		public RuleCall getForRangeParserRuleCall_1() { return cForRangeParserRuleCall_1; }
	}
	public class ForEachCollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForEachCollection");
		private final Assignment cCollAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCollNodeAttributeCallParserRuleCall_0 = (RuleCall)cCollAssignment.eContents().get(0);
		
		//ForEachCollection:
		//	coll=NodeAttributeCall;
		@Override public ParserRule getRule() { return rule; }
		
		//coll=NodeAttributeCall
		public Assignment getCollAssignment() { return cCollAssignment; }
		
		//NodeAttributeCall
		public RuleCall getCollNodeAttributeCallParserRuleCall_0() { return cCollNodeAttributeCallParserRuleCall_0; }
	}
	public class ForRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForRange");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartINTTerminalRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndINTTerminalRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//ForRange:
		//	start=INT ':' end=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//start=INT ':' end=INT
		public Group getGroup() { return cGroup; }
		
		//start=INT
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//INT
		public RuleCall getStartINTTerminalRuleCall_0_0() { return cStartINTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//end=INT
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//INT
		public RuleCall getEndINTTerminalRuleCall_2_0() { return cEndINTTerminalRuleCall_2_0; }
	}
	
	public class BooleanElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Boolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTRUEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTRUETrueKeyword_0_0 = (Keyword)cTRUEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cFALSEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cFALSEFalseKeyword_1_0 = (Keyword)cFALSEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Boolean:
		//	TRUE='true' | FALSE='false';
		public EnumRule getRule() { return rule; }
		
		//TRUE='true' | FALSE='false'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TRUE='true'
		public EnumLiteralDeclaration getTRUEEnumLiteralDeclaration_0() { return cTRUEEnumLiteralDeclaration_0; }
		
		//'true'
		public Keyword getTRUETrueKeyword_0_0() { return cTRUETrueKeyword_0_0; }
		
		//FALSE='false'
		public EnumLiteralDeclaration getFALSEEnumLiteralDeclaration_1() { return cFALSEEnumLiteralDeclaration_1; }
		
		//'false'
		public Keyword getFALSEFalseKeyword_1_0() { return cFALSEFalseKeyword_1_0; }
	}
	public class PrimitiveTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINTIntKeyword_0_0 = (Keyword)cINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCHAREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCHARCharKeyword_1_0 = (Keyword)cCHAREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDOUBLEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDOUBLEDoubleKeyword_2_0 = (Keyword)cDOUBLEEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PrimitiveType:
		//	INT='int' | CHAR='char' | DOUBLE='double';
		public EnumRule getRule() { return rule; }
		
		//INT='int' | CHAR='char' | DOUBLE='double'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT='int'
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_0() { return cINTEnumLiteralDeclaration_0; }
		
		//'int'
		public Keyword getINTIntKeyword_0_0() { return cINTIntKeyword_0_0; }
		
		//CHAR='char'
		public EnumLiteralDeclaration getCHAREnumLiteralDeclaration_1() { return cCHAREnumLiteralDeclaration_1; }
		
		//'char'
		public Keyword getCHARCharKeyword_1_0() { return cCHARCharKeyword_1_0; }
		
		//DOUBLE='double'
		public EnumLiteralDeclaration getDOUBLEEnumLiteralDeclaration_2() { return cDOUBLEEnumLiteralDeclaration_2; }
		
		//'double'
		public Keyword getDOUBLEDoubleKeyword_2_0() { return cDOUBLEDoubleKeyword_2_0; }
	}
	public class RelationalOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLER_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cSMALLER_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLEREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cSMALLERLessThanSignKeyword_5_0 = (Keyword)cSMALLEREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum RelationalOp:
		//	GREATER='>' |
		//	GREATER_OR_EQUAL='>=' |
		//	EQUAL='==' |
		//	UNEQUAL='!=' |
		//	SMALLER_OR_EQUAL='<=' |
		//	SMALLER='<';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' | GREATER_OR_EQUAL='>=' | EQUAL='==' | UNEQUAL='!=' | SMALLER_OR_EQUAL='<=' | SMALLER='<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }
		
		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }
		
		//UNEQUAL='!='
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_3() { return cUNEQUALEnumLiteralDeclaration_3; }
		
		//'!='
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_3_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_3_0; }
		
		//SMALLER_OR_EQUAL='<='
		public EnumLiteralDeclaration getSMALLER_OR_EQUALEnumLiteralDeclaration_4() { return cSMALLER_OR_EQUALEnumLiteralDeclaration_4; }
		
		//'<='
		public Keyword getSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
		
		//SMALLER='<'
		public EnumLiteralDeclaration getSMALLEREnumLiteralDeclaration_5() { return cSMALLEREnumLiteralDeclaration_5; }
		
		//'<'
		public Keyword getSMALLERLessThanSignKeyword_5_0() { return cSMALLERLessThanSignKeyword_5_0; }
	}
	
	private final MofgenFileElements pMofgenFile;
	private final ImportElements pImport;
	private final PatternElements pPattern;
	private final PatternReturnElements pPatternReturn;
	private final NodeElements pNode;
	private final NodeConstructorElements pNodeConstructor;
	private final PatternCallElements pPatternCall;
	private final NodeReferenceOrAssignmentElements pNodeReferenceOrAssignment;
	private final PatternNodeReferenceElements pPatternNodeReference;
	private final AssignmentElements pAssignment;
	private final NodeAttributeCallElements pNodeAttributeCall;
	private final ParameterElements pParameter;
	private final PrimitiveParameterElements pPrimitiveParameter;
	private final ObjectParameterElements pObjectParameter;
	private final ParameterOrMethodCallElements pParameterOrMethodCall;
	private final ParameterRefElements pParameterRef;
	private final MethodCallElements pMethodCall;
	private final BooleanExpressionElements pBooleanExpression;
	private final RelationExpressionElements pRelationExpression;
	private final BooleanOrElements pBooleanOr;
	private final BooleanXorElements pBooleanXor;
	private final BooleanAndElements pBooleanAnd;
	private final BaseBooleanElements pBaseBoolean;
	private final BooleanElements eBoolean;
	private final NumberLiteralElements pNumberLiteral;
	private final TerminalRule tINT;
	private final TerminalRule tNUMBER;
	private final StringExpressionElements pStringExpression;
	private final StringConcatenationElements pStringConcatenation;
	private final StringLiteralElements pStringLiteral;
	private final PrimitiveTypeElements ePrimitiveType;
	private final GeneratorElements pGenerator;
	private final GeneratorElementElements pGeneratorElement;
	private final GeneratorCommandElements pGeneratorCommand;
	private final GenPatternCallElements pGenPatternCall;
	private final PatternObjectCreationElements pPatternObjectCreation;
	private final PatternObjectElements pPatternObject;
	private final ForLoopElements pForLoop;
	private final ForConditionElements pForCondition;
	private final ForEachCollectionElements pForEachCollection;
	private final ForRangeElements pForRange;
	private final RelationalOpElements eRelationalOp;
	private final TerminalRule tASSIGNMENT_OP;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MGLangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMofgenFile = new MofgenFileElements();
		this.pImport = new ImportElements();
		this.pPattern = new PatternElements();
		this.pPatternReturn = new PatternReturnElements();
		this.pNode = new NodeElements();
		this.pNodeConstructor = new NodeConstructorElements();
		this.pPatternCall = new PatternCallElements();
		this.pNodeReferenceOrAssignment = new NodeReferenceOrAssignmentElements();
		this.pPatternNodeReference = new PatternNodeReferenceElements();
		this.pAssignment = new AssignmentElements();
		this.pNodeAttributeCall = new NodeAttributeCallElements();
		this.pParameter = new ParameterElements();
		this.pPrimitiveParameter = new PrimitiveParameterElements();
		this.pObjectParameter = new ObjectParameterElements();
		this.pParameterOrMethodCall = new ParameterOrMethodCallElements();
		this.pParameterRef = new ParameterRefElements();
		this.pMethodCall = new MethodCallElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pRelationExpression = new RelationExpressionElements();
		this.pBooleanOr = new BooleanOrElements();
		this.pBooleanXor = new BooleanXorElements();
		this.pBooleanAnd = new BooleanAndElements();
		this.pBaseBoolean = new BaseBooleanElements();
		this.eBoolean = new BooleanElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.INT");
		this.tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NUMBER");
		this.pStringExpression = new StringExpressionElements();
		this.pStringConcatenation = new StringConcatenationElements();
		this.pStringLiteral = new StringLiteralElements();
		this.ePrimitiveType = new PrimitiveTypeElements();
		this.pGenerator = new GeneratorElements();
		this.pGeneratorElement = new GeneratorElementElements();
		this.pGeneratorCommand = new GeneratorCommandElements();
		this.pGenPatternCall = new GenPatternCallElements();
		this.pPatternObjectCreation = new PatternObjectCreationElements();
		this.pPatternObject = new PatternObjectElements();
		this.pForLoop = new ForLoopElements();
		this.pForCondition = new ForConditionElements();
		this.pForEachCollection = new ForEachCollectionElements();
		this.pForRange = new ForRangeElements();
		this.eRelationalOp = new RelationalOpElements();
		this.tASSIGNMENT_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ASSIGNMENT_OP");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.mofgen.MGLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// TODO: Arithmetics von Re.action auslagern und dann mit in eMoflon-Projekt packen und importieren, wo es benötigt wird?
	//MofgenFile:
	//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
	public MofgenFileElements getMofgenFileAccess() {
		return pMofgenFile;
	}
	
	public ParserRule getMofgenFileRule() {
		return getMofgenFileAccess().getRule();
	}
	
	//Import:
	//	'import' name=STRING 'as' alias=ID;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
	//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' nodes+=Node* '}'
	//	return=PatternReturn?;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternReturn:
	//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
	public PatternReturnElements getPatternReturnAccess() {
		return pPatternReturn;
	}
	
	public ParserRule getPatternReturnRule() {
		return getPatternReturnAccess().getRule();
	}
	
	//Node:
	//	type=[ecore::EClass] name=ID createdBy=(NodeConstructor | PatternCall)?;
	public NodeElements getNodeAccess() {
		return pNode;
	}
	
	public ParserRule getNodeRule() {
		return getNodeAccess().getRule();
	}
	
	//NodeConstructor:
	//	{NodeConstructor} '{' refsAssigns+=NodeReferenceOrAssignment* '}';
	public NodeConstructorElements getNodeConstructorAccess() {
		return pNodeConstructor;
	}
	
	public ParserRule getNodeConstructorRule() {
		return getNodeConstructorAccess().getRule();
	}
	
	//PatternCall:
	//	called=[Pattern] '(' params+=StringExpression* ')';
	public PatternCallElements getPatternCallAccess() {
		return pPatternCall;
	}
	
	public ParserRule getPatternCallRule() {
		return getPatternCallAccess().getRule();
	}
	
	//NodeReferenceOrAssignment:
	//	(PatternNodeReference | Assignment) ('[' condition=BooleanExpression ']')?;
	public NodeReferenceOrAssignmentElements getNodeReferenceOrAssignmentAccess() {
		return pNodeReferenceOrAssignment;
	}
	
	public ParserRule getNodeReferenceOrAssignmentRule() {
		return getNodeReferenceOrAssignmentAccess().getRule();
	}
	
	//PatternNodeReference:
	//	type=[ecore::EReference] '->' target=[Node];
	public PatternNodeReferenceElements getPatternNodeReferenceAccess() {
		return pPatternNodeReference;
	}
	
	public ParserRule getPatternNodeReferenceRule() {
		return getPatternNodeReferenceAccess().getRule();
	}
	
	////TODO: "doc -entries-> entry" fügt einen entry in entries hinzu oder weist entries objekt entry zu? Das führt zu zweideutigkeiten so
	//Assignment:
	//	target=[ecore::EAttribute] ASSIGNMENT_OP value=StringExpression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	////TODO make Enum Assignments possible
	//NodeAttributeCall:
	//	node=[Node] '.' attribute=[ecore::EAttribute];
	public NodeAttributeCallElements getNodeAttributeCallAccess() {
		return pNodeAttributeCall;
	}
	
	public ParserRule getNodeAttributeCallRule() {
		return getNodeAttributeCallAccess().getRule();
	}
	
	//Parameter:
	//	PrimitiveParameter | ObjectParameter;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//PrimitiveParameter:
	//	type=PrimitiveType name=ID;
	public PrimitiveParameterElements getPrimitiveParameterAccess() {
		return pPrimitiveParameter;
	}
	
	public ParserRule getPrimitiveParameterRule() {
		return getPrimitiveParameterAccess().getRule();
	}
	
	//ObjectParameter:
	//	type=[ecore::EClassifier] name=ID;
	public ObjectParameterElements getObjectParameterAccess() {
		return pObjectParameter;
	}
	
	public ParserRule getObjectParameterRule() {
		return getObjectParameterAccess().getRule();
	}
	
	//ParameterOrMethodCall:
	//	ParameterRef | MethodCall;
	public ParameterOrMethodCallElements getParameterOrMethodCallAccess() {
		return pParameterOrMethodCall;
	}
	
	public ParserRule getParameterOrMethodCallRule() {
		return getParameterOrMethodCallAccess().getRule();
	}
	
	//ParameterRef:
	//	ref=[Parameter];
	public ParameterRefElements getParameterRefAccess() {
		return pParameterRef;
	}
	
	public ParserRule getParameterRefRule() {
		return getParameterRefAccess().getRule();
	}
	
	//MethodCall:
	//	calledNode=[Node] '.' method=[ecore::EOperation];
	public MethodCallElements getMethodCallAccess() {
		return pMethodCall;
	}
	
	public ParserRule getMethodCallRule() {
		return getMethodCallAccess().getRule();
	}
	
	//BooleanExpression:
	//	BooleanOr;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//RelationExpression BooleanExpression:
	//	lhs=ParameterOrMethodCall relation=RelationalOp rhs=ParameterOrMethodCall;
	public RelationExpressionElements getRelationExpressionAccess() {
		return pRelationExpression;
	}
	
	public ParserRule getRelationExpressionRule() {
		return getRelationExpressionAccess().getRule();
	}
	
	//BooleanOr BooleanExpression:
	//	BooleanXor ({Or.left=current} '||' right=BooleanXor)*;
	public BooleanOrElements getBooleanOrAccess() {
		return pBooleanOr;
	}
	
	public ParserRule getBooleanOrRule() {
		return getBooleanOrAccess().getRule();
	}
	
	//BooleanXor BooleanExpression:
	//	BooleanAnd ({Xor.left=current} '^' right=BooleanAnd)*;
	public BooleanXorElements getBooleanXorAccess() {
		return pBooleanXor;
	}
	
	public ParserRule getBooleanXorRule() {
		return getBooleanXorAccess().getRule();
	}
	
	//BooleanAnd BooleanExpression:
	//	BaseBoolean ({And.left=current} '&&' right=BaseBoolean)*;
	public BooleanAndElements getBooleanAndAccess() {
		return pBooleanAnd;
	}
	
	public ParserRule getBooleanAndRule() {
		return getBooleanAndAccess().getRule();
	}
	
	//BaseBoolean BooleanExpression:
	//	{NegatedBoolean} '!' '(' expr=BooleanExpression ')' | '(' BooleanExpression ')' | {BooleanLiteral} value=Boolean |
	//	RelationExpression;
	public BaseBooleanElements getBaseBooleanAccess() {
		return pBaseBoolean;
	}
	
	public ParserRule getBaseBooleanRule() {
		return getBaseBooleanAccess().getRule();
	}
	
	//enum Boolean:
	//	TRUE='true' | FALSE='false';
	public BooleanElements getBooleanAccess() {
		return eBoolean;
	}
	
	public EnumRule getBooleanRule() {
		return getBooleanAccess().getRule();
	}
	
	//NumberLiteral:
	//	value=NUMBER;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//@Override
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal NUMBER:
	//	'-'? INT ('.' INT)?;
	public TerminalRule getNUMBERRule() {
		return tNUMBER;
	}
	
	//StringExpression:
	//	StringConcatenation;
	public StringExpressionElements getStringExpressionAccess() {
		return pStringExpression;
	}
	
	public ParserRule getStringExpressionRule() {
		return getStringExpressionAccess().getRule();
	}
	
	//StringConcatenation STRING:
	//	StringLiteral ({Concat.left=current} '+' right=StringConcatenation)?;
	public StringConcatenationElements getStringConcatenationAccess() {
		return pStringConcatenation;
	}
	
	public ParserRule getStringConcatenationRule() {
		return getStringConcatenationAccess().getRule();
	}
	
	//StringLiteral STRING:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//enum PrimitiveType:
	//	INT='int' | CHAR='char' | DOUBLE='double';
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return ePrimitiveType;
	}
	
	public EnumRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}
	
	//Generator:
	//	{Generator} 'gen' '('
	//	// TODO	
	//	')' '{' commands+=GeneratorElement* '}';
	public GeneratorElements getGeneratorAccess() {
		return pGenerator;
	}
	
	public ParserRule getGeneratorRule() {
		return getGeneratorAccess().getRule();
	}
	
	//GeneratorElement:
	//	GeneratorCommand | ForLoop;
	public GeneratorElementElements getGeneratorElementAccess() {
		return pGeneratorElement;
	}
	
	public ParserRule getGeneratorElementRule() {
		return getGeneratorElementAccess().getRule();
	}
	
	//GeneratorCommand:
	//	PatternCall | PatternObjectCreation;
	public GeneratorCommandElements getGeneratorCommandAccess() {
		return pGeneratorCommand;
	}
	
	public ParserRule getGeneratorCommandRule() {
		return getGeneratorCommandAccess().getRule();
	}
	
	////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermöglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject übersetzen?
	//GenPatternCall:
	//	calledPattern=[Pattern] ('(' params+=PatternObject* ')')?;
	public GenPatternCallElements getGenPatternCallAccess() {
		return pGenPatternCall;
	}
	
	public ParserRule getGenPatternCallRule() {
		return getGenPatternCallAccess().getRule();
	}
	
	//PatternObjectCreation:
	//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
	public PatternObjectCreationElements getPatternObjectCreationAccess() {
		return pPatternObjectCreation;
	}
	
	public ParserRule getPatternObjectCreationRule() {
		return getPatternObjectCreationAccess().getRule();
	}
	
	//PatternObject:
	//	type=[Pattern] name=ID;
	public PatternObjectElements getPatternObjectAccess() {
		return pPatternObject;
	}
	
	public ParserRule getPatternObjectRule() {
		return getPatternObjectAccess().getRule();
	}
	
	//ForLoop:
	//	'for' iteratorVar=ID 'in' iteratingCondition=ForCondition '{'
	//	commands+=GeneratorCommand*
	//	'}';
	public ForLoopElements getForLoopAccess() {
		return pForLoop;
	}
	
	public ParserRule getForLoopRule() {
		return getForLoopAccess().getRule();
	}
	
	//ForCondition:
	//	ForEachCollection | ForRange;
	public ForConditionElements getForConditionAccess() {
		return pForCondition;
	}
	
	public ParserRule getForConditionRule() {
		return getForConditionAccess().getRule();
	}
	
	//ForEachCollection:
	//	coll=NodeAttributeCall;
	public ForEachCollectionElements getForEachCollectionAccess() {
		return pForEachCollection;
	}
	
	public ParserRule getForEachCollectionRule() {
		return getForEachCollectionAccess().getRule();
	}
	
	//ForRange:
	//	start=INT ':' end=INT;
	public ForRangeElements getForRangeAccess() {
		return pForRange;
	}
	
	public ParserRule getForRangeRule() {
		return getForRangeAccess().getRule();
	}
	
	//enum RelationalOp:
	//	GREATER='>' |
	//	GREATER_OR_EQUAL='>=' |
	//	EQUAL='==' |
	//	UNEQUAL='!=' |
	//	SMALLER_OR_EQUAL='<=' |
	//	SMALLER='<';
	public RelationalOpElements getRelationalOpAccess() {
		return eRelationalOp;
	}
	
	public EnumRule getRelationalOpRule() {
		return getRelationalOpAccess().getRule();
	}
	
	//terminal ASSIGNMENT_OP:
	//	'=';
	public TerminalRule getASSIGNMENT_OPRule() {
		return tASSIGNMENT_OP;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
