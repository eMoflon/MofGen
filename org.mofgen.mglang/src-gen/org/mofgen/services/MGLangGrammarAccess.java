/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MGLangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MofgenFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MofgenFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cConfigAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConfigConfigParserRuleCall_1_0 = (RuleCall)cConfigAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cPatternsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cPatternsPatternParserRuleCall_2_0_0 = (RuleCall)cPatternsAssignment_2_0.eContents().get(0);
		private final Assignment cGeneratorsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cGeneratorsGeneratorParserRuleCall_2_1_0 = (RuleCall)cGeneratorsAssignment_2_1.eContents().get(0);
		
		////TODO: Make Aliases accessible
		////TODO: Variables
		//MofgenFile:
		//	imports+=Import*
		//	config=Config (patterns+=Pattern | generators+=Generator)*;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+=Import* config=Config (patterns+=Pattern | generators+=Generator)*
		public Group getGroup() { return cGroup; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }
		
		//config=Config
		public Assignment getConfigAssignment_1() { return cConfigAssignment_1; }
		
		//Config
		public RuleCall getConfigConfigParserRuleCall_1_0() { return cConfigConfigParserRuleCall_1_0; }
		
		//(patterns+=Pattern | generators+=Generator)*
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//patterns+=Pattern
		public Assignment getPatternsAssignment_2_0() { return cPatternsAssignment_2_0; }
		
		//Pattern
		public RuleCall getPatternsPatternParserRuleCall_2_0_0() { return cPatternsPatternParserRuleCall_2_0_0; }
		
		//generators+=Generator
		public Assignment getGeneratorsAssignment_2_1() { return cGeneratorsAssignment_2_1; }
		
		//Generator
		public RuleCall getGeneratorsGeneratorParserRuleCall_2_1_0() { return cGeneratorsGeneratorParserRuleCall_2_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAliasAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAliasIDTerminalRuleCall_3_0 = (RuleCall)cAliasAssignment_3.eContents().get(0);
		
		//Import:
		//	'import' name=STRING 'as' alias=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=STRING 'as' alias=ID
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//alias=ID
		public Assignment getAliasAssignment_3() { return cAliasAssignment_3; }
		
		//ID
		public RuleCall getAliasIDTerminalRuleCall_3_0() { return cAliasIDTerminalRuleCall_3_0; }
	}
	public class ConfigElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Config");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConfigAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cConfigKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cExpressionsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cExpressionsConfigExpressionParserRuleCall_5_0 = (RuleCall)cExpressionsAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Config:
		//	{Config} 'config' '(' ')' '{'
		//	expressions+=ConfigExpression*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Config} 'config' '(' ')' '{' expressions+=ConfigExpression* '}'
		public Group getGroup() { return cGroup; }
		
		//{Config}
		public Action getConfigAction_0() { return cConfigAction_0; }
		
		//'config'
		public Keyword getConfigKeyword_1() { return cConfigKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//expressions+=ConfigExpression*
		public Assignment getExpressionsAssignment_5() { return cExpressionsAssignment_5; }
		
		//ConfigExpression
		public RuleCall getExpressionsConfigExpressionParserRuleCall_5_0() { return cExpressionsConfigExpressionParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ConfigExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ConfigExpression");
		private final Keyword cTestKeyword = (Keyword)rule.eContents().get(1);
		
		//ConfigExpression:
		//	'test';
		@Override public ParserRule getRule() { return rule; }
		
		//'test'
		public Keyword getTestKeyword() { return cTestKeyword; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPatternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final UnorderedGroup cUnorderedGroup_4 = (UnorderedGroup)cGroup.eContents().get(4);
		private final Assignment cCollsAssignment_4_0 = (Assignment)cUnorderedGroup_4.eContents().get(0);
		private final RuleCall cCollsCollectionParserRuleCall_4_0_0 = (RuleCall)cCollsAssignment_4_0.eContents().get(0);
		private final Assignment cNodesAssignment_4_1 = (Assignment)cUnorderedGroup_4.eContents().get(1);
		private final RuleCall cNodesNodeParserRuleCall_4_1_0 = (RuleCall)cNodesAssignment_4_1.eContents().get(0);
		private final Assignment cParamManipulationsAssignment_4_2 = (Assignment)cUnorderedGroup_4.eContents().get(2);
		private final RuleCall cParamManipulationsParamManipulationParserRuleCall_4_2_0 = (RuleCall)cParamManipulationsAssignment_4_2.eContents().get(0);
		private final Assignment cSwitchesAssignment_4_3 = (Assignment)cUnorderedGroup_4.eContents().get(3);
		private final RuleCall cSwitchesSwitchParserRuleCall_4_3_0 = (RuleCall)cSwitchesAssignment_4_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnPatternReturnParserRuleCall_6_0 = (RuleCall)cReturnAssignment_6.eContents().get(0);
		
		//Pattern:
		//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* &
		//	nodes+=Node* & paramManipulations+=ParamManipulation* & switches+=Switch*) '}'
		//	return=PatternReturn?;
		@Override public ParserRule getRule() { return rule; }
		
		//'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* & nodes+=Node*
		//& paramManipulations+=ParamManipulation* & switches+=Switch*) '}' return=PatternReturn?
		public Group getGroup() { return cGroup; }
		
		//'pattern'
		public Keyword getPatternKeyword_0() { return cPatternKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0_0() { return cParametersParameterParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(colls+=Collection* & nodes+=Node* & paramManipulations+=ParamManipulation* & switches+=Switch*)
		public UnorderedGroup getUnorderedGroup_4() { return cUnorderedGroup_4; }
		
		//colls+=Collection*
		public Assignment getCollsAssignment_4_0() { return cCollsAssignment_4_0; }
		
		//Collection
		public RuleCall getCollsCollectionParserRuleCall_4_0_0() { return cCollsCollectionParserRuleCall_4_0_0; }
		
		//nodes+=Node*
		public Assignment getNodesAssignment_4_1() { return cNodesAssignment_4_1; }
		
		//Node
		public RuleCall getNodesNodeParserRuleCall_4_1_0() { return cNodesNodeParserRuleCall_4_1_0; }
		
		//paramManipulations+=ParamManipulation*
		public Assignment getParamManipulationsAssignment_4_2() { return cParamManipulationsAssignment_4_2; }
		
		//ParamManipulation
		public RuleCall getParamManipulationsParamManipulationParserRuleCall_4_2_0() { return cParamManipulationsParamManipulationParserRuleCall_4_2_0; }
		
		//switches+=Switch*
		public Assignment getSwitchesAssignment_4_3() { return cSwitchesAssignment_4_3; }
		
		//Switch
		public RuleCall getSwitchesSwitchParserRuleCall_4_3_0() { return cSwitchesSwitchParserRuleCall_4_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
		
		//return=PatternReturn?
		public Assignment getReturnAssignment_6() { return cReturnAssignment_6; }
		
		//PatternReturn
		public RuleCall getReturnPatternReturnParserRuleCall_6_0() { return cReturnPatternReturnParserRuleCall_6_0; }
	}
	public class PatternReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternReturn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternReturnAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cThisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cFullStopKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReturnValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cReturnValueNodeCrossReference_3_1_0 = (CrossReference)cReturnValueAssignment_3_1.eContents().get(0);
		private final RuleCall cReturnValueNodeIDTerminalRuleCall_3_1_0_1 = (RuleCall)cReturnValueNodeCrossReference_3_1_0.eContents().get(1);
		
		//PatternReturn:
		//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?
		public Group getGroup() { return cGroup; }
		
		//{PatternReturn}
		public Action getPatternReturnAction_0() { return cPatternReturnAction_0; }
		
		//'return'
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }
		
		//'this'
		public Keyword getThisKeyword_2() { return cThisKeyword_2; }
		
		//('.' returnValue=[Node])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'.'
		public Keyword getFullStopKeyword_3_0() { return cFullStopKeyword_3_0; }
		
		//returnValue=[Node]
		public Assignment getReturnValueAssignment_3_1() { return cReturnValueAssignment_3_1; }
		
		//[Node]
		public CrossReference getReturnValueNodeCrossReference_3_1_0() { return cReturnValueNodeCrossReference_3_1_0; }
		
		//ID
		public RuleCall getReturnValueNodeIDTerminalRuleCall_3_1_0_1() { return cReturnValueNodeIDTerminalRuleCall_3_1_0_1; }
	}
	public class ParamManipulationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParamManipulation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cParamParameterNodeCrossReference_0_0 = (CrossReference)cParamAssignment_0.eContents().get(0);
		private final RuleCall cParamParameterNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cParamParameterNodeCrossReference_0_0.eContents().get(1);
		private final Assignment cContentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContentNodeContentParserRuleCall_1_0 = (RuleCall)cContentAssignment_1.eContents().get(0);
		
		//ParamManipulation:
		//	param=[ParameterNode] content=NodeContent;
		@Override public ParserRule getRule() { return rule; }
		
		//param=[ParameterNode] content=NodeContent
		public Group getGroup() { return cGroup; }
		
		//param=[ParameterNode]
		public Assignment getParamAssignment_0() { return cParamAssignment_0; }
		
		//[ParameterNode]
		public CrossReference getParamParameterNodeCrossReference_0_0() { return cParamParameterNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getParamParameterNodeIDTerminalRuleCall_0_0_1() { return cParamParameterNodeIDTerminalRuleCall_0_0_1; }
		
		//content=NodeContent
		public Assignment getContentAssignment_1() { return cContentAssignment_1; }
		
		//NodeContent
		public RuleCall getContentNodeContentParserRuleCall_1_0() { return cContentNodeContentParserRuleCall_1_0; }
	}
	public class NodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Node");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cCreatedByAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cCreatedByNodeContentParserRuleCall_2_0_0 = (RuleCall)cCreatedByAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cCreatedByAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cCreatedByPatternCallParserRuleCall_2_1_1_0 = (RuleCall)cCreatedByAssignment_2_1_1.eContents().get(0);
		
		//Node:
		//	type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_0_0() { return cTypeEClassCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_0_0_1() { return cTypeEClassIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//createdBy=NodeContent
		public Assignment getCreatedByAssignment_2_0() { return cCreatedByAssignment_2_0; }
		
		//NodeContent
		public RuleCall getCreatedByNodeContentParserRuleCall_2_0_0() { return cCreatedByNodeContentParserRuleCall_2_0_0; }
		
		//ASSIGNMENT_OP createdBy=PatternCall
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_1_0() { return cASSIGNMENT_OPTerminalRuleCall_2_1_0; }
		
		//createdBy=PatternCall
		public Assignment getCreatedByAssignment_2_1_1() { return cCreatedByAssignment_2_1_1; }
		
		//PatternCall
		public RuleCall getCreatedByPatternCallParserRuleCall_2_1_1_0() { return cCreatedByPatternCallParserRuleCall_2_1_1_0; }
	}
	public class NodeContentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeContent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeContentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefsAssignsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefsAssignsNodeReferenceOrAssignmentOrControlFlowParserRuleCall_2_0 = (RuleCall)cRefsAssignsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//NodeContent:
		//	{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignmentOrControlFlow* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignmentOrControlFlow* '}'
		public Group getGroup() { return cGroup; }
		
		//{NodeContent}
		public Action getNodeContentAction_0() { return cNodeContentAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//refsAssigns+=NodeReferenceOrAssignmentOrControlFlow*
		public Assignment getRefsAssignsAssignment_2() { return cRefsAssignsAssignment_2; }
		
		//NodeReferenceOrAssignmentOrControlFlow
		public RuleCall getRefsAssignsNodeReferenceOrAssignmentOrControlFlowParserRuleCall_2_0() { return cRefsAssignsNodeReferenceOrAssignmentOrControlFlowParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class PatternCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledPatternCrossReference_0_0 = (CrossReference)cCalledAssignment_0.eContents().get(0);
		private final RuleCall cCalledPatternIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledPatternCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParamsArithmeticExpressionParserRuleCall_2_0_0 = (RuleCall)cParamsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParamsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParamsArithmeticExpressionParserRuleCall_2_1_1_0 = (RuleCall)cParamsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PatternCall:
		//	called=[Pattern] '(' (params+=ArithmeticExpression (',' params+=ArithmeticExpression)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//called=[Pattern] '(' (params+=ArithmeticExpression (',' params+=ArithmeticExpression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//called=[Pattern]
		public Assignment getCalledAssignment_0() { return cCalledAssignment_0; }
		
		//[Pattern]
		public CrossReference getCalledPatternCrossReference_0_0() { return cCalledPatternCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledPatternIDTerminalRuleCall_0_0_1() { return cCalledPatternIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(params+=ArithmeticExpression (',' params+=ArithmeticExpression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//params+=ArithmeticExpression
		public Assignment getParamsAssignment_2_0() { return cParamsAssignment_2_0; }
		
		//ArithmeticExpression
		public RuleCall getParamsArithmeticExpressionParserRuleCall_2_0_0() { return cParamsArithmeticExpressionParserRuleCall_2_0_0; }
		
		//(',' params+=ArithmeticExpression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//params+=ArithmeticExpression
		public Assignment getParamsAssignment_2_1_1() { return cParamsAssignment_2_1_1; }
		
		//ArithmeticExpression
		public RuleCall getParamsArithmeticExpressionParserRuleCall_2_1_1_0() { return cParamsArithmeticExpressionParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class NodeReferenceOrAssignmentOrControlFlowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeReferenceOrAssignmentOrControlFlow");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPatternNodeReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSwitchParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//NodeReferenceOrAssignmentOrControlFlow:
		//	PatternNodeReference | Assignment | Switch;
		@Override public ParserRule getRule() { return rule; }
		
		//PatternNodeReference | Assignment | Switch
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PatternNodeReference
		public RuleCall getPatternNodeReferenceParserRuleCall_0() { return cPatternNodeReferenceParserRuleCall_0; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }
		
		//Switch
		public RuleCall getSwitchParserRuleCall_2() { return cSwitchParserRuleCall_2; }
	}
	public class PatternNodeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternNodeReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEReferenceCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEReferenceCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTargetNodeCrossReference_2_0 = (CrossReference)cTargetAssignment_2.eContents().get(0);
		private final RuleCall cTargetNodeIDTerminalRuleCall_2_0_1 = (RuleCall)cTargetNodeCrossReference_2_0.eContents().get(1);
		
		//PatternNodeReference:
		//	type=[ecore::EReference] '->' target=[Node];
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EReference] '->' target=[Node]
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_0_0() { return cTypeEReferenceCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_0_0_1() { return cTypeEReferenceIDTerminalRuleCall_0_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//target=[Node]
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }
		
		//[Node]
		public CrossReference getTargetNodeCrossReference_2_0() { return cTargetNodeCrossReference_2_0; }
		
		//ID
		public RuleCall getTargetNodeIDTerminalRuleCall_2_0_1() { return cTargetNodeIDTerminalRuleCall_2_0_1; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTargetAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTargetEAttributeCrossReference_0_0 = (CrossReference)cTargetAssignment_0.eContents().get(0);
		private final RuleCall cTargetEAttributeIDTerminalRuleCall_0_0_1 = (RuleCall)cTargetEAttributeCrossReference_0_0.eContents().get(1);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Assignment:
		//	target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression
		public Group getGroup() { return cGroup; }
		
		//target=[ecore::EAttribute]
		public Assignment getTargetAssignment_0() { return cTargetAssignment_0; }
		
		//[ecore::EAttribute]
		public CrossReference getTargetEAttributeCrossReference_0_0() { return cTargetEAttributeCrossReference_0_0; }
		
		//ID
		public RuleCall getTargetEAttributeIDTerminalRuleCall_0_0_1() { return cTargetEAttributeIDTerminalRuleCall_0_0_1; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//value=ArithmeticExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//ArithmeticExpression
		public RuleCall getValueArithmeticExpressionParserRuleCall_2_0() { return cValueArithmeticExpressionParserRuleCall_2_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Parameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterNodeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////TODO make Enum Assignments possible
		//Parameter:
		//	PrimitiveParameter | ParameterNode;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimitiveParameter | ParameterNode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimitiveParameter
		public RuleCall getPrimitiveParameterParserRuleCall_0() { return cPrimitiveParameterParserRuleCall_0; }
		
		//ParameterNode
		public RuleCall getParameterNodeParserRuleCall_1() { return cParameterNodeParserRuleCall_1; }
	}
	public class PrimitiveParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypePrimitiveTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PrimitiveParameter:
		//	type=PrimitiveType name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=PrimitiveType name=ID
		public Group getGroup() { return cGroup; }
		
		//type=PrimitiveType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//PrimitiveType
		public RuleCall getTypePrimitiveTypeEnumRuleCall_0_0() { return cTypePrimitiveTypeEnumRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ParameterNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ParameterNode:
		//	type=[ecore::EClassifier] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClassifier] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_0_0() { return cTypeEClassifierCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class RefOrCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RefOrCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cRefRefTypeCrossReference_0_0 = (CrossReference)cRefAssignment_0.eContents().get(0);
		private final RuleCall cRefRefTypeIDTerminalRuleCall_0_0_1 = (RuleCall)cRefRefTypeCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRefOrCallTargetAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRefAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cRefETypedElementCrossReference_1_2_0 = (CrossReference)cRefAssignment_1_2.eContents().get(0);
		private final RuleCall cRefETypedElementIDTerminalRuleCall_1_2_0_1 = (RuleCall)cRefETypedElementCrossReference_1_2_0.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Assignment cParamsAssignment_1_3_1 = (Assignment)cGroup_1_3.eContents().get(1);
		private final RuleCall cParamsRefParamsParserRuleCall_1_3_1_0 = (RuleCall)cParamsAssignment_1_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3_2 = (Keyword)cGroup_1_3.eContents().get(2);
		
		//RefOrCall:
		//	ref=[RefType] ({RefOrCall.target=current} '.' ref=[ecore::ETypedElement] ('(' params=RefParams? ')')?)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ref=[RefType] ({RefOrCall.target=current} '.' ref=[ecore::ETypedElement] ('(' params=RefParams? ')')?)*
		public Group getGroup() { return cGroup; }
		
		//ref=[RefType]
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//[RefType]
		public CrossReference getRefRefTypeCrossReference_0_0() { return cRefRefTypeCrossReference_0_0; }
		
		//ID
		public RuleCall getRefRefTypeIDTerminalRuleCall_0_0_1() { return cRefRefTypeIDTerminalRuleCall_0_0_1; }
		
		//({RefOrCall.target=current} '.' ref=[ecore::ETypedElement] ('(' params=RefParams? ')')?)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{RefOrCall.target=current}
		public Action getRefOrCallTargetAction_1_0() { return cRefOrCallTargetAction_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }
		
		//ref=[ecore::ETypedElement]
		public Assignment getRefAssignment_1_2() { return cRefAssignment_1_2; }
		
		//[ecore::ETypedElement]
		public CrossReference getRefETypedElementCrossReference_1_2_0() { return cRefETypedElementCrossReference_1_2_0; }
		
		//ID
		public RuleCall getRefETypedElementIDTerminalRuleCall_1_2_0_1() { return cRefETypedElementIDTerminalRuleCall_1_2_0_1; }
		
		//('(' params=RefParams? ')')?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_3_0() { return cLeftParenthesisKeyword_1_3_0; }
		
		//params=RefParams?
		public Assignment getParamsAssignment_1_3_1() { return cParamsAssignment_1_3_1; }
		
		//RefParams
		public RuleCall getParamsRefParamsParserRuleCall_1_3_1_0() { return cParamsRefParamsParserRuleCall_1_3_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3_2() { return cRightParenthesisKeyword_1_3_2; }
	}
	public class RefParamsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RefParams");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cParamsArithmeticExpressionParserRuleCall_0_0 = (RuleCall)cParamsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cParamsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cParamsArithmeticExpressionParserRuleCall_1_1_0 = (RuleCall)cParamsAssignment_1_1.eContents().get(0);
		
		////TODO: Map and List Operations
		//RefParams:
		//	params+=ArithmeticExpression (',' params+=ArithmeticExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		////	ArithmeticExpression ({RefParams.last=current} ',' next=ArithmeticExpression)*;
		//params+=ArithmeticExpression (',' params+=ArithmeticExpression)*
		public Group getGroup() { return cGroup; }
		
		////	ArithmeticExpression ({RefParams.last=current} ',' next=ArithmeticExpression)*;
		//params+=ArithmeticExpression
		public Assignment getParamsAssignment_0() { return cParamsAssignment_0; }
		
		//ArithmeticExpression
		public RuleCall getParamsArithmeticExpressionParserRuleCall_0_0() { return cParamsArithmeticExpressionParserRuleCall_0_0; }
		
		//(',' params+=ArithmeticExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//params+=ArithmeticExpression
		public Assignment getParamsAssignment_1_1() { return cParamsAssignment_1_1; }
		
		//ArithmeticExpression
		public RuleCall getParamsArithmeticExpressionParserRuleCall_1_1_0() { return cParamsArithmeticExpressionParserRuleCall_1_1_0; }
	}
	public class GeneratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Generator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGeneratorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamsParameterParserRuleCall_3_0 = (RuleCall)cParamsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCommandsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCommandsGeneratorExpressionParserRuleCall_6_0 = (RuleCall)cCommandsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Generator:
		//	{Generator} 'gen' '(' params+=Parameter* ')' '{' commands+=GeneratorExpression* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Generator} 'gen' '(' params+=Parameter* ')' '{' commands+=GeneratorExpression* '}'
		public Group getGroup() { return cGroup; }
		
		//{Generator}
		public Action getGeneratorAction_0() { return cGeneratorAction_0; }
		
		//'gen'
		public Keyword getGenKeyword_1() { return cGenKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//params+=Parameter*
		public Assignment getParamsAssignment_3() { return cParamsAssignment_3; }
		
		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_0() { return cParamsParameterParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//commands+=GeneratorExpression*
		public Assignment getCommandsAssignment_6() { return cCommandsAssignment_6; }
		
		//GeneratorExpression
		public RuleCall getCommandsGeneratorExpressionParserRuleCall_6_0() { return cCommandsGeneratorExpressionParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class GeneratorExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSwitchParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPatternCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPatternObjectCreationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//GeneratorExpression:
		//	ForStatement | Switch | Collection | PatternCall | PatternObjectCreation;
		@Override public ParserRule getRule() { return rule; }
		
		////Only serves as super class for all possible commands within generator
		//ForStatement | Switch | Collection | PatternCall | PatternObjectCreation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////Only serves as super class for all possible commands within generator
		//ForStatement
		public RuleCall getForStatementParserRuleCall_0() { return cForStatementParserRuleCall_0; }
		
		//Switch
		public RuleCall getSwitchParserRuleCall_1() { return cSwitchParserRuleCall_1; }
		
		//Collection
		public RuleCall getCollectionParserRuleCall_2() { return cCollectionParserRuleCall_2; }
		
		//PatternCall
		public RuleCall getPatternCallParserRuleCall_3() { return cPatternCallParserRuleCall_3; }
		
		//PatternObjectCreation
		public RuleCall getPatternObjectCreationParserRuleCall_4() { return cPatternObjectCreationParserRuleCall_4; }
	}
	public class PatternObjectCreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObjectCreation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPObjectAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPObjectPatternObjectParserRuleCall_0_0 = (RuleCall)cPObjectAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cPatternCallAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternCallPatternCallParserRuleCall_2_0 = (RuleCall)cPatternCallAssignment_2.eContents().get(0);
		
		//PatternObjectCreation:
		//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
		@Override public ParserRule getRule() { return rule; }
		
		//pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall
		public Group getGroup() { return cGroup; }
		
		//pObject=PatternObject
		public Assignment getPObjectAssignment_0() { return cPObjectAssignment_0; }
		
		//PatternObject
		public RuleCall getPObjectPatternObjectParserRuleCall_0_0() { return cPObjectPatternObjectParserRuleCall_0_0; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//patternCall=PatternCall
		public Assignment getPatternCallAssignment_2() { return cPatternCallAssignment_2; }
		
		//PatternCall
		public RuleCall getPatternCallPatternCallParserRuleCall_2_0() { return cPatternCallPatternCallParserRuleCall_2_0; }
	}
	public class PatternObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypePatternCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypePatternIDTerminalRuleCall_0_0_1 = (RuleCall)cTypePatternCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PatternObject:
		//	type=[Pattern] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Pattern] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[Pattern]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Pattern]
		public CrossReference getTypePatternCrossReference_0_0() { return cTypePatternCrossReference_0_0; }
		
		//ID
		public RuleCall getTypePatternIDTerminalRuleCall_0_0_1() { return cTypePatternIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadForHeadParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyForBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ForStatement:
		//	'for' head=ForHead '{' body=ForBody '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'for' head=ForHead '{' body=ForBody '}'
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//head=ForHead
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//ForHead
		public RuleCall getHeadForHeadParserRuleCall_1_0() { return cHeadForHeadParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//body=ForBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//ForBody
		public RuleCall getBodyForBodyParserRuleCall_3_0() { return cBodyForBodyParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class ForHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForHead");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGeneralForHeadParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForEachHeadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ForHead:
		//	GeneralForHead | ForEachHead;
		@Override public ParserRule getRule() { return rule; }
		
		//GeneralForHead | ForEachHead
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GeneralForHead
		public RuleCall getGeneralForHeadParserRuleCall_0() { return cGeneralForHeadParserRuleCall_0; }
		
		//ForEachHead
		public RuleCall getForEachHeadParserRuleCall_1() { return cForEachHeadParserRuleCall_1; }
	}
	public class GeneralForHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneralForHead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIteratorVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIteratorVarIDTerminalRuleCall_0_0 = (RuleCall)cIteratorVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRangeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRangeForRangeParserRuleCall_2_0 = (RuleCall)cRangeAssignment_2.eContents().get(0);
		
		//GeneralForHead:
		//	iteratorVar=ID 'in' range=ForRange;
		@Override public ParserRule getRule() { return rule; }
		
		//iteratorVar=ID 'in' range=ForRange
		public Group getGroup() { return cGroup; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_0() { return cIteratorVarAssignment_0; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_0_0() { return cIteratorVarIDTerminalRuleCall_0_0; }
		
		//'in'
		public Keyword getInKeyword_1() { return cInKeyword_1; }
		
		//range=ForRange
		public Assignment getRangeAssignment_2() { return cRangeAssignment_2; }
		
		//ForRange
		public RuleCall getRangeForRangeParserRuleCall_2_0() { return cRangeForRangeParserRuleCall_2_0; }
	}
	public class ForEachHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForEachHead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSrcAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSrcRefOrCallParserRuleCall_0_0 = (RuleCall)cSrcAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cErefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cErefEReferenceCrossReference_2_0 = (CrossReference)cErefAssignment_2.eContents().get(0);
		private final RuleCall cErefEReferenceIDTerminalRuleCall_2_0_1 = (RuleCall)cErefEReferenceCrossReference_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIteratorVarAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIteratorVarIDTerminalRuleCall_4_0 = (RuleCall)cIteratorVarAssignment_4.eContents().get(0);
		
		//ForEachHead:
		//	src=RefOrCall '-' eref=[ecore::EReference] '->' iteratorVar=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//src=RefOrCall '-' eref=[ecore::EReference] '->' iteratorVar=ID
		public Group getGroup() { return cGroup; }
		
		//src=RefOrCall
		public Assignment getSrcAssignment_0() { return cSrcAssignment_0; }
		
		//RefOrCall
		public RuleCall getSrcRefOrCallParserRuleCall_0_0() { return cSrcRefOrCallParserRuleCall_0_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//eref=[ecore::EReference]
		public Assignment getErefAssignment_2() { return cErefAssignment_2; }
		
		//[ecore::EReference]
		public CrossReference getErefEReferenceCrossReference_2_0() { return cErefEReferenceCrossReference_2_0; }
		
		//ID
		public RuleCall getErefEReferenceIDTerminalRuleCall_2_0_1() { return cErefEReferenceIDTerminalRuleCall_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_4() { return cIteratorVarAssignment_4; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_4_0() { return cIteratorVarIDTerminalRuleCall_4_0; }
	}
	public class RefTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RefType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//RefType:
		//	Node | Parameter | Collection;
		@Override public ParserRule getRule() { return rule; }
		
		//Node | Parameter | Collection
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Node
		public RuleCall getNodeParserRuleCall_0() { return cNodeParserRuleCall_0; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }
		
		//Collection
		public RuleCall getCollectionParserRuleCall_2() { return cCollectionParserRuleCall_2; }
	}
	public class ForBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommandsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandsGeneratorExpressionParserRuleCall_1_0 = (RuleCall)cCommandsAssignment_1.eContents().get(0);
		
		//ForBody:
		//	{ForBody} commands+=GeneratorExpression*;
		@Override public ParserRule getRule() { return rule; }
		
		//{ForBody} commands+=GeneratorExpression*
		public Group getGroup() { return cGroup; }
		
		//{ForBody}
		public Action getForBodyAction_0() { return cForBodyAction_0; }
		
		//commands+=GeneratorExpression*
		public Assignment getCommandsAssignment_1() { return cCommandsAssignment_1; }
		
		//GeneratorExpression
		public RuleCall getCommandsGeneratorExpressionParserRuleCall_1_0() { return cCommandsGeneratorExpressionParserRuleCall_1_0; }
	}
	public class SwitchExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SwitchExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCollectionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPatternCallParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPatternObjectCreationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNodeReferenceOrAssignmentOrControlFlowParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//SwitchExpression:
		//	ForStatement | Collection | PatternCall | PatternObjectCreation | NodeReferenceOrAssignmentOrControlFlow;
		@Override public ParserRule getRule() { return rule; }
		
		//ForStatement | Collection | PatternCall | PatternObjectCreation | NodeReferenceOrAssignmentOrControlFlow
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ForStatement
		public RuleCall getForStatementParserRuleCall_0() { return cForStatementParserRuleCall_0; }
		
		//Collection
		public RuleCall getCollectionParserRuleCall_1() { return cCollectionParserRuleCall_1; }
		
		//PatternCall
		public RuleCall getPatternCallParserRuleCall_2() { return cPatternCallParserRuleCall_2; }
		
		//PatternObjectCreation
		public RuleCall getPatternObjectCreationParserRuleCall_3() { return cPatternObjectCreationParserRuleCall_3; }
		
		//NodeReferenceOrAssignmentOrControlFlow
		public RuleCall getNodeReferenceOrAssignmentOrControlFlowParserRuleCall_4() { return cNodeReferenceOrAssignmentOrControlFlowParserRuleCall_4; }
	}
	public class SwitchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Switch");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfElseSwitchParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSwitchCaseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Switch:
		//	IfElseSwitch | SwitchCase;
		@Override public ParserRule getRule() { return rule; }
		
		//IfElseSwitch | SwitchCase
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfElseSwitch
		public RuleCall getIfElseSwitchParserRuleCall_0() { return cIfElseSwitchParserRuleCall_0; }
		
		//SwitchCase
		public RuleCall getSwitchCaseParserRuleCall_1() { return cSwitchCaseParserRuleCall_1; }
	}
	public class IfElseSwitchElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfElseSwitch");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCasesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCasesIfElseCaseParserRuleCall_2_0 = (RuleCall)cCasesAssignment_2.eContents().get(0);
		private final Assignment cDefaultAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDefaultDefaultParserRuleCall_3_0 = (RuleCall)cDefaultAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//IfElseSwitch:
		//	'switch' '{' cases+=IfElseCase+ default=Default? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'switch' '{' cases+=IfElseCase+ default=Default? '}'
		public Group getGroup() { return cGroup; }
		
		//'switch'
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//cases+=IfElseCase+
		public Assignment getCasesAssignment_2() { return cCasesAssignment_2; }
		
		//IfElseCase
		public RuleCall getCasesIfElseCaseParserRuleCall_2_0() { return cCasesIfElseCaseParserRuleCall_2_0; }
		
		//default=Default?
		public Assignment getDefaultAssignment_3() { return cDefaultAssignment_3; }
		
		//Default
		public RuleCall getDefaultDefaultParserRuleCall_3_0() { return cDefaultDefaultParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class IfElseCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfElseCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cValAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyCaseBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//IfElseCase:
		//	'case' val=ArithmeticExpression ':' body=CaseBody;
		@Override public ParserRule getRule() { return rule; }
		
		//'case' val=ArithmeticExpression ':' body=CaseBody
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//val=ArithmeticExpression
		public Assignment getValAssignment_1() { return cValAssignment_1; }
		
		//ArithmeticExpression
		public RuleCall getValArithmeticExpressionParserRuleCall_1_0() { return cValArithmeticExpressionParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//body=CaseBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//CaseBody
		public RuleCall getBodyCaseBodyParserRuleCall_3_0() { return cBodyCaseBodyParserRuleCall_3_0; }
	}
	public class DefaultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Default");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cCaseBodyParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Default:
		//	'default' ':' CaseBody;
		@Override public ParserRule getRule() { return rule; }
		
		//'default' ':' CaseBody
		public Group getGroup() { return cGroup; }
		
		//'default'
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//CaseBody
		public RuleCall getCaseBodyParserRuleCall_2() { return cCaseBodyParserRuleCall_2; }
	}
	public class SwitchCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SwitchCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeRefOrCallParserRuleCall_2_0 = (RuleCall)cAttributeAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCasesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCasesCaseParserRuleCall_5_0 = (RuleCall)cCasesAssignment_5.eContents().get(0);
		private final Assignment cDefaultAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDefaultDefaultParserRuleCall_6_0 = (RuleCall)cDefaultAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//SwitchCase:
		//	'switch' '(' attribute=RefOrCall ')' '{' cases+=Case+ default=Default? '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'switch' '(' attribute=RefOrCall ')' '{' cases+=Case+ default=Default? '}'
		public Group getGroup() { return cGroup; }
		
		//'switch'
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//attribute=RefOrCall
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//RefOrCall
		public RuleCall getAttributeRefOrCallParserRuleCall_2_0() { return cAttributeRefOrCallParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//cases+=Case+
		public Assignment getCasesAssignment_5() { return cCasesAssignment_5; }
		
		//Case
		public RuleCall getCasesCaseParserRuleCall_5_0() { return cCasesCaseParserRuleCall_5_0; }
		
		//default=Default?
		public Assignment getDefaultAssignment_6() { return cDefaultAssignment_6; }
		
		//Default
		public RuleCall getDefaultDefaultParserRuleCall_6_0() { return cDefaultDefaultParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Case");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCaseWithCastParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCaseWithoutCastParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Case:
		//	CaseWithCast | CaseWithoutCast;
		@Override public ParserRule getRule() { return rule; }
		
		//CaseWithCast | CaseWithoutCast
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CaseWithCast
		public RuleCall getCaseWithCastParserRuleCall_0() { return cCaseWithCastParserRuleCall_0; }
		
		//CaseWithoutCast
		public RuleCall getCaseWithoutCastParserRuleCall_1() { return cCaseWithoutCastParserRuleCall_1; }
	}
	public class CaseWithCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.CaseWithCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNodeNodeParserRuleCall_1_0 = (RuleCall)cNodeAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cWhenKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cWhenAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cWhenArithmeticExpressionParserRuleCall_2_1_0 = (RuleCall)cWhenAssignment_2_1.eContents().get(0);
		private final Keyword cColonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyCaseBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//CaseWithCast: // TODO: Check that arithmetic expression really yields boolean value
		//	'case' node=Node ('when' when=ArithmeticExpression)? ':' body=CaseBody;
		@Override public ParserRule getRule() { return rule; }
		
		//// TODO: Check that arithmetic expression really yields boolean value
		//'case' node=Node ('when' when=ArithmeticExpression)? ':' body=CaseBody
		public Group getGroup() { return cGroup; }
		
		//// TODO: Check that arithmetic expression really yields boolean value
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//node=Node
		public Assignment getNodeAssignment_1() { return cNodeAssignment_1; }
		
		//Node
		public RuleCall getNodeNodeParserRuleCall_1_0() { return cNodeNodeParserRuleCall_1_0; }
		
		//('when' when=ArithmeticExpression)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'when'
		public Keyword getWhenKeyword_2_0() { return cWhenKeyword_2_0; }
		
		//when=ArithmeticExpression
		public Assignment getWhenAssignment_2_1() { return cWhenAssignment_2_1; }
		
		//ArithmeticExpression
		public RuleCall getWhenArithmeticExpressionParserRuleCall_2_1_0() { return cWhenArithmeticExpressionParserRuleCall_2_1_0; }
		
		//':'
		public Keyword getColonKeyword_3() { return cColonKeyword_3; }
		
		//body=CaseBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }
		
		//CaseBody
		public RuleCall getBodyCaseBodyParserRuleCall_4_0() { return cBodyCaseBodyParserRuleCall_4_0; }
	}
	public class CaseWithoutCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.CaseWithoutCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cValAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyCaseBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//CaseWithoutCast:
		//	'case' val=ArithmeticExpression ':' body=CaseBody;
		@Override public ParserRule getRule() { return rule; }
		
		//'case' val=ArithmeticExpression ':' body=CaseBody
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//val=ArithmeticExpression
		public Assignment getValAssignment_1() { return cValAssignment_1; }
		
		//ArithmeticExpression
		public RuleCall getValArithmeticExpressionParserRuleCall_1_0() { return cValArithmeticExpressionParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//body=CaseBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//CaseBody
		public RuleCall getBodyCaseBodyParserRuleCall_3_0() { return cBodyCaseBodyParserRuleCall_3_0; }
	}
	public class CaseBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.CaseBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cCaseBodyAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExpressionsAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionsSwitchExpressionParserRuleCall_0_2_0 = (RuleCall)cExpressionsAssignment_0_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cExpressionsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionsSwitchExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionsAssignment_1_0.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//CaseBody:
		//	{CaseBody} '{' expressions+=SwitchExpression* '}' | expressions+=SwitchExpression NEWLINE;
		@Override public ParserRule getRule() { return rule; }
		
		//{CaseBody} '{' expressions+=SwitchExpression* '}' | expressions+=SwitchExpression NEWLINE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{CaseBody} '{' expressions+=SwitchExpression* '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//{CaseBody}
		public Action getCaseBodyAction_0_0() { return cCaseBodyAction_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_1() { return cLeftCurlyBracketKeyword_0_1; }
		
		//expressions+=SwitchExpression*
		public Assignment getExpressionsAssignment_0_2() { return cExpressionsAssignment_0_2; }
		
		//SwitchExpression
		public RuleCall getExpressionsSwitchExpressionParserRuleCall_0_2_0() { return cExpressionsSwitchExpressionParserRuleCall_0_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_3() { return cRightCurlyBracketKeyword_0_3; }
		
		//expressions+=SwitchExpression NEWLINE
		public Group getGroup_1() { return cGroup_1; }
		
		//expressions+=SwitchExpression
		public Assignment getExpressionsAssignment_1_0() { return cExpressionsAssignment_1_0; }
		
		//SwitchExpression
		public RuleCall getExpressionsSwitchExpressionParserRuleCall_1_0_0() { return cExpressionsSwitchExpressionParserRuleCall_1_0_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_1_1() { return cNEWLINETerminalRuleCall_1_1; }
	}
	public class CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Collection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cListParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMapParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Collection:
		//	List | Map;
		@Override public ParserRule getRule() { return rule; }
		
		//List | Map
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//List
		public RuleCall getListParserRuleCall_0() { return cListParserRuleCall_0; }
		
		//Map
		public RuleCall getMapParserRuleCall_1() { return cMapParserRuleCall_1; }
	}
	public class ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cCreatedByAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCreatedByListAssignmentParserRuleCall_2_1_0 = (RuleCall)cCreatedByAssignment_2_1.eContents().get(0);
		
		//List:
		//	'List' name=ID (ASSIGNMENT_OP createdBy=ListAssignment)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'List' name=ID (ASSIGNMENT_OP createdBy=ListAssignment)?
		public Group getGroup() { return cGroup; }
		
		//'List'
		public Keyword getListKeyword_0() { return cListKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(ASSIGNMENT_OP createdBy=ListAssignment)?
		public Group getGroup_2() { return cGroup_2; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_0() { return cASSIGNMENT_OPTerminalRuleCall_2_0; }
		
		//createdBy=ListAssignment
		public Assignment getCreatedByAssignment_2_1() { return cCreatedByAssignment_2_1; }
		
		//ListAssignment
		public RuleCall getCreatedByListAssignmentParserRuleCall_2_1_0() { return cCreatedByListAssignmentParserRuleCall_2_1_0; }
	}
	public class ListAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ListAssignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cListAdHocParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRefOrCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ListAssignment:
		//	ListAdHoc | RefOrCall;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Returns List?
		//ListAdHoc | RefOrCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO Returns List?
		//ListAdHoc
		public RuleCall getListAdHocParserRuleCall_0() { return cListAdHocParserRuleCall_0; }
		
		//RefOrCall
		public RuleCall getRefOrCallParserRuleCall_1() { return cRefOrCallParserRuleCall_1; }
	}
	public class ListAdHocElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ListAdHoc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsLiteralParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsLiteralParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListAdHoc: //TODO Returns List?
		//	'[' elements+=Literal (',' elements+=Literal)* ']' //TODO Allow empty lists? --> Probably have no purpose here since one will not be able to manipulate them, right?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Returns List?
		//'[' elements+=Literal (',' elements+=Literal)* ']'
		public Group getGroup() { return cGroup; }
		
		////TODO Returns List?
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//elements+=Literal
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }
		
		//Literal
		public RuleCall getElementsLiteralParserRuleCall_1_0() { return cElementsLiteralParserRuleCall_1_0; }
		
		//(',' elements+=Literal)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//elements+=Literal
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }
		
		//Literal
		public RuleCall getElementsLiteralParserRuleCall_2_1_0() { return cElementsLiteralParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Map");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMapKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cCreatedByAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCreatedByMapAssignmentParserRuleCall_2_1_0 = (RuleCall)cCreatedByAssignment_2_1.eContents().get(0);
		
		//Map:
		//	'Map' name=ID (ASSIGNMENT_OP createdBy=MapAssignment)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'Map' name=ID (ASSIGNMENT_OP createdBy=MapAssignment)?
		public Group getGroup() { return cGroup; }
		
		//'Map'
		public Keyword getMapKeyword_0() { return cMapKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(ASSIGNMENT_OP createdBy=MapAssignment)?
		public Group getGroup_2() { return cGroup_2; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_0() { return cASSIGNMENT_OPTerminalRuleCall_2_0; }
		
		//createdBy=MapAssignment
		public Assignment getCreatedByAssignment_2_1() { return cCreatedByAssignment_2_1; }
		
		//MapAssignment
		public RuleCall getCreatedByMapAssignmentParserRuleCall_2_1_0() { return cCreatedByMapAssignmentParserRuleCall_2_1_0; }
	}
	public class MapAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MapAssignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMapAdHocParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRefOrCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MapAssignment:
		//	MapAdHoc | RefOrCall;
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Returns Map?
		//MapAdHoc | RefOrCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////TODO Returns Map?
		//MapAdHoc
		public RuleCall getMapAdHocParserRuleCall_0() { return cMapAdHocParserRuleCall_0; }
		
		//RefOrCall
		public RuleCall getRefOrCallParserRuleCall_1() { return cRefOrCallParserRuleCall_1; }
	}
	public class MapAdHocElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MapAdHoc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEntriesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntriesMapTupelParserRuleCall_1_0 = (RuleCall)cEntriesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEntriesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEntriesMapTupelParserRuleCall_2_1_0 = (RuleCall)cEntriesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MapAdHoc: //TODO Returns Map?
		//	'[' entries+=MapTupel (',' entries+=MapTupel)* ']';
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Returns Map?
		//'[' entries+=MapTupel (',' entries+=MapTupel)* ']'
		public Group getGroup() { return cGroup; }
		
		////TODO Returns Map?
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//entries+=MapTupel
		public Assignment getEntriesAssignment_1() { return cEntriesAssignment_1; }
		
		//MapTupel
		public RuleCall getEntriesMapTupelParserRuleCall_1_0() { return cEntriesMapTupelParserRuleCall_1_0; }
		
		//(',' entries+=MapTupel)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//entries+=MapTupel
		public Assignment getEntriesAssignment_2_1() { return cEntriesAssignment_2_1; }
		
		//MapTupel
		public RuleCall getEntriesMapTupelParserRuleCall_2_1_0() { return cEntriesMapTupelParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapTupelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MapTupel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyLiteralParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueArithmeticExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MapTupel:
		//	'(' key=Literal ',' value=ArithmeticExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' key=Literal ',' value=ArithmeticExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//key=Literal
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }
		
		//Literal
		public RuleCall getKeyLiteralParserRuleCall_1_0() { return cKeyLiteralParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//value=ArithmeticExpression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//ArithmeticExpression
		public RuleCall getValueArithmeticExpressionParserRuleCall_3_0() { return cValueArithmeticExpressionParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ForRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForRange");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartArithmeticExpressionParserRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//ForRange:
		//	start=ArithmeticExpression ':' end=ArithmeticExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//start=ArithmeticExpression ':' end=ArithmeticExpression
		public Group getGroup() { return cGroup; }
		
		//start=ArithmeticExpression
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//ArithmeticExpression
		public RuleCall getStartArithmeticExpressionParserRuleCall_0_0() { return cStartArithmeticExpressionParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//end=ArithmeticExpression
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//ArithmeticExpression
		public RuleCall getEndArithmeticExpressionParserRuleCall_2_0() { return cEndArithmeticExpressionParserRuleCall_2_0; }
	}
	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ArithmeticExpression");
		private final RuleCall cTertiaryExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////======================================Arithmetics============================================
		//ArithmeticExpression:
		//	TertiaryExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//TertiaryExpression
		public RuleCall getTertiaryExpressionParserRuleCall() { return cTertiaryExpressionParserRuleCall; }
	}
	public class TertiaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TertiaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSecondaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTertiaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpTertiaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSecondaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//TertiaryExpression ArithmeticExpression:
		//	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//SecondaryExpression
		public RuleCall getSecondaryExpressionParserRuleCall_0() { return cSecondaryExpressionParserRuleCall_0; }
		
		//({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Tertiary.left=current}
		public Action getTertiaryLeftAction_1_0() { return cTertiaryLeftAction_1_0; }
		
		//op=TertiaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//TertiaryOp
		public RuleCall getOpTertiaryOpEnumRuleCall_1_1_0() { return cOpTertiaryOpEnumRuleCall_1_1_0; }
		
		//right=SecondaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//SecondaryExpression
		public RuleCall getRightSecondaryExpressionParserRuleCall_1_2_0() { return cRightSecondaryExpressionParserRuleCall_1_2_0; }
	}
	public class SecondaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SecondaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSecondaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSecondaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SecondaryExpression ArithmeticExpression:
		//	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpr
		public RuleCall getPrimaryExprParserRuleCall_0() { return cPrimaryExprParserRuleCall_0; }
		
		//({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Secondary.left=current}
		public Action getSecondaryLeftAction_1_0() { return cSecondaryLeftAction_1_0; }
		
		//op=SecondaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//SecondaryOp
		public RuleCall getOpSecondaryOpEnumRuleCall_1_1_0() { return cOpSecondaryOpEnumRuleCall_1_1_0; }
		
		//right=PrimaryExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PrimaryExpr
		public RuleCall getRightPrimaryExprParserRuleCall_1_2_0() { return cRightPrimaryExprParserRuleCall_1_2_0; }
	}
	public class PrimaryExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimaryExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPrimaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPrimaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PrimaryExpr ArithmeticExpression:
		//	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationExpression
		public RuleCall getRelationExpressionParserRuleCall_0() { return cRelationExpressionParserRuleCall_0; }
		
		//({Primary.left=current} op=PrimaryOp right=RelationExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Primary.left=current}
		public Action getPrimaryLeftAction_1_0() { return cPrimaryLeftAction_1_0; }
		
		//op=PrimaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//PrimaryOp
		public RuleCall getOpPrimaryOpEnumRuleCall_1_1_0() { return cOpPrimaryOpEnumRuleCall_1_1_0; }
		
		//right=RelationExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RelationExpression
		public RuleCall getRightRelationExpressionParserRuleCall_1_2_0() { return cRightRelationExpressionParserRuleCall_1_2_0; }
	}
	public class RelationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cRelationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRelationRelationalOpEnumRuleCall_1_1_0 = (RuleCall)cRelationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBaseExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelationExpression ArithmeticExpression:
		//	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*
		public Group getGroup() { return cGroup; }
		
		//BaseExpr
		public RuleCall getBaseExprParserRuleCall_0() { return cBaseExprParserRuleCall_0; }
		
		//({Rel.left=current} relation=RelationalOp right=BaseExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Rel.left=current}
		public Action getRelLeftAction_1_0() { return cRelLeftAction_1_0; }
		
		//relation=RelationalOp
		public Assignment getRelationAssignment_1_1() { return cRelationAssignment_1_1; }
		
		//RelationalOp
		public RuleCall getRelationRelationalOpEnumRuleCall_1_1_0() { return cRelationRelationalOpEnumRuleCall_1_1_0; }
		
		//right=BaseExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BaseExpr
		public RuleCall getRightBaseExprParserRuleCall_1_2_0() { return cRightBaseExprParserRuleCall_1_2_0; }
	}
	public class BaseExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BaseExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cArithmeticExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNegationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprBaseExprParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cFunctionCallAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cFuncAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFuncMathFuncEnumRuleCall_2_1_0 = (RuleCall)cFuncAssignment_2_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cExprAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cExprArithmeticExpressionParserRuleCall_2_3_0 = (RuleCall)cExprAssignment_2_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final RuleCall cLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cRefOrCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//BaseExpr ArithmeticExpression:
		//	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
		//	expr=ArithmeticExpression ')' | Literal | RefOrCall;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
		//expr=ArithmeticExpression ')' | Literal | RefOrCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' ArithmeticExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0_1() { return cArithmeticExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{NegationExpression} '!' expr=BaseExpr
		public Group getGroup_1() { return cGroup_1; }
		
		//{NegationExpression}
		public Action getNegationExpressionAction_1_0() { return cNegationExpressionAction_1_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }
		
		//expr=BaseExpr
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }
		
		//BaseExpr
		public RuleCall getExprBaseExprParserRuleCall_1_2_0() { return cExprBaseExprParserRuleCall_1_2_0; }
		
		//{FunctionCall} func=MathFunc '(' expr=ArithmeticExpression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//{FunctionCall}
		public Action getFunctionCallAction_2_0() { return cFunctionCallAction_2_0; }
		
		//func=MathFunc
		public Assignment getFuncAssignment_2_1() { return cFuncAssignment_2_1; }
		
		//MathFunc
		public RuleCall getFuncMathFuncEnumRuleCall_2_1_0() { return cFuncMathFuncEnumRuleCall_2_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_2() { return cLeftParenthesisKeyword_2_2; }
		
		//expr=ArithmeticExpression
		public Assignment getExprAssignment_2_3() { return cExprAssignment_2_3; }
		
		//ArithmeticExpression
		public RuleCall getExprArithmeticExpressionParserRuleCall_2_3_0() { return cExprArithmeticExpressionParserRuleCall_2_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_4() { return cRightParenthesisKeyword_2_4; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_3() { return cLiteralParserRuleCall_3; }
		
		//RefOrCall
		public RuleCall getRefOrCallParserRuleCall_4() { return cRefOrCallParserRuleCall_4; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal:
		//	BooleanLiteral | StringLiteral | NumberLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanLiteral | StringLiteral | NumberLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_1() { return cStringLiteralParserRuleCall_1; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_2() { return cNumberLiteralParserRuleCall_2; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValAlternatives_0 = (Alternatives)cValAssignment.eContents().get(0);
		private final RuleCall cValTRUETerminalRuleCall_0_0 = (RuleCall)cValAlternatives_0.eContents().get(0);
		private final RuleCall cValFALSETerminalRuleCall_0_1 = (RuleCall)cValAlternatives_0.eContents().get(1);
		
		//BooleanLiteral:
		//	val=(TRUE | FALSE);
		@Override public ParserRule getRule() { return rule; }
		
		//val=(TRUE | FALSE)
		public Assignment getValAssignment() { return cValAssignment; }
		
		//(TRUE | FALSE)
		public Alternatives getValAlternatives_0() { return cValAlternatives_0; }
		
		//TRUE
		public RuleCall getValTRUETerminalRuleCall_0_0() { return cValTRUETerminalRuleCall_0_0; }
		
		//FALSE
		public RuleCall getValFALSETerminalRuleCall_0_1() { return cValFALSETerminalRuleCall_0_1; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.StringLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValSTRINGTerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//StringLiteral:
		//	val=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//val=STRING
		public Assignment getValAssignment() { return cValAssignment; }
		
		//STRING
		public RuleCall getValSTRINGTerminalRuleCall_0() { return cValSTRINGTerminalRuleCall_0; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NumberLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValDOUBLETerminalRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//NumberLiteral:
		//	val=DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//val=DOUBLE
		public Assignment getValAssignment() { return cValAssignment; }
		
		//DOUBLE
		public RuleCall getValDOUBLETerminalRuleCall_0() { return cValDOUBLETerminalRuleCall_0; }
	}
	
	public class MathFuncElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MathFunc");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSQRTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSQRTSqrtKeyword_0_0 = (Keyword)cSQRTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cABSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cABSAbsKeyword_1_0 = (Keyword)cABSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MathFunc:
		//	SQRT='sqrt' | ABS='abs';
		public EnumRule getRule() { return rule; }
		
		//SQRT='sqrt' | ABS='abs'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SQRT='sqrt'
		public EnumLiteralDeclaration getSQRTEnumLiteralDeclaration_0() { return cSQRTEnumLiteralDeclaration_0; }
		
		//'sqrt'
		public Keyword getSQRTSqrtKeyword_0_0() { return cSQRTSqrtKeyword_0_0; }
		
		//ABS='abs'
		public EnumLiteralDeclaration getABSEnumLiteralDeclaration_1() { return cABSEnumLiteralDeclaration_1; }
		
		//'abs'
		public Keyword getABSAbsKeyword_1_0() { return cABSAbsKeyword_1_0; }
	}
	public class PrimitiveTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINTIntKeyword_0_0 = (Keyword)cINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCHAREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCHARCharKeyword_1_0 = (Keyword)cCHAREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDOUBLEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDOUBLEDoubleKeyword_2_0 = (Keyword)cDOUBLEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSTRINGEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSTRINGStringKeyword_3_0 = (Keyword)cSTRINGEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum PrimitiveType:
		//	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' //TODO: String as Primitive? (and therefore also better lowercase?)
		//;
		public EnumRule getRule() { return rule; }
		
		//INT='int' | CHAR='char' | DOUBLE='double' | STRING='String'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT='int'
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_0() { return cINTEnumLiteralDeclaration_0; }
		
		//'int'
		public Keyword getINTIntKeyword_0_0() { return cINTIntKeyword_0_0; }
		
		//CHAR='char'
		public EnumLiteralDeclaration getCHAREnumLiteralDeclaration_1() { return cCHAREnumLiteralDeclaration_1; }
		
		//'char'
		public Keyword getCHARCharKeyword_1_0() { return cCHARCharKeyword_1_0; }
		
		//DOUBLE='double'
		public EnumLiteralDeclaration getDOUBLEEnumLiteralDeclaration_2() { return cDOUBLEEnumLiteralDeclaration_2; }
		
		//'double'
		public Keyword getDOUBLEDoubleKeyword_2_0() { return cDOUBLEDoubleKeyword_2_0; }
		
		//STRING='String'
		public EnumLiteralDeclaration getSTRINGEnumLiteralDeclaration_3() { return cSTRINGEnumLiteralDeclaration_3; }
		
		//'String'
		public Keyword getSTRINGStringKeyword_3_0() { return cSTRINGStringKeyword_3_0; }
	}
	public class RelationalOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cLESS_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cLESS_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cLESSLessThanSignKeyword_5_0 = (Keyword)cLESSEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum RelationalOp:
		//	GREATER='>' |
		//	GREATER_OR_EQUAL='>=' |
		//	EQUAL='==' |
		//	UNEQUAL='!=' |
		//	LESS_OR_EQUAL='<=' |
		//	LESS='<';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' | GREATER_OR_EQUAL='>=' | EQUAL='==' | UNEQUAL='!=' | LESS_OR_EQUAL='<=' | LESS='<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }
		
		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }
		
		//UNEQUAL='!='
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_3() { return cUNEQUALEnumLiteralDeclaration_3; }
		
		//'!='
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_3_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_3_0; }
		
		//LESS_OR_EQUAL='<='
		public EnumLiteralDeclaration getLESS_OR_EQUALEnumLiteralDeclaration_4() { return cLESS_OR_EQUALEnumLiteralDeclaration_4; }
		
		//'<='
		public Keyword getLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cLESS_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
		
		//LESS='<'
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_5() { return cLESSEnumLiteralDeclaration_5; }
		
		//'<'
		public Keyword getLESSLessThanSignKeyword_5_0() { return cLESSLessThanSignKeyword_5_0; }
	}
	public class TertiaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TertiaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cORVerticalLineVerticalLineKeyword_2_0 = (Keyword)cOREnumLiteralDeclaration_2.eContents().get(0);
		
		//enum TertiaryOp:
		//	PLUS='+' |
		//	MINUS='-' |
		//	OR='||';
		public EnumRule getRule() { return rule; }
		
		//PLUS='+' | MINUS='-' | OR='||'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }
		
		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
		
		//OR='||'
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_2() { return cOREnumLiteralDeclaration_2; }
		
		//'||'
		public Keyword getORVerticalLineVerticalLineKeyword_2_0() { return cORVerticalLineVerticalLineKeyword_2_0; }
	}
	public class SecondaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SecondaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMODPercentSignKeyword_0_0 = (Keyword)cMODEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cXORCircumflexAccentKeyword_1_0 = (Keyword)cXOREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum SecondaryOp:
		//	MOD='%' |
		//	XOR='^';
		public EnumRule getRule() { return rule; }
		
		//MOD='%' | XOR='^'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MOD='%'
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_0() { return cMODEnumLiteralDeclaration_0; }
		
		//'%'
		public Keyword getMODPercentSignKeyword_0_0() { return cMODPercentSignKeyword_0_0; }
		
		//XOR='^'
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_1() { return cXOREnumLiteralDeclaration_1; }
		
		//'^'
		public Keyword getXORCircumflexAccentKeyword_1_0() { return cXORCircumflexAccentKeyword_1_0; }
	}
	public class PrimaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cANDAmpersandAmpersandKeyword_2_0 = (Keyword)cANDEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PrimaryOp:
		//	MUL='*' |
		//	DIV='/' |
		//	AND='&&';
		public EnumRule getRule() { return rule; }
		
		//MUL='*' | DIV='/' | AND='&&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MUL='*'
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }
		
		//DIV='/'
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
		
		//AND='&&'
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_2() { return cANDEnumLiteralDeclaration_2; }
		
		//'&&'
		public Keyword getANDAmpersandAmpersandKeyword_2_0() { return cANDAmpersandAmpersandKeyword_2_0; }
	}
	
	private final MofgenFileElements pMofgenFile;
	private final ImportElements pImport;
	private final ConfigElements pConfig;
	private final ConfigExpressionElements pConfigExpression;
	private final PatternElements pPattern;
	private final PatternReturnElements pPatternReturn;
	private final ParamManipulationElements pParamManipulation;
	private final NodeElements pNode;
	private final NodeContentElements pNodeContent;
	private final PatternCallElements pPatternCall;
	private final NodeReferenceOrAssignmentOrControlFlowElements pNodeReferenceOrAssignmentOrControlFlow;
	private final PatternNodeReferenceElements pPatternNodeReference;
	private final AssignmentElements pAssignment;
	private final ParameterElements pParameter;
	private final PrimitiveParameterElements pPrimitiveParameter;
	private final ParameterNodeElements pParameterNode;
	private final RefOrCallElements pRefOrCall;
	private final RefParamsElements pRefParams;
	private final GeneratorElements pGenerator;
	private final GeneratorExpressionElements pGeneratorExpression;
	private final PatternObjectCreationElements pPatternObjectCreation;
	private final PatternObjectElements pPatternObject;
	private final ForStatementElements pForStatement;
	private final ForHeadElements pForHead;
	private final GeneralForHeadElements pGeneralForHead;
	private final ForEachHeadElements pForEachHead;
	private final RefTypeElements pRefType;
	private final ForBodyElements pForBody;
	private final SwitchExpressionElements pSwitchExpression;
	private final SwitchElements pSwitch;
	private final IfElseSwitchElements pIfElseSwitch;
	private final IfElseCaseElements pIfElseCase;
	private final DefaultElements pDefault;
	private final SwitchCaseElements pSwitchCase;
	private final CaseElements pCase;
	private final CaseWithCastElements pCaseWithCast;
	private final CaseWithoutCastElements pCaseWithoutCast;
	private final CaseBodyElements pCaseBody;
	private final CollectionElements pCollection;
	private final ListElements pList;
	private final ListAssignmentElements pListAssignment;
	private final ListAdHocElements pListAdHoc;
	private final MapElements pMap;
	private final MapAssignmentElements pMapAssignment;
	private final MapAdHocElements pMapAdHoc;
	private final MapTupelElements pMapTupel;
	private final ForRangeElements pForRange;
	private final ArithmeticExpressionElements pArithmeticExpression;
	private final TertiaryExpressionElements pTertiaryExpression;
	private final SecondaryExpressionElements pSecondaryExpression;
	private final PrimaryExprElements pPrimaryExpr;
	private final RelationExpressionElements pRelationExpression;
	private final BaseExprElements pBaseExpr;
	private final LiteralElements pLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final StringLiteralElements pStringLiteral;
	private final NumberLiteralElements pNumberLiteral;
	private final MathFuncElements eMathFunc;
	private final PrimitiveTypeElements ePrimitiveType;
	private final TerminalRule tDOUBLE;
	private final TerminalRule tTRUE;
	private final TerminalRule tFALSE;
	private final RelationalOpElements eRelationalOp;
	private final TertiaryOpElements eTertiaryOp;
	private final SecondaryOpElements eSecondaryOp;
	private final PrimaryOpElements ePrimaryOp;
	private final TerminalRule tASSIGNMENT_OP;
	private final TerminalRule tNEWLINE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MGLangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMofgenFile = new MofgenFileElements();
		this.pImport = new ImportElements();
		this.pConfig = new ConfigElements();
		this.pConfigExpression = new ConfigExpressionElements();
		this.pPattern = new PatternElements();
		this.pPatternReturn = new PatternReturnElements();
		this.pParamManipulation = new ParamManipulationElements();
		this.pNode = new NodeElements();
		this.pNodeContent = new NodeContentElements();
		this.pPatternCall = new PatternCallElements();
		this.pNodeReferenceOrAssignmentOrControlFlow = new NodeReferenceOrAssignmentOrControlFlowElements();
		this.pPatternNodeReference = new PatternNodeReferenceElements();
		this.pAssignment = new AssignmentElements();
		this.pParameter = new ParameterElements();
		this.pPrimitiveParameter = new PrimitiveParameterElements();
		this.pParameterNode = new ParameterNodeElements();
		this.pRefOrCall = new RefOrCallElements();
		this.pRefParams = new RefParamsElements();
		this.pGenerator = new GeneratorElements();
		this.pGeneratorExpression = new GeneratorExpressionElements();
		this.pPatternObjectCreation = new PatternObjectCreationElements();
		this.pPatternObject = new PatternObjectElements();
		this.pForStatement = new ForStatementElements();
		this.pForHead = new ForHeadElements();
		this.pGeneralForHead = new GeneralForHeadElements();
		this.pForEachHead = new ForEachHeadElements();
		this.pRefType = new RefTypeElements();
		this.pForBody = new ForBodyElements();
		this.pSwitchExpression = new SwitchExpressionElements();
		this.pSwitch = new SwitchElements();
		this.pIfElseSwitch = new IfElseSwitchElements();
		this.pIfElseCase = new IfElseCaseElements();
		this.pDefault = new DefaultElements();
		this.pSwitchCase = new SwitchCaseElements();
		this.pCase = new CaseElements();
		this.pCaseWithCast = new CaseWithCastElements();
		this.pCaseWithoutCast = new CaseWithoutCastElements();
		this.pCaseBody = new CaseBodyElements();
		this.pCollection = new CollectionElements();
		this.pList = new ListElements();
		this.pListAssignment = new ListAssignmentElements();
		this.pListAdHoc = new ListAdHocElements();
		this.pMap = new MapElements();
		this.pMapAssignment = new MapAssignmentElements();
		this.pMapAdHoc = new MapAdHocElements();
		this.pMapTupel = new MapTupelElements();
		this.pForRange = new ForRangeElements();
		this.pArithmeticExpression = new ArithmeticExpressionElements();
		this.pTertiaryExpression = new TertiaryExpressionElements();
		this.pSecondaryExpression = new SecondaryExpressionElements();
		this.pPrimaryExpr = new PrimaryExprElements();
		this.pRelationExpression = new RelationExpressionElements();
		this.pBaseExpr = new BaseExprElements();
		this.pLiteral = new LiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.eMathFunc = new MathFuncElements();
		this.ePrimitiveType = new PrimitiveTypeElements();
		this.tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.DOUBLE");
		this.tTRUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TRUE");
		this.tFALSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.FALSE");
		this.eRelationalOp = new RelationalOpElements();
		this.eTertiaryOp = new TertiaryOpElements();
		this.eSecondaryOp = new SecondaryOpElements();
		this.ePrimaryOp = new PrimaryOpElements();
		this.tASSIGNMENT_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ASSIGNMENT_OP");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NEWLINE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.mofgen.MGLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////TODO: Make Aliases accessible
	////TODO: Variables
	//MofgenFile:
	//	imports+=Import*
	//	config=Config (patterns+=Pattern | generators+=Generator)*;
	public MofgenFileElements getMofgenFileAccess() {
		return pMofgenFile;
	}
	
	public ParserRule getMofgenFileRule() {
		return getMofgenFileAccess().getRule();
	}
	
	//Import:
	//	'import' name=STRING 'as' alias=ID;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Config:
	//	{Config} 'config' '(' ')' '{'
	//	expressions+=ConfigExpression*
	//	'}';
	public ConfigElements getConfigAccess() {
		return pConfig;
	}
	
	public ParserRule getConfigRule() {
		return getConfigAccess().getRule();
	}
	
	//ConfigExpression:
	//	'test';
	public ConfigExpressionElements getConfigExpressionAccess() {
		return pConfigExpression;
	}
	
	public ParserRule getConfigExpressionRule() {
		return getConfigExpressionAccess().getRule();
	}
	
	//Pattern:
	//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* &
	//	nodes+=Node* & paramManipulations+=ParamManipulation* & switches+=Switch*) '}'
	//	return=PatternReturn?;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternReturn:
	//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
	public PatternReturnElements getPatternReturnAccess() {
		return pPatternReturn;
	}
	
	public ParserRule getPatternReturnRule() {
		return getPatternReturnAccess().getRule();
	}
	
	//ParamManipulation:
	//	param=[ParameterNode] content=NodeContent;
	public ParamManipulationElements getParamManipulationAccess() {
		return pParamManipulation;
	}
	
	public ParserRule getParamManipulationRule() {
		return getParamManipulationAccess().getRule();
	}
	
	//Node:
	//	type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?;
	public NodeElements getNodeAccess() {
		return pNode;
	}
	
	public ParserRule getNodeRule() {
		return getNodeAccess().getRule();
	}
	
	//NodeContent:
	//	{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignmentOrControlFlow* '}';
	public NodeContentElements getNodeContentAccess() {
		return pNodeContent;
	}
	
	public ParserRule getNodeContentRule() {
		return getNodeContentAccess().getRule();
	}
	
	//PatternCall:
	//	called=[Pattern] '(' (params+=ArithmeticExpression (',' params+=ArithmeticExpression)*)? ')';
	public PatternCallElements getPatternCallAccess() {
		return pPatternCall;
	}
	
	public ParserRule getPatternCallRule() {
		return getPatternCallAccess().getRule();
	}
	
	//NodeReferenceOrAssignmentOrControlFlow:
	//	PatternNodeReference | Assignment | Switch;
	public NodeReferenceOrAssignmentOrControlFlowElements getNodeReferenceOrAssignmentOrControlFlowAccess() {
		return pNodeReferenceOrAssignmentOrControlFlow;
	}
	
	public ParserRule getNodeReferenceOrAssignmentOrControlFlowRule() {
		return getNodeReferenceOrAssignmentOrControlFlowAccess().getRule();
	}
	
	//PatternNodeReference:
	//	type=[ecore::EReference] '->' target=[Node];
	public PatternNodeReferenceElements getPatternNodeReferenceAccess() {
		return pPatternNodeReference;
	}
	
	public ParserRule getPatternNodeReferenceRule() {
		return getPatternNodeReferenceAccess().getRule();
	}
	
	//Assignment:
	//	target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	////TODO make Enum Assignments possible
	//Parameter:
	//	PrimitiveParameter | ParameterNode;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//PrimitiveParameter:
	//	type=PrimitiveType name=ID;
	public PrimitiveParameterElements getPrimitiveParameterAccess() {
		return pPrimitiveParameter;
	}
	
	public ParserRule getPrimitiveParameterRule() {
		return getPrimitiveParameterAccess().getRule();
	}
	
	//ParameterNode:
	//	type=[ecore::EClassifier] name=ID;
	public ParameterNodeElements getParameterNodeAccess() {
		return pParameterNode;
	}
	
	public ParserRule getParameterNodeRule() {
		return getParameterNodeAccess().getRule();
	}
	
	//RefOrCall:
	//	ref=[RefType] ({RefOrCall.target=current} '.' ref=[ecore::ETypedElement] ('(' params=RefParams? ')')?)*;
	public RefOrCallElements getRefOrCallAccess() {
		return pRefOrCall;
	}
	
	public ParserRule getRefOrCallRule() {
		return getRefOrCallAccess().getRule();
	}
	
	////TODO: Map and List Operations
	//RefParams:
	//	params+=ArithmeticExpression (',' params+=ArithmeticExpression)*;
	public RefParamsElements getRefParamsAccess() {
		return pRefParams;
	}
	
	public ParserRule getRefParamsRule() {
		return getRefParamsAccess().getRule();
	}
	
	//Generator:
	//	{Generator} 'gen' '(' params+=Parameter* ')' '{' commands+=GeneratorExpression* '}';
	public GeneratorElements getGeneratorAccess() {
		return pGenerator;
	}
	
	public ParserRule getGeneratorRule() {
		return getGeneratorAccess().getRule();
	}
	
	//GeneratorExpression:
	//	ForStatement | Switch | Collection | PatternCall | PatternObjectCreation;
	public GeneratorExpressionElements getGeneratorExpressionAccess() {
		return pGeneratorExpression;
	}
	
	public ParserRule getGeneratorExpressionRule() {
		return getGeneratorExpressionAccess().getRule();
	}
	
	//PatternObjectCreation:
	//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
	public PatternObjectCreationElements getPatternObjectCreationAccess() {
		return pPatternObjectCreation;
	}
	
	public ParserRule getPatternObjectCreationRule() {
		return getPatternObjectCreationAccess().getRule();
	}
	
	//PatternObject:
	//	type=[Pattern] name=ID;
	public PatternObjectElements getPatternObjectAccess() {
		return pPatternObject;
	}
	
	public ParserRule getPatternObjectRule() {
		return getPatternObjectAccess().getRule();
	}
	
	//ForStatement:
	//	'for' head=ForHead '{' body=ForBody '}';
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}
	
	//ForHead:
	//	GeneralForHead | ForEachHead;
	public ForHeadElements getForHeadAccess() {
		return pForHead;
	}
	
	public ParserRule getForHeadRule() {
		return getForHeadAccess().getRule();
	}
	
	//GeneralForHead:
	//	iteratorVar=ID 'in' range=ForRange;
	public GeneralForHeadElements getGeneralForHeadAccess() {
		return pGeneralForHead;
	}
	
	public ParserRule getGeneralForHeadRule() {
		return getGeneralForHeadAccess().getRule();
	}
	
	//ForEachHead:
	//	src=RefOrCall '-' eref=[ecore::EReference] '->' iteratorVar=ID;
	public ForEachHeadElements getForEachHeadAccess() {
		return pForEachHead;
	}
	
	public ParserRule getForEachHeadRule() {
		return getForEachHeadAccess().getRule();
	}
	
	//RefType:
	//	Node | Parameter | Collection;
	public RefTypeElements getRefTypeAccess() {
		return pRefType;
	}
	
	public ParserRule getRefTypeRule() {
		return getRefTypeAccess().getRule();
	}
	
	//ForBody:
	//	{ForBody} commands+=GeneratorExpression*;
	public ForBodyElements getForBodyAccess() {
		return pForBody;
	}
	
	public ParserRule getForBodyRule() {
		return getForBodyAccess().getRule();
	}
	
	//SwitchExpression:
	//	ForStatement | Collection | PatternCall | PatternObjectCreation | NodeReferenceOrAssignmentOrControlFlow;
	public SwitchExpressionElements getSwitchExpressionAccess() {
		return pSwitchExpression;
	}
	
	public ParserRule getSwitchExpressionRule() {
		return getSwitchExpressionAccess().getRule();
	}
	
	//Switch:
	//	IfElseSwitch | SwitchCase;
	public SwitchElements getSwitchAccess() {
		return pSwitch;
	}
	
	public ParserRule getSwitchRule() {
		return getSwitchAccess().getRule();
	}
	
	//IfElseSwitch:
	//	'switch' '{' cases+=IfElseCase+ default=Default? '}';
	public IfElseSwitchElements getIfElseSwitchAccess() {
		return pIfElseSwitch;
	}
	
	public ParserRule getIfElseSwitchRule() {
		return getIfElseSwitchAccess().getRule();
	}
	
	//IfElseCase:
	//	'case' val=ArithmeticExpression ':' body=CaseBody;
	public IfElseCaseElements getIfElseCaseAccess() {
		return pIfElseCase;
	}
	
	public ParserRule getIfElseCaseRule() {
		return getIfElseCaseAccess().getRule();
	}
	
	//Default:
	//	'default' ':' CaseBody;
	public DefaultElements getDefaultAccess() {
		return pDefault;
	}
	
	public ParserRule getDefaultRule() {
		return getDefaultAccess().getRule();
	}
	
	//SwitchCase:
	//	'switch' '(' attribute=RefOrCall ')' '{' cases+=Case+ default=Default? '}';
	public SwitchCaseElements getSwitchCaseAccess() {
		return pSwitchCase;
	}
	
	public ParserRule getSwitchCaseRule() {
		return getSwitchCaseAccess().getRule();
	}
	
	//Case:
	//	CaseWithCast | CaseWithoutCast;
	public CaseElements getCaseAccess() {
		return pCase;
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}
	
	//CaseWithCast: // TODO: Check that arithmetic expression really yields boolean value
	//	'case' node=Node ('when' when=ArithmeticExpression)? ':' body=CaseBody;
	public CaseWithCastElements getCaseWithCastAccess() {
		return pCaseWithCast;
	}
	
	public ParserRule getCaseWithCastRule() {
		return getCaseWithCastAccess().getRule();
	}
	
	//CaseWithoutCast:
	//	'case' val=ArithmeticExpression ':' body=CaseBody;
	public CaseWithoutCastElements getCaseWithoutCastAccess() {
		return pCaseWithoutCast;
	}
	
	public ParserRule getCaseWithoutCastRule() {
		return getCaseWithoutCastAccess().getRule();
	}
	
	//CaseBody:
	//	{CaseBody} '{' expressions+=SwitchExpression* '}' | expressions+=SwitchExpression NEWLINE;
	public CaseBodyElements getCaseBodyAccess() {
		return pCaseBody;
	}
	
	public ParserRule getCaseBodyRule() {
		return getCaseBodyAccess().getRule();
	}
	
	//Collection:
	//	List | Map;
	public CollectionElements getCollectionAccess() {
		return pCollection;
	}
	
	public ParserRule getCollectionRule() {
		return getCollectionAccess().getRule();
	}
	
	//List:
	//	'List' name=ID (ASSIGNMENT_OP createdBy=ListAssignment)?;
	public ListElements getListAccess() {
		return pList;
	}
	
	public ParserRule getListRule() {
		return getListAccess().getRule();
	}
	
	//ListAssignment:
	//	ListAdHoc | RefOrCall;
	public ListAssignmentElements getListAssignmentAccess() {
		return pListAssignment;
	}
	
	public ParserRule getListAssignmentRule() {
		return getListAssignmentAccess().getRule();
	}
	
	//ListAdHoc: //TODO Returns List?
	//	'[' elements+=Literal (',' elements+=Literal)* ']' //TODO Allow empty lists? --> Probably have no purpose here since one will not be able to manipulate them, right?
	//;
	public ListAdHocElements getListAdHocAccess() {
		return pListAdHoc;
	}
	
	public ParserRule getListAdHocRule() {
		return getListAdHocAccess().getRule();
	}
	
	//Map:
	//	'Map' name=ID (ASSIGNMENT_OP createdBy=MapAssignment)?;
	public MapElements getMapAccess() {
		return pMap;
	}
	
	public ParserRule getMapRule() {
		return getMapAccess().getRule();
	}
	
	//MapAssignment:
	//	MapAdHoc | RefOrCall;
	public MapAssignmentElements getMapAssignmentAccess() {
		return pMapAssignment;
	}
	
	public ParserRule getMapAssignmentRule() {
		return getMapAssignmentAccess().getRule();
	}
	
	//MapAdHoc: //TODO Returns Map?
	//	'[' entries+=MapTupel (',' entries+=MapTupel)* ']';
	public MapAdHocElements getMapAdHocAccess() {
		return pMapAdHoc;
	}
	
	public ParserRule getMapAdHocRule() {
		return getMapAdHocAccess().getRule();
	}
	
	//MapTupel:
	//	'(' key=Literal ',' value=ArithmeticExpression ')';
	public MapTupelElements getMapTupelAccess() {
		return pMapTupel;
	}
	
	public ParserRule getMapTupelRule() {
		return getMapTupelAccess().getRule();
	}
	
	//ForRange:
	//	start=ArithmeticExpression ':' end=ArithmeticExpression;
	public ForRangeElements getForRangeAccess() {
		return pForRange;
	}
	
	public ParserRule getForRangeRule() {
		return getForRangeAccess().getRule();
	}
	
	////======================================Arithmetics============================================
	//ArithmeticExpression:
	//	TertiaryExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return pArithmeticExpression;
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}
	
	//TertiaryExpression ArithmeticExpression:
	//	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;
	public TertiaryExpressionElements getTertiaryExpressionAccess() {
		return pTertiaryExpression;
	}
	
	public ParserRule getTertiaryExpressionRule() {
		return getTertiaryExpressionAccess().getRule();
	}
	
	//SecondaryExpression ArithmeticExpression:
	//	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;
	public SecondaryExpressionElements getSecondaryExpressionAccess() {
		return pSecondaryExpression;
	}
	
	public ParserRule getSecondaryExpressionRule() {
		return getSecondaryExpressionAccess().getRule();
	}
	
	//PrimaryExpr ArithmeticExpression:
	//	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;
	public PrimaryExprElements getPrimaryExprAccess() {
		return pPrimaryExpr;
	}
	
	public ParserRule getPrimaryExprRule() {
		return getPrimaryExprAccess().getRule();
	}
	
	//RelationExpression ArithmeticExpression:
	//	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;
	public RelationExpressionElements getRelationExpressionAccess() {
		return pRelationExpression;
	}
	
	public ParserRule getRelationExpressionRule() {
		return getRelationExpressionAccess().getRule();
	}
	
	//BaseExpr ArithmeticExpression:
	//	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
	//	expr=ArithmeticExpression ')' | Literal | RefOrCall;
	public BaseExprElements getBaseExprAccess() {
		return pBaseExpr;
	}
	
	public ParserRule getBaseExprRule() {
		return getBaseExprAccess().getRule();
	}
	
	//Literal:
	//	BooleanLiteral | StringLiteral | NumberLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BooleanLiteral:
	//	val=(TRUE | FALSE);
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	val=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//NumberLiteral:
	//	val=DOUBLE;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//enum MathFunc:
	//	SQRT='sqrt' | ABS='abs';
	public MathFuncElements getMathFuncAccess() {
		return eMathFunc;
	}
	
	public EnumRule getMathFuncRule() {
		return getMathFuncAccess().getRule();
	}
	
	//enum PrimitiveType:
	//	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' //TODO: String as Primitive? (and therefore also better lowercase?)
	//;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return ePrimitiveType;
	}
	
	public EnumRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}
	
	//terminal DOUBLE returns ecore::EDouble:
	//	INT ('.' INT)?;
	public TerminalRule getDOUBLERule() {
		return tDOUBLE;
	}
	
	//terminal TRUE returns ecore::EBoolean:
	//	'true';
	public TerminalRule getTRUERule() {
		return tTRUE;
	}
	
	//terminal FALSE returns ecore::EBoolean:
	//	'false';
	public TerminalRule getFALSERule() {
		return tFALSE;
	}
	
	//enum RelationalOp:
	//	GREATER='>' |
	//	GREATER_OR_EQUAL='>=' |
	//	EQUAL='==' |
	//	UNEQUAL='!=' |
	//	LESS_OR_EQUAL='<=' |
	//	LESS='<';
	public RelationalOpElements getRelationalOpAccess() {
		return eRelationalOp;
	}
	
	public EnumRule getRelationalOpRule() {
		return getRelationalOpAccess().getRule();
	}
	
	//enum TertiaryOp:
	//	PLUS='+' |
	//	MINUS='-' |
	//	OR='||';
	public TertiaryOpElements getTertiaryOpAccess() {
		return eTertiaryOp;
	}
	
	public EnumRule getTertiaryOpRule() {
		return getTertiaryOpAccess().getRule();
	}
	
	//enum SecondaryOp:
	//	MOD='%' |
	//	XOR='^';
	public SecondaryOpElements getSecondaryOpAccess() {
		return eSecondaryOp;
	}
	
	public EnumRule getSecondaryOpRule() {
		return getSecondaryOpAccess().getRule();
	}
	
	//enum PrimaryOp:
	//	MUL='*' |
	//	DIV='/' |
	//	AND='&&';
	public PrimaryOpElements getPrimaryOpAccess() {
		return ePrimaryOp;
	}
	
	public EnumRule getPrimaryOpRule() {
		return getPrimaryOpAccess().getRule();
	}
	
	//terminal ASSIGNMENT_OP:
	//	'=';
	public TerminalRule getASSIGNMENT_OPRule() {
		return tASSIGNMENT_OP;
	}
	
	//terminal NEWLINE:
	//	'\n';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
