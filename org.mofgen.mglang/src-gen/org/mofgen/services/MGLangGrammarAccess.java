/*
 * generated by Xtext 2.20.0
 */
package org.mofgen.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MGLangGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MofgenFileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MofgenFile");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cPatternsAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cPatternsPatternParserRuleCall_1_0_0 = (RuleCall)cPatternsAssignment_1_0.eContents().get(0);
		private final Assignment cGeneratorsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cGeneratorsGeneratorParserRuleCall_1_1_0 = (RuleCall)cGeneratorsAssignment_1_1.eContents().get(0);
		
		//MofgenFile:
		//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+=Import* (patterns+=Pattern | generators+=Generator)*
		public Group getGroup() { return cGroup; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_0_0() { return cImportsImportParserRuleCall_0_0; }
		
		//(patterns+=Pattern | generators+=Generator)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//patterns+=Pattern
		public Assignment getPatternsAssignment_1_0() { return cPatternsAssignment_1_0; }
		
		//Pattern
		public RuleCall getPatternsPatternParserRuleCall_1_0_0() { return cPatternsPatternParserRuleCall_1_0_0; }
		
		//generators+=Generator
		public Assignment getGeneratorsAssignment_1_1() { return cGeneratorsAssignment_1_1; }
		
		//Generator
		public RuleCall getGeneratorsGeneratorParserRuleCall_1_1_0() { return cGeneratorsGeneratorParserRuleCall_1_1_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cAsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAliasAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAliasIDTerminalRuleCall_3_0 = (RuleCall)cAliasAssignment_3.eContents().get(0);
		
		//Import:
		//	'import' name=STRING 'as' alias=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//'import' name=STRING 'as' alias=ID
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }
		
		//'as'
		public Keyword getAsKeyword_2() { return cAsKeyword_2; }
		
		//alias=ID
		public Assignment getAliasAssignment_3() { return cAliasAssignment_3; }
		
		//ID
		public RuleCall getAliasIDTerminalRuleCall_3_0() { return cAliasIDTerminalRuleCall_3_0; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPatternKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cParametersAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_2_1_0_0 = (RuleCall)cParametersAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_2_1_1_1_0 = (RuleCall)cParametersAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final UnorderedGroup cUnorderedGroup_4 = (UnorderedGroup)cGroup.eContents().get(4);
		private final Assignment cCollsAssignment_4_0 = (Assignment)cUnorderedGroup_4.eContents().get(0);
		private final RuleCall cCollsCollectionParserRuleCall_4_0_0 = (RuleCall)cCollsAssignment_4_0.eContents().get(0);
		private final Assignment cNodesAssignment_4_1 = (Assignment)cUnorderedGroup_4.eContents().get(1);
		private final RuleCall cNodesNodeParserRuleCall_4_1_0 = (RuleCall)cNodesAssignment_4_1.eContents().get(0);
		private final Assignment cParamManipulationsAssignment_4_2 = (Assignment)cUnorderedGroup_4.eContents().get(2);
		private final RuleCall cParamManipulationsParamManipulationParserRuleCall_4_2_0 = (RuleCall)cParamManipulationsAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReturnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReturnPatternReturnParserRuleCall_6_0 = (RuleCall)cReturnAssignment_6.eContents().get(0);
		
		//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
		//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* &
		//	nodes+=Node* & paramManipulations+=ParamManipulation*) '}' return=PatternReturn?;
		@Override public ParserRule getRule() { return rule; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* & nodes+=Node*
		//& paramManipulations+=ParamManipulation*) '}' return=PatternReturn?
		public Group getGroup() { return cGroup; }
		
		////(abstract?='abstract')? // 'Abstract' necessary? TODO
		//'pattern'
		public Keyword getPatternKeyword_0() { return cPatternKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')')
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_0() { return cParametersAssignment_2_1_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_0_0() { return cParametersParameterParserRuleCall_2_1_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_2_1_1_1() { return cParametersAssignment_2_1_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_1_1_1_0() { return cParametersParameterParserRuleCall_2_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(colls+=Collection* & nodes+=Node* & paramManipulations+=ParamManipulation*)
		public UnorderedGroup getUnorderedGroup_4() { return cUnorderedGroup_4; }
		
		//colls+=Collection*
		public Assignment getCollsAssignment_4_0() { return cCollsAssignment_4_0; }
		
		//Collection
		public RuleCall getCollsCollectionParserRuleCall_4_0_0() { return cCollsCollectionParserRuleCall_4_0_0; }
		
		//nodes+=Node*
		public Assignment getNodesAssignment_4_1() { return cNodesAssignment_4_1; }
		
		//Node
		public RuleCall getNodesNodeParserRuleCall_4_1_0() { return cNodesNodeParserRuleCall_4_1_0; }
		
		//paramManipulations+=ParamManipulation*
		public Assignment getParamManipulationsAssignment_4_2() { return cParamManipulationsAssignment_4_2; }
		
		//ParamManipulation
		public RuleCall getParamManipulationsParamManipulationParserRuleCall_4_2_0() { return cParamManipulationsParamManipulationParserRuleCall_4_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
		
		//return=PatternReturn?
		public Assignment getReturnAssignment_6() { return cReturnAssignment_6; }
		
		//PatternReturn
		public RuleCall getReturnPatternReturnParserRuleCall_6_0() { return cReturnPatternReturnParserRuleCall_6_0; }
	}
	public class PatternReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternReturn");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternReturnAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cThisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cFullStopKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cReturnValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cReturnValueNodeCrossReference_3_1_0 = (CrossReference)cReturnValueAssignment_3_1.eContents().get(0);
		private final RuleCall cReturnValueNodeIDTerminalRuleCall_3_1_0_1 = (RuleCall)cReturnValueNodeCrossReference_3_1_0.eContents().get(1);
		
		//PatternReturn:
		//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
		@Override public ParserRule getRule() { return rule; }
		
		//{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?
		public Group getGroup() { return cGroup; }
		
		//{PatternReturn}
		public Action getPatternReturnAction_0() { return cPatternReturnAction_0; }
		
		//'return'
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }
		
		//'this'
		public Keyword getThisKeyword_2() { return cThisKeyword_2; }
		
		//('.' returnValue=[Node])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'.'
		public Keyword getFullStopKeyword_3_0() { return cFullStopKeyword_3_0; }
		
		//returnValue=[Node]
		public Assignment getReturnValueAssignment_3_1() { return cReturnValueAssignment_3_1; }
		
		//[Node]
		public CrossReference getReturnValueNodeCrossReference_3_1_0() { return cReturnValueNodeCrossReference_3_1_0; }
		
		//ID
		public RuleCall getReturnValueNodeIDTerminalRuleCall_3_1_0_1() { return cReturnValueNodeIDTerminalRuleCall_3_1_0_1; }
	}
	public class ParamManipulationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParamManipulation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cParamAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cParamParameterNodeCrossReference_0_0 = (CrossReference)cParamAssignment_0.eContents().get(0);
		private final RuleCall cParamParameterNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cParamParameterNodeCrossReference_0_0.eContents().get(1);
		private final Assignment cContentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContentNodeContentParserRuleCall_1_0 = (RuleCall)cContentAssignment_1.eContents().get(0);
		
		//ParamManipulation:
		//	param=[ParameterNode] content=NodeContent;
		@Override public ParserRule getRule() { return rule; }
		
		//param=[ParameterNode] content=NodeContent
		public Group getGroup() { return cGroup; }
		
		//param=[ParameterNode]
		public Assignment getParamAssignment_0() { return cParamAssignment_0; }
		
		//[ParameterNode]
		public CrossReference getParamParameterNodeCrossReference_0_0() { return cParamParameterNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getParamParameterNodeIDTerminalRuleCall_0_0_1() { return cParamParameterNodeIDTerminalRuleCall_0_0_1; }
		
		//content=NodeContent
		public Assignment getContentAssignment_1() { return cContentAssignment_1; }
		
		//NodeContent
		public RuleCall getContentNodeContentParserRuleCall_1_0() { return cContentNodeContentParserRuleCall_1_0; }
	}
	public class NodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Node");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cCreatedByAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cCreatedByNodeContentParserRuleCall_2_0_0 = (RuleCall)cCreatedByAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_1_0 = (RuleCall)cGroup_2_1.eContents().get(0);
		private final Assignment cCreatedByAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cCreatedByPatternCallParserRuleCall_2_1_1_0 = (RuleCall)cCreatedByAssignment_2_1_1.eContents().get(0);
		
		//Node:
		//	type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClass]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClass]
		public CrossReference getTypeEClassCrossReference_0_0() { return cTypeEClassCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassIDTerminalRuleCall_0_0_1() { return cTypeEClassIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//createdBy=NodeContent
		public Assignment getCreatedByAssignment_2_0() { return cCreatedByAssignment_2_0; }
		
		//NodeContent
		public RuleCall getCreatedByNodeContentParserRuleCall_2_0_0() { return cCreatedByNodeContentParserRuleCall_2_0_0; }
		
		//ASSIGNMENT_OP createdBy=PatternCall
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_1_0() { return cASSIGNMENT_OPTerminalRuleCall_2_1_0; }
		
		//createdBy=PatternCall
		public Assignment getCreatedByAssignment_2_1_1() { return cCreatedByAssignment_2_1_1; }
		
		//PatternCall
		public RuleCall getCreatedByPatternCallParserRuleCall_2_1_1_0() { return cCreatedByPatternCallParserRuleCall_2_1_1_0; }
	}
	public class NodeContentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeContent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeContentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefsAssignsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0 = (RuleCall)cRefsAssignsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//NodeContent:
		//	{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignment* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignment* '}'
		public Group getGroup() { return cGroup; }
		
		//{NodeContent}
		public Action getNodeContentAction_0() { return cNodeContentAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//refsAssigns+=NodeReferenceOrAssignment*
		public Assignment getRefsAssignsAssignment_2() { return cRefsAssignsAssignment_2; }
		
		//NodeReferenceOrAssignment
		public RuleCall getRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0() { return cRefsAssignsNodeReferenceOrAssignmentParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class PatternCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledPatternCrossReference_0_0 = (CrossReference)cCalledAssignment_0.eContents().get(0);
		private final RuleCall cCalledPatternIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledPatternCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParamsArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cParamsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//PatternCall:
		//	called=[Pattern] '(' params+=ArithmeticExpression* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//called=[Pattern] '(' params+=ArithmeticExpression* ')'
		public Group getGroup() { return cGroup; }
		
		//called=[Pattern]
		public Assignment getCalledAssignment_0() { return cCalledAssignment_0; }
		
		//[Pattern]
		public CrossReference getCalledPatternCrossReference_0_0() { return cCalledPatternCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledPatternIDTerminalRuleCall_0_0_1() { return cCalledPatternIDTerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//params+=ArithmeticExpression*
		public Assignment getParamsAssignment_2() { return cParamsAssignment_2; }
		
		//ArithmeticExpression
		public RuleCall getParamsArithmeticExpressionParserRuleCall_2_0() { return cParamsArithmeticExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class NodeReferenceOrAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeReferenceOrAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cPatternNodeReferenceParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cConditionAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cConditionArithmeticExpressionParserRuleCall_1_1_0 = (RuleCall)cConditionAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//NodeReferenceOrAssignment:
		//	(PatternNodeReference | Assignment) ('[' condition=ArithmeticExpression ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//(PatternNodeReference | Assignment) ('[' condition=ArithmeticExpression ']')?
		public Group getGroup() { return cGroup; }
		
		//(PatternNodeReference | Assignment)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//PatternNodeReference
		public RuleCall getPatternNodeReferenceParserRuleCall_0_0() { return cPatternNodeReferenceParserRuleCall_0_0; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_0_1() { return cAssignmentParserRuleCall_0_1; }
		
		//('[' condition=ArithmeticExpression ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//condition=ArithmeticExpression
		public Assignment getConditionAssignment_1_1() { return cConditionAssignment_1_1; }
		
		//ArithmeticExpression
		public RuleCall getConditionArithmeticExpressionParserRuleCall_1_1_0() { return cConditionArithmeticExpressionParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class PatternNodeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternNodeReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEReferenceCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEReferenceIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEReferenceCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTargetNodeCrossReference_2_0 = (CrossReference)cTargetAssignment_2.eContents().get(0);
		private final RuleCall cTargetNodeIDTerminalRuleCall_2_0_1 = (RuleCall)cTargetNodeCrossReference_2_0.eContents().get(1);
		
		//PatternNodeReference:
		//	type=[ecore::EReference] '->' target=[Node];
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EReference] '->' target=[Node]
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EReference]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EReference]
		public CrossReference getTypeEReferenceCrossReference_0_0() { return cTypeEReferenceCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEReferenceIDTerminalRuleCall_0_0_1() { return cTypeEReferenceIDTerminalRuleCall_0_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//target=[Node]
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }
		
		//[Node]
		public CrossReference getTargetNodeCrossReference_2_0() { return cTargetNodeCrossReference_2_0; }
		
		//ID
		public RuleCall getTargetNodeIDTerminalRuleCall_2_0_1() { return cTargetNodeIDTerminalRuleCall_2_0_1; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTargetAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTargetEAttributeCrossReference_0_0 = (CrossReference)cTargetAssignment_0.eContents().get(0);
		private final RuleCall cTargetEAttributeIDTerminalRuleCall_0_0_1 = (RuleCall)cTargetEAttributeCrossReference_0_0.eContents().get(1);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//Assignment:
		//	target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression
		public Group getGroup() { return cGroup; }
		
		//target=[ecore::EAttribute]
		public Assignment getTargetAssignment_0() { return cTargetAssignment_0; }
		
		//[ecore::EAttribute]
		public CrossReference getTargetEAttributeCrossReference_0_0() { return cTargetEAttributeCrossReference_0_0; }
		
		//ID
		public RuleCall getTargetEAttributeIDTerminalRuleCall_0_0_1() { return cTargetEAttributeIDTerminalRuleCall_0_0_1; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//value=ArithmeticExpression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//ArithmeticExpression
		public RuleCall getValueArithmeticExpressionParserRuleCall_2_0() { return cValueArithmeticExpressionParserRuleCall_2_0; }
	}
	public class NodeAttributeCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeAttributeCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cNodeNodeCrossReference_0_0 = (CrossReference)cNodeAssignment_0.eContents().get(0);
		private final RuleCall cNodeNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cNodeNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cAttributeEAttributeCrossReference_2_0 = (CrossReference)cAttributeAssignment_2.eContents().get(0);
		private final RuleCall cAttributeEAttributeIDTerminalRuleCall_2_0_1 = (RuleCall)cAttributeEAttributeCrossReference_2_0.eContents().get(1);
		
		////TODO make Enum Assignments possible
		//NodeAttributeCall:
		//	node=[Node] '.' attribute=[ecore::EAttribute];
		@Override public ParserRule getRule() { return rule; }
		
		//node=[Node] '.' attribute=[ecore::EAttribute]
		public Group getGroup() { return cGroup; }
		
		//node=[Node]
		public Assignment getNodeAssignment_0() { return cNodeAssignment_0; }
		
		//[Node]
		public CrossReference getNodeNodeCrossReference_0_0() { return cNodeNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getNodeNodeIDTerminalRuleCall_0_0_1() { return cNodeNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//attribute=[ecore::EAttribute]
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//[ecore::EAttribute]
		public CrossReference getAttributeEAttributeCrossReference_2_0() { return cAttributeEAttributeCrossReference_2_0; }
		
		//ID
		public RuleCall getAttributeEAttributeIDTerminalRuleCall_2_0_1() { return cAttributeEAttributeIDTerminalRuleCall_2_0_1; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Parameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterNodeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Parameter:
		//	PrimitiveParameter | ParameterNode;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimitiveParameter | ParameterNode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimitiveParameter
		public RuleCall getPrimitiveParameterParserRuleCall_0() { return cPrimitiveParameterParserRuleCall_0; }
		
		//ParameterNode
		public RuleCall getParameterNodeParserRuleCall_1() { return cParameterNodeParserRuleCall_1; }
	}
	public class PrimitiveParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypePrimitiveTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PrimitiveParameter:
		//	type=PrimitiveType name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=PrimitiveType name=ID
		public Group getGroup() { return cGroup; }
		
		//type=PrimitiveType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//PrimitiveType
		public RuleCall getTypePrimitiveTypeEnumRuleCall_0_0() { return cTypePrimitiveTypeEnumRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ParameterNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEClassifierCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEClassifierIDTerminalRuleCall_0_0_1 = (RuleCall)cTypeEClassifierCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ParameterNode:
		//	type=[ecore::EClassifier] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EClassifier] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EClassifier]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EClassifier]
		public CrossReference getTypeEClassifierCrossReference_0_0() { return cTypeEClassifierCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeEClassifierIDTerminalRuleCall_0_0_1() { return cTypeEClassifierIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ParameterRefOrMethodCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterRefOrMethodCall");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ParameterRefOrMethodCall:
		//	ParameterRef | MethodCall;
		@Override public ParserRule getRule() { return rule; }
		
		//ParameterRef | MethodCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ParameterRef
		public RuleCall getParameterRefParserRuleCall_0() { return cParameterRefParserRuleCall_0; }
		
		//MethodCall
		public RuleCall getMethodCallParserRuleCall_1() { return cMethodCallParserRuleCall_1; }
	}
	public class ParameterRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ParameterRef");
		private final Assignment cRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cRefParameterCrossReference_0 = (CrossReference)cRefAssignment.eContents().get(0);
		private final RuleCall cRefParameterIDTerminalRuleCall_0_1 = (RuleCall)cRefParameterCrossReference_0.eContents().get(1);
		
		//ParameterRef:
		//	ref=[Parameter];
		@Override public ParserRule getRule() { return rule; }
		
		//ref=[Parameter]
		public Assignment getRefAssignment() { return cRefAssignment; }
		
		//[Parameter]
		public CrossReference getRefParameterCrossReference_0() { return cRefParameterCrossReference_0; }
		
		//ID
		public RuleCall getRefParameterIDTerminalRuleCall_0_1() { return cRefParameterIDTerminalRuleCall_0_1; }
	}
	public class MethodCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MethodCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCalledNodeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cCalledNodeNodeCrossReference_0_0 = (CrossReference)cCalledNodeAssignment_0.eContents().get(0);
		private final RuleCall cCalledNodeNodeIDTerminalRuleCall_0_0_1 = (RuleCall)cCalledNodeNodeCrossReference_0_0.eContents().get(1);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMethodAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cMethodEOperationCrossReference_2_0 = (CrossReference)cMethodAssignment_2.eContents().get(0);
		private final RuleCall cMethodEOperationIDTerminalRuleCall_2_0_1 = (RuleCall)cMethodEOperationCrossReference_2_0.eContents().get(1);
		
		//MethodCall:
		//	calledNode=[Node] '.' method=[ecore::EOperation];
		@Override public ParserRule getRule() { return rule; }
		
		////TODO Scoping
		//calledNode=[Node] '.' method=[ecore::EOperation]
		public Group getGroup() { return cGroup; }
		
		////TODO Scoping
		//calledNode=[Node]
		public Assignment getCalledNodeAssignment_0() { return cCalledNodeAssignment_0; }
		
		//[Node]
		public CrossReference getCalledNodeNodeCrossReference_0_0() { return cCalledNodeNodeCrossReference_0_0; }
		
		//ID
		public RuleCall getCalledNodeNodeIDTerminalRuleCall_0_0_1() { return cCalledNodeNodeIDTerminalRuleCall_0_0_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//method=[ecore::EOperation]
		public Assignment getMethodAssignment_2() { return cMethodAssignment_2; }
		
		//[ecore::EOperation]
		public CrossReference getMethodEOperationCrossReference_2_0() { return cMethodEOperationCrossReference_2_0; }
		
		//ID
		public RuleCall getMethodEOperationIDTerminalRuleCall_2_0_1() { return cMethodEOperationIDTerminalRuleCall_2_0_1; }
	}
	public class ArithmeticExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ArithmeticExpression");
		private final RuleCall cTertiaryExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ArithmeticExpression:
		//	TertiaryExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//TertiaryExpression
		public RuleCall getTertiaryExpressionParserRuleCall() { return cTertiaryExpressionParserRuleCall; }
	}
	public class TertiaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TertiaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSecondaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTertiaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpTertiaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSecondaryExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//TertiaryExpression ArithmeticExpression:
		//	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*
		public Group getGroup() { return cGroup; }
		
		//SecondaryExpression
		public RuleCall getSecondaryExpressionParserRuleCall_0() { return cSecondaryExpressionParserRuleCall_0; }
		
		//({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Tertiary.left=current}
		public Action getTertiaryLeftAction_1_0() { return cTertiaryLeftAction_1_0; }
		
		//op=TertiaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//TertiaryOp
		public RuleCall getOpTertiaryOpEnumRuleCall_1_1_0() { return cOpTertiaryOpEnumRuleCall_1_1_0; }
		
		//right=SecondaryExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//SecondaryExpression
		public RuleCall getRightSecondaryExpressionParserRuleCall_1_2_0() { return cRightSecondaryExpressionParserRuleCall_1_2_0; }
	}
	public class SecondaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SecondaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSecondaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpSecondaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SecondaryExpression ArithmeticExpression:
		//	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*
		public Group getGroup() { return cGroup; }
		
		//PrimaryExpr
		public RuleCall getPrimaryExprParserRuleCall_0() { return cPrimaryExprParserRuleCall_0; }
		
		//({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Secondary.left=current}
		public Action getSecondaryLeftAction_1_0() { return cSecondaryLeftAction_1_0; }
		
		//op=SecondaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//SecondaryOp
		public RuleCall getOpSecondaryOpEnumRuleCall_1_1_0() { return cOpSecondaryOpEnumRuleCall_1_1_0; }
		
		//right=PrimaryExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PrimaryExpr
		public RuleCall getRightPrimaryExprParserRuleCall_1_2_0() { return cRightPrimaryExprParserRuleCall_1_2_0; }
	}
	public class PrimaryExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimaryExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRelationExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPrimaryLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPrimaryOpEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightRelationExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PrimaryExpr ArithmeticExpression:
		//	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*
		public Group getGroup() { return cGroup; }
		
		//RelationExpression
		public RuleCall getRelationExpressionParserRuleCall_0() { return cRelationExpressionParserRuleCall_0; }
		
		//({Primary.left=current} op=PrimaryOp right=RelationExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Primary.left=current}
		public Action getPrimaryLeftAction_1_0() { return cPrimaryLeftAction_1_0; }
		
		//op=PrimaryOp
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//PrimaryOp
		public RuleCall getOpPrimaryOpEnumRuleCall_1_1_0() { return cOpPrimaryOpEnumRuleCall_1_1_0; }
		
		//right=RelationExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//RelationExpression
		public RuleCall getRightRelationExpressionParserRuleCall_1_2_0() { return cRightRelationExpressionParserRuleCall_1_2_0; }
	}
	public class RelationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cRelationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRelationRelationalOpEnumRuleCall_1_1_0 = (RuleCall)cRelationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBaseExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelationExpression ArithmeticExpression:
		//	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*
		public Group getGroup() { return cGroup; }
		
		//BaseExpr
		public RuleCall getBaseExprParserRuleCall_0() { return cBaseExprParserRuleCall_0; }
		
		//({Rel.left=current} relation=RelationalOp right=BaseExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Rel.left=current}
		public Action getRelLeftAction_1_0() { return cRelLeftAction_1_0; }
		
		//relation=RelationalOp
		public Assignment getRelationAssignment_1_1() { return cRelationAssignment_1_1; }
		
		//RelationalOp
		public RuleCall getRelationRelationalOpEnumRuleCall_1_1_0() { return cRelationRelationalOpEnumRuleCall_1_1_0; }
		
		//right=BaseExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//BaseExpr
		public RuleCall getRightBaseExprParserRuleCall_1_2_0() { return cRightBaseExprParserRuleCall_1_2_0; }
	}
	public class BaseExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BaseExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cArithmeticExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNegationExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprBaseExprParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cFunctionCallAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cFuncAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cFuncMathFuncEnumRuleCall_2_1_0 = (RuleCall)cFuncAssignment_2_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cExprAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cExprArithmeticExpressionParserRuleCall_2_3_0 = (RuleCall)cExprAssignment_2_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cLiteralAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final RuleCall cLiteralParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final RuleCall cParameterRefOrMethodCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//BaseExpr ArithmeticExpression:
		//	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
		//	expr=ArithmeticExpression ')' | {Literal} Literal | ParameterRefOrMethodCall;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
		//expr=ArithmeticExpression ')' | {Literal} Literal | ParameterRefOrMethodCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' ArithmeticExpression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//ArithmeticExpression
		public RuleCall getArithmeticExpressionParserRuleCall_0_1() { return cArithmeticExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{NegationExpression} '!' expr=BaseExpr
		public Group getGroup_1() { return cGroup_1; }
		
		//{NegationExpression}
		public Action getNegationExpressionAction_1_0() { return cNegationExpressionAction_1_0; }
		
		//'!'
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }
		
		//expr=BaseExpr
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }
		
		//BaseExpr
		public RuleCall getExprBaseExprParserRuleCall_1_2_0() { return cExprBaseExprParserRuleCall_1_2_0; }
		
		//{FunctionCall} func=MathFunc '(' expr=ArithmeticExpression ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//{FunctionCall}
		public Action getFunctionCallAction_2_0() { return cFunctionCallAction_2_0; }
		
		//func=MathFunc
		public Assignment getFuncAssignment_2_1() { return cFuncAssignment_2_1; }
		
		//MathFunc
		public RuleCall getFuncMathFuncEnumRuleCall_2_1_0() { return cFuncMathFuncEnumRuleCall_2_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_2() { return cLeftParenthesisKeyword_2_2; }
		
		//expr=ArithmeticExpression
		public Assignment getExprAssignment_2_3() { return cExprAssignment_2_3; }
		
		//ArithmeticExpression
		public RuleCall getExprArithmeticExpressionParserRuleCall_2_3_0() { return cExprArithmeticExpressionParserRuleCall_2_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_4() { return cRightParenthesisKeyword_2_4; }
		
		//{Literal} Literal
		public Group getGroup_3() { return cGroup_3; }
		
		//{Literal}
		public Action getLiteralAction_3_0() { return cLiteralAction_3_0; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_3_1() { return cLiteralParserRuleCall_3_1; }
		
		//ParameterRefOrMethodCall
		public RuleCall getParameterRefOrMethodCallParserRuleCall_4() { return cParameterRefOrMethodCallParserRuleCall_4; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Literal:
		//	BooleanLiteral | StringLiteral | NumberLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanLiteral | StringLiteral | NumberLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_0() { return cBooleanLiteralParserRuleCall_0; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_1() { return cStringLiteralParserRuleCall_1; }
		
		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_2() { return cNumberLiteralParserRuleCall_2; }
	}
	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTRUETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFALSETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BooleanLiteral ecore::EBoolean:
		//	TRUE | FALSE;
		@Override public ParserRule getRule() { return rule; }
		
		//TRUE | FALSE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TRUE
		public RuleCall getTRUETerminalRuleCall_0() { return cTRUETerminalRuleCall_0; }
		
		//FALSE
		public RuleCall getFALSETerminalRuleCall_1() { return cFALSETerminalRuleCall_1; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.StringLiteral");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StringLiteral:
		//	STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}
	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NumberLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//NumberLiteral ecore::EDouble:
		//	INT ('.' INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//INT ('.' INT)?
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//('.' INT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1_1() { return cINTTerminalRuleCall_1_1; }
	}
	public class GeneratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Generator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGeneratorAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParamsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParamsParameterParserRuleCall_3_0 = (RuleCall)cParamsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cCommandsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCommandsGeneratorCommandParserRuleCall_6_0 = (RuleCall)cCommandsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Generator:
		//	{Generator} 'gen' '('
		//	params+=Parameter*
		//	')' '{' commands+=GeneratorCommand* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Generator} 'gen' '(' params+=Parameter* ')' '{' commands+=GeneratorCommand* '}'
		public Group getGroup() { return cGroup; }
		
		//{Generator}
		public Action getGeneratorAction_0() { return cGeneratorAction_0; }
		
		//'gen'
		public Keyword getGenKeyword_1() { return cGenKeyword_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//params+=Parameter*
		public Assignment getParamsAssignment_3() { return cParamsAssignment_3; }
		
		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_0() { return cParamsParameterParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//commands+=GeneratorCommand*
		public Assignment getCommandsAssignment_6() { return cCommandsAssignment_6; }
		
		//GeneratorCommand
		public RuleCall getCommandsGeneratorCommandParserRuleCall_6_0() { return cCommandsGeneratorCommandParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class GeneratorCommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneratorCommand");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cForStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIfStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSwitchCaseParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cCollectionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPatternCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cPatternObjectCreationParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject bersetzen?
		//GeneratorCommand:
		//	ForStatement | IfStatement | SwitchCase | Collection | PatternCall | PatternObjectCreation;
		@Override public ParserRule getRule() { return rule; }
		
		////Only serves as super class for all possible commands within generator
		//ForStatement | IfStatement | SwitchCase | Collection | PatternCall | PatternObjectCreation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////Only serves as super class for all possible commands within generator
		//ForStatement
		public RuleCall getForStatementParserRuleCall_0() { return cForStatementParserRuleCall_0; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_1() { return cIfStatementParserRuleCall_1; }
		
		//SwitchCase
		public RuleCall getSwitchCaseParserRuleCall_2() { return cSwitchCaseParserRuleCall_2; }
		
		//Collection
		public RuleCall getCollectionParserRuleCall_3() { return cCollectionParserRuleCall_3; }
		
		//PatternCall
		public RuleCall getPatternCallParserRuleCall_4() { return cPatternCallParserRuleCall_4; }
		
		//PatternObjectCreation
		public RuleCall getPatternObjectCreationParserRuleCall_5() { return cPatternObjectCreationParserRuleCall_5; }
	}
	public class PatternObjectCreationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObjectCreation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPObjectAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPObjectPatternObjectParserRuleCall_0_0 = (RuleCall)cPObjectAssignment_0.eContents().get(0);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cPatternCallAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternCallPatternCallParserRuleCall_2_0 = (RuleCall)cPatternCallAssignment_2.eContents().get(0);
		
		//PatternObjectCreation:
		//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
		@Override public ParserRule getRule() { return rule; }
		
		//pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall
		public Group getGroup() { return cGroup; }
		
		//pObject=PatternObject
		public Assignment getPObjectAssignment_0() { return cPObjectAssignment_0; }
		
		//PatternObject
		public RuleCall getPObjectPatternObjectParserRuleCall_0_0() { return cPObjectPatternObjectParserRuleCall_0_0; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_1() { return cASSIGNMENT_OPTerminalRuleCall_1; }
		
		//patternCall=PatternCall
		public Assignment getPatternCallAssignment_2() { return cPatternCallAssignment_2; }
		
		//PatternCall
		public RuleCall getPatternCallPatternCallParserRuleCall_2_0() { return cPatternCallPatternCallParserRuleCall_2_0; }
	}
	public class PatternObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PatternObject");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypePatternCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypePatternIDTerminalRuleCall_0_0_1 = (RuleCall)cTypePatternCrossReference_0_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//PatternObject:
		//	type=[Pattern] name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[Pattern] name=ID
		public Group getGroup() { return cGroup; }
		
		//type=[Pattern]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[Pattern]
		public CrossReference getTypePatternCrossReference_0_0() { return cTypePatternCrossReference_0_0; }
		
		//ID
		public RuleCall getTypePatternIDTerminalRuleCall_0_0_1() { return cTypePatternIDTerminalRuleCall_0_0_1; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadForHeadParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyForBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ForStatement:
		//	'for' head=ForHead '{' body=ForBody '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'for' head=ForHead '{' body=ForBody '}'
		public Group getGroup() { return cGroup; }
		
		//'for'
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//head=ForHead
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//ForHead
		public RuleCall getHeadForHeadParserRuleCall_1_0() { return cHeadForHeadParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//body=ForBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//ForBody
		public RuleCall getBodyForBodyParserRuleCall_3_0() { return cBodyForBodyParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class ForHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForHead");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGeneralForHeadParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForEachHeadParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ForHead:
		//	GeneralForHead | ForEachHead;
		@Override public ParserRule getRule() { return rule; }
		
		//GeneralForHead | ForEachHead
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GeneralForHead
		public RuleCall getGeneralForHeadParserRuleCall_0() { return cGeneralForHeadParserRuleCall_0; }
		
		//ForEachHead
		public RuleCall getForEachHeadParserRuleCall_1() { return cForEachHeadParserRuleCall_1; }
	}
	public class GeneralForHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GeneralForHead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIteratorVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIteratorVarIDTerminalRuleCall_0_0 = (RuleCall)cIteratorVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRangeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRangeForRangeParserRuleCall_2_0 = (RuleCall)cRangeAssignment_2.eContents().get(0);
		
		//GeneralForHead:
		//	iteratorVar=ID 'in' range=ForRange;
		@Override public ParserRule getRule() { return rule; }
		
		//iteratorVar=ID 'in' range=ForRange
		public Group getGroup() { return cGroup; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_0() { return cIteratorVarAssignment_0; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_0_0() { return cIteratorVarIDTerminalRuleCall_0_0; }
		
		//'in'
		public Keyword getInKeyword_1() { return cInKeyword_1; }
		
		//range=ForRange
		public Assignment getRangeAssignment_2() { return cRangeAssignment_2; }
		
		//ForRange
		public RuleCall getRangeForRangeParserRuleCall_2_0() { return cRangeForRangeParserRuleCall_2_0; }
	}
	public class ForEachHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForEachHead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSrcAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSrcNodeOrParameterOrCollectionCrossReference_0_0 = (CrossReference)cSrcAssignment_0.eContents().get(0);
		private final RuleCall cSrcNodeOrParameterOrCollectionIDTerminalRuleCall_0_0_1 = (RuleCall)cSrcNodeOrParameterOrCollectionCrossReference_0_0.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRefAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRefEReferenceCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefEReferenceIDTerminalRuleCall_2_0_1 = (RuleCall)cRefEReferenceCrossReference_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIteratorVarAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIteratorVarIDTerminalRuleCall_4_0 = (RuleCall)cIteratorVarAssignment_4.eContents().get(0);
		
		//ForEachHead:
		//	src=[NodeOrParameterOrCollection] '-' ref=[ecore::EReference] '->' iteratorVar=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//src=[NodeOrParameterOrCollection] '-' ref=[ecore::EReference] '->' iteratorVar=ID
		public Group getGroup() { return cGroup; }
		
		//src=[NodeOrParameterOrCollection]
		public Assignment getSrcAssignment_0() { return cSrcAssignment_0; }
		
		//[NodeOrParameterOrCollection]
		public CrossReference getSrcNodeOrParameterOrCollectionCrossReference_0_0() { return cSrcNodeOrParameterOrCollectionCrossReference_0_0; }
		
		//ID
		public RuleCall getSrcNodeOrParameterOrCollectionIDTerminalRuleCall_0_0_1() { return cSrcNodeOrParameterOrCollectionIDTerminalRuleCall_0_0_1; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//ref=[ecore::EReference]
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//[ecore::EReference]
		public CrossReference getRefEReferenceCrossReference_2_0() { return cRefEReferenceCrossReference_2_0; }
		
		//ID
		public RuleCall getRefEReferenceIDTerminalRuleCall_2_0_1() { return cRefEReferenceIDTerminalRuleCall_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//iteratorVar=ID
		public Assignment getIteratorVarAssignment_4() { return cIteratorVarAssignment_4; }
		
		//ID
		public RuleCall getIteratorVarIDTerminalRuleCall_4_0() { return cIteratorVarIDTerminalRuleCall_4_0; }
	}
	public class NodeOrParameterOrCollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NodeOrParameterOrCollection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNodeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCollectionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//NodeOrParameterOrCollection:
		//	Node | Parameter | Collection;
		@Override public ParserRule getRule() { return rule; }
		
		//Node | Parameter | Collection
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Node
		public RuleCall getNodeParserRuleCall_0() { return cNodeParserRuleCall_0; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_1() { return cParameterParserRuleCall_1; }
		
		//Collection
		public RuleCall getCollectionParserRuleCall_2() { return cCollectionParserRuleCall_2; }
	}
	public class ForBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForBody");
		private final RuleCall cGenCommandBlockParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ForBody:
		//	GenCommandBlock;
		@Override public ParserRule getRule() { return rule; }
		
		//GenCommandBlock
		public RuleCall getGenCommandBlockParserRuleCall() { return cGenCommandBlockParserRuleCall; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfStatement");
		private final RuleCall cSingleLineIfParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//IfStatement:
		//	SingleLineIf //| BlockIf
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//SingleLineIf
		public RuleCall getSingleLineIfParserRuleCall() { return cSingleLineIfParserRuleCall; }
	}
	public class SingleLineIfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SingleLineIf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionArithmeticExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cCommandAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cCommandGeneratorCommandParserRuleCall_4_0 = (RuleCall)cCommandAssignment_4.eContents().get(0);
		
		//SingleLineIf:
		//	'if' '(' condition=ArithmeticExpression ')' command=GeneratorCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' '(' condition=ArithmeticExpression ')' command=GeneratorCommand
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//condition=ArithmeticExpression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//ArithmeticExpression
		public RuleCall getConditionArithmeticExpressionParserRuleCall_2_0() { return cConditionArithmeticExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//command=GeneratorCommand
		public Assignment getCommandAssignment_4() { return cCommandAssignment_4; }
		
		//GeneratorCommand
		public RuleCall getCommandGeneratorCommandParserRuleCall_4_0() { return cCommandGeneratorCommandParserRuleCall_4_0; }
	}
	public class GenCommandBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.GenCommandBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGenCommandBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommandsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommandsGeneratorCommandParserRuleCall_1_0 = (RuleCall)cCommandsAssignment_1.eContents().get(0);
		
		//GenCommandBlock:
		//	{GenCommandBlock} commands+=GeneratorCommand*;
		@Override public ParserRule getRule() { return rule; }
		
		//{GenCommandBlock} commands+=GeneratorCommand*
		public Group getGroup() { return cGroup; }
		
		//{GenCommandBlock}
		public Action getGenCommandBlockAction_0() { return cGenCommandBlockAction_0; }
		
		//commands+=GeneratorCommand*
		public Assignment getCommandsAssignment_1() { return cCommandsAssignment_1; }
		
		//GeneratorCommand
		public RuleCall getCommandsGeneratorCommandParserRuleCall_1_0() { return cCommandsGeneratorCommandParserRuleCall_1_0; }
	}
	public class BlockIfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.BlockIf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIfAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIfIfHeadAndBodyParserRuleCall_1_0 = (RuleCall)cIfAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cGroup_2.eContents().get(0);
		private final Keyword cElseKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Keyword cIfKeyword_2_0_1 = (Keyword)cGroup_2_0.eContents().get(1);
		private final Assignment cElseifsAssignment_2_0_2 = (Assignment)cGroup_2_0.eContents().get(2);
		private final RuleCall cElseifsIfHeadAndBodyParserRuleCall_2_0_2_0 = (RuleCall)cElseifsAssignment_2_0_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cElseKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cElseAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cElseIfBodyParserRuleCall_2_1_1_0 = (RuleCall)cElseAssignment_2_1_1.eContents().get(0);
		
		////TODO If-Recursion
		//BlockIf:
		//	'if' if=IfHeadAndBody (('else' 'if' elseifs+=IfHeadAndBody)* ('else' else=IfBody))?;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' if=IfHeadAndBody (('else' 'if' elseifs+=IfHeadAndBody)* ('else' else=IfBody))?
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//if=IfHeadAndBody
		public Assignment getIfAssignment_1() { return cIfAssignment_1; }
		
		//IfHeadAndBody
		public RuleCall getIfIfHeadAndBodyParserRuleCall_1_0() { return cIfIfHeadAndBodyParserRuleCall_1_0; }
		
		//(('else' 'if' elseifs+=IfHeadAndBody)* ('else' else=IfBody))?
		public Group getGroup_2() { return cGroup_2; }
		
		//('else' 'if' elseifs+=IfHeadAndBody)*
		public Group getGroup_2_0() { return cGroup_2_0; }
		
		//'else'
		public Keyword getElseKeyword_2_0_0() { return cElseKeyword_2_0_0; }
		
		//'if'
		public Keyword getIfKeyword_2_0_1() { return cIfKeyword_2_0_1; }
		
		//elseifs+=IfHeadAndBody
		public Assignment getElseifsAssignment_2_0_2() { return cElseifsAssignment_2_0_2; }
		
		//IfHeadAndBody
		public RuleCall getElseifsIfHeadAndBodyParserRuleCall_2_0_2_0() { return cElseifsIfHeadAndBodyParserRuleCall_2_0_2_0; }
		
		//('else' else=IfBody)
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'else'
		public Keyword getElseKeyword_2_1_0() { return cElseKeyword_2_1_0; }
		
		//else=IfBody
		public Assignment getElseAssignment_2_1_1() { return cElseAssignment_2_1_1; }
		
		//IfBody
		public RuleCall getElseIfBodyParserRuleCall_2_1_1_0() { return cElseIfBodyParserRuleCall_2_1_1_0; }
	}
	public class IfHeadAndBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfHeadAndBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadIfHeadParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyIfBodyParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//IfHeadAndBody:
		//	'(' head=IfHead ')' '{' body=IfBody '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' head=IfHead ')' '{' body=IfBody '}'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//head=IfHead
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//IfHead
		public RuleCall getHeadIfHeadParserRuleCall_1_0() { return cHeadIfHeadParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//body=IfBody
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }
		
		//IfBody
		public RuleCall getBodyIfBodyParserRuleCall_4_0() { return cBodyIfBodyParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class IfHeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfHead");
		private final Assignment cConditionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConditionArithmeticExpressionParserRuleCall_0 = (RuleCall)cConditionAssignment.eContents().get(0);
		
		//IfHead:
		//	condition=ArithmeticExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//condition=ArithmeticExpression
		public Assignment getConditionAssignment() { return cConditionAssignment; }
		
		//ArithmeticExpression
		public RuleCall getConditionArithmeticExpressionParserRuleCall_0() { return cConditionArithmeticExpressionParserRuleCall_0; }
	}
	public class IfBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.IfBody");
		private final Assignment cCommandsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCommandsGenCommandBlockParserRuleCall_0 = (RuleCall)cCommandsAssignment.eContents().get(0);
		
		//IfBody:
		//	commands=GenCommandBlock;
		@Override public ParserRule getRule() { return rule; }
		
		//commands=GenCommandBlock
		public Assignment getCommandsAssignment() { return cCommandsAssignment; }
		
		//GenCommandBlock
		public RuleCall getCommandsGenCommandBlockParserRuleCall_0() { return cCommandsGenCommandBlockParserRuleCall_0; }
	}
	public class SwitchCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SwitchCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAttributeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAttributeParameterRefOrMethodCallParserRuleCall_2_0 = (RuleCall)cAttributeAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCasesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCasesCaseParserRuleCall_5_0 = (RuleCall)cCasesAssignment_5.eContents().get(0);
		private final Assignment cDefaultAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cDefaultDefaultParserRuleCall_6_0 = (RuleCall)cDefaultAssignment_6.eContents().get(0);
		
		//SwitchCase:
		//	'switch' '(' attribute=ParameterRefOrMethodCall ')' '{' cases+=Case+ default=Default;
		@Override public ParserRule getRule() { return rule; }
		
		//'switch' '(' attribute=ParameterRefOrMethodCall ')' '{' cases+=Case+ default=Default
		public Group getGroup() { return cGroup; }
		
		//'switch'
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//attribute=ParameterRefOrMethodCall
		public Assignment getAttributeAssignment_2() { return cAttributeAssignment_2; }
		
		//ParameterRefOrMethodCall
		public RuleCall getAttributeParameterRefOrMethodCallParserRuleCall_2_0() { return cAttributeParameterRefOrMethodCallParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//cases+=Case+
		public Assignment getCasesAssignment_5() { return cCasesAssignment_5; }
		
		//Case
		public RuleCall getCasesCaseParserRuleCall_5_0() { return cCasesCaseParserRuleCall_5_0; }
		
		//default=Default
		public Assignment getDefaultAssignment_6() { return cDefaultAssignment_6; }
		
		//Default
		public RuleCall getDefaultDefaultParserRuleCall_6_0() { return cDefaultDefaultParserRuleCall_6_0; }
	}
	public class DefaultElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Default");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefaultKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cGeneratorCommandParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Default:
		//	'default' ':' GeneratorCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//'default' ':' GeneratorCommand
		public Group getGroup() { return cGroup; }
		
		//'default'
		public Keyword getDefaultKeyword_0() { return cDefaultKeyword_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//GeneratorCommand
		public RuleCall getGeneratorCommandParserRuleCall_2() { return cGeneratorCommandParserRuleCall_2; }
	}
	public class CaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Case");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValArithmeticExpressionParserRuleCall_1_0 = (RuleCall)cValAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyCaseBodyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//Case:
		//	'case' val=ArithmeticExpression ':' body=CaseBody;
		@Override public ParserRule getRule() { return rule; }
		
		//'case' val=ArithmeticExpression ':' body=CaseBody
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//val=ArithmeticExpression
		public Assignment getValAssignment_1() { return cValAssignment_1; }
		
		//ArithmeticExpression
		public RuleCall getValArithmeticExpressionParserRuleCall_1_0() { return cValArithmeticExpressionParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//body=CaseBody
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//CaseBody
		public RuleCall getBodyCaseBodyParserRuleCall_3_0() { return cBodyCaseBodyParserRuleCall_3_0; }
	}
	public class CaseBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.CaseBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cGenCommandBlockParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cGeneratorCommandParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//CaseBody:
		//	'{' GenCommandBlock '}' | GeneratorCommand;
		@Override public ParserRule getRule() { return rule; }
		
		//'{' GenCommandBlock '}' | GeneratorCommand
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'{' GenCommandBlock '}'
		public Group getGroup_0() { return cGroup_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_0_0() { return cLeftCurlyBracketKeyword_0_0; }
		
		//GenCommandBlock
		public RuleCall getGenCommandBlockParserRuleCall_0_1() { return cGenCommandBlockParserRuleCall_0_1; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_0_2() { return cRightCurlyBracketKeyword_0_2; }
		
		//GeneratorCommand
		public RuleCall getGeneratorCommandParserRuleCall_1() { return cGeneratorCommandParserRuleCall_1; }
	}
	public class CollectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Collection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cListParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMapParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Collection:
		//	List | Map;
		@Override public ParserRule getRule() { return rule; }
		
		//List | Map
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//List
		public RuleCall getListParserRuleCall_0() { return cListParserRuleCall_0; }
		
		//Map
		public RuleCall getMapParserRuleCall_1() { return cMapParserRuleCall_1; }
	}
	public class ListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.List");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cListKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cListAdHocParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//List:
		//	'List' name=ID (ASSIGNMENT_OP ListAdHoc);
		@Override public ParserRule getRule() { return rule; }
		
		//'List' name=ID (ASSIGNMENT_OP ListAdHoc)
		public Group getGroup() { return cGroup; }
		
		//'List'
		public Keyword getListKeyword_0() { return cListKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(ASSIGNMENT_OP ListAdHoc)
		public Group getGroup_2() { return cGroup_2; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_0() { return cASSIGNMENT_OPTerminalRuleCall_2_0; }
		
		//ListAdHoc
		public RuleCall getListAdHocParserRuleCall_2_1() { return cListAdHocParserRuleCall_2_1; }
	}
	public class ListAdHocElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ListAdHoc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsLiteralParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsLiteralParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ListAdHoc:
		//	'[' elements+=Literal (',' elements+=Literal)* ']' //TODO Allow empty lists? --> Probably have no purpose here since one will not be able to manipulate them, right?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'[' elements+=Literal (',' elements+=Literal)* ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//elements+=Literal
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }
		
		//Literal
		public RuleCall getElementsLiteralParserRuleCall_1_0() { return cElementsLiteralParserRuleCall_1_0; }
		
		//(',' elements+=Literal)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//elements+=Literal
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }
		
		//Literal
		public RuleCall getElementsLiteralParserRuleCall_2_1_0() { return cElementsLiteralParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.Map");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMapKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cASSIGNMENT_OPTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cMapAdHocParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		
		//Map:
		//	'Map' name=ID (ASSIGNMENT_OP MapAdHoc);
		@Override public ParserRule getRule() { return rule; }
		
		//'Map' name=ID (ASSIGNMENT_OP MapAdHoc)
		public Group getGroup() { return cGroup; }
		
		//'Map'
		public Keyword getMapKeyword_0() { return cMapKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//(ASSIGNMENT_OP MapAdHoc)
		public Group getGroup_2() { return cGroup_2; }
		
		//ASSIGNMENT_OP
		public RuleCall getASSIGNMENT_OPTerminalRuleCall_2_0() { return cASSIGNMENT_OPTerminalRuleCall_2_0; }
		
		//MapAdHoc
		public RuleCall getMapAdHocParserRuleCall_2_1() { return cMapAdHocParserRuleCall_2_1; }
	}
	public class MapAdHocElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MapAdHoc");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEntriesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntriesMapTupelParserRuleCall_1_0 = (RuleCall)cEntriesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cEntriesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cEntriesMapTupelParserRuleCall_2_1_0 = (RuleCall)cEntriesAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MapAdHoc:
		//	'[' entries+=MapTupel (',' entries+=MapTupel)* ']';
		@Override public ParserRule getRule() { return rule; }
		
		//'[' entries+=MapTupel (',' entries+=MapTupel)* ']'
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//entries+=MapTupel
		public Assignment getEntriesAssignment_1() { return cEntriesAssignment_1; }
		
		//MapTupel
		public RuleCall getEntriesMapTupelParserRuleCall_1_0() { return cEntriesMapTupelParserRuleCall_1_0; }
		
		//(',' entries+=MapTupel)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//entries+=MapTupel
		public Assignment getEntriesAssignment_2_1() { return cEntriesAssignment_2_1; }
		
		//MapTupel
		public RuleCall getEntriesMapTupelParserRuleCall_2_1_0() { return cEntriesMapTupelParserRuleCall_2_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}
	public class MapTupelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MapTupel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cKeyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKeyLiteralParserRuleCall_1_0 = (RuleCall)cKeyAssignment_1.eContents().get(0);
		private final Keyword cCommaKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueArithmeticExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MapTupel:
		//	'(' key=Literal ',' value=ArithmeticExpression ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' key=Literal ',' value=ArithmeticExpression ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//key=Literal
		public Assignment getKeyAssignment_1() { return cKeyAssignment_1; }
		
		//Literal
		public RuleCall getKeyLiteralParserRuleCall_1_0() { return cKeyLiteralParserRuleCall_1_0; }
		
		//','
		public Keyword getCommaKeyword_2() { return cCommaKeyword_2; }
		
		//value=ArithmeticExpression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//ArithmeticExpression
		public RuleCall getValueArithmeticExpressionParserRuleCall_3_0() { return cValueArithmeticExpressionParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ForRangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ForRange");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStartINTTerminalRuleCall_0_0 = (RuleCall)cStartAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEndAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cEndINTTerminalRuleCall_2_0 = (RuleCall)cEndAssignment_2.eContents().get(0);
		
		//ForRange:
		//	start=INT ':' end=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//start=INT ':' end=INT
		public Group getGroup() { return cGroup; }
		
		//start=INT
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//INT
		public RuleCall getStartINTTerminalRuleCall_0_0() { return cStartINTTerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//end=INT
		public Assignment getEndAssignment_2() { return cEndAssignment_2; }
		
		//INT
		public RuleCall getEndINTTerminalRuleCall_2_0() { return cEndINTTerminalRuleCall_2_0; }
	}
	
	public class MathFuncElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.MathFunc");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSQRTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSQRTSqrtKeyword_0_0 = (Keyword)cSQRTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cABSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cABSAbsKeyword_1_0 = (Keyword)cABSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MathFunc:
		//	SQRT='sqrt' | ABS='abs';
		public EnumRule getRule() { return rule; }
		
		//SQRT='sqrt' | ABS='abs'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SQRT='sqrt'
		public EnumLiteralDeclaration getSQRTEnumLiteralDeclaration_0() { return cSQRTEnumLiteralDeclaration_0; }
		
		//'sqrt'
		public Keyword getSQRTSqrtKeyword_0_0() { return cSQRTSqrtKeyword_0_0; }
		
		//ABS='abs'
		public EnumLiteralDeclaration getABSEnumLiteralDeclaration_1() { return cABSEnumLiteralDeclaration_1; }
		
		//'abs'
		public Keyword getABSAbsKeyword_1_0() { return cABSAbsKeyword_1_0; }
	}
	public class PrimitiveTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINTIntKeyword_0_0 = (Keyword)cINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCHAREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCHARCharKeyword_1_0 = (Keyword)cCHAREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDOUBLEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDOUBLEDoubleKeyword_2_0 = (Keyword)cDOUBLEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSTRINGEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSTRINGStringKeyword_3_0 = (Keyword)cSTRINGEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum PrimitiveType:
		//	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' //TODO: String as Primitive? (and therefore also better lowercase?)
		//;
		public EnumRule getRule() { return rule; }
		
		//INT='int' | CHAR='char' | DOUBLE='double' | STRING='String'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT='int'
		public EnumLiteralDeclaration getINTEnumLiteralDeclaration_0() { return cINTEnumLiteralDeclaration_0; }
		
		//'int'
		public Keyword getINTIntKeyword_0_0() { return cINTIntKeyword_0_0; }
		
		//CHAR='char'
		public EnumLiteralDeclaration getCHAREnumLiteralDeclaration_1() { return cCHAREnumLiteralDeclaration_1; }
		
		//'char'
		public Keyword getCHARCharKeyword_1_0() { return cCHARCharKeyword_1_0; }
		
		//DOUBLE='double'
		public EnumLiteralDeclaration getDOUBLEEnumLiteralDeclaration_2() { return cDOUBLEEnumLiteralDeclaration_2; }
		
		//'double'
		public Keyword getDOUBLEDoubleKeyword_2_0() { return cDOUBLEDoubleKeyword_2_0; }
		
		//STRING='String'
		public EnumLiteralDeclaration getSTRINGEnumLiteralDeclaration_3() { return cSTRINGEnumLiteralDeclaration_3; }
		
		//'String'
		public Keyword getSTRINGStringKeyword_3_0() { return cSTRINGStringKeyword_3_0; }
	}
	public class RelationalOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.RelationalOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGREATER_OR_EQUALEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cGREATER_OR_EQUALEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cUNEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cUNEQUALExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cUNEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLER_OR_EQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0 = (Keyword)cSMALLER_OR_EQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cSMALLEREnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cSMALLERLessThanSignKeyword_5_0 = (Keyword)cSMALLEREnumLiteralDeclaration_5.eContents().get(0);
		
		//enum RelationalOp:
		//	GREATER='>' |
		//	GREATER_OR_EQUAL='>=' |
		//	EQUAL='==' |
		//	UNEQUAL='!=' |
		//	SMALLER_OR_EQUAL='<=' |
		//	SMALLER='<';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' | GREATER_OR_EQUAL='>=' | EQUAL='==' | UNEQUAL='!=' | SMALLER_OR_EQUAL='<=' | SMALLER='<'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//GREATER_OR_EQUAL='>='
		public EnumLiteralDeclaration getGREATER_OR_EQUALEnumLiteralDeclaration_1() { return cGREATER_OR_EQUALEnumLiteralDeclaration_1; }
		
		//'>='
		public Keyword getGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0() { return cGREATER_OR_EQUALGreaterThanSignEqualsSignKeyword_1_0; }
		
		//EQUAL='=='
		public EnumLiteralDeclaration getEQUALEnumLiteralDeclaration_2() { return cEQUALEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALEqualsSignEqualsSignKeyword_2_0() { return cEQUALEqualsSignEqualsSignKeyword_2_0; }
		
		//UNEQUAL='!='
		public EnumLiteralDeclaration getUNEQUALEnumLiteralDeclaration_3() { return cUNEQUALEnumLiteralDeclaration_3; }
		
		//'!='
		public Keyword getUNEQUALExclamationMarkEqualsSignKeyword_3_0() { return cUNEQUALExclamationMarkEqualsSignKeyword_3_0; }
		
		//SMALLER_OR_EQUAL='<='
		public EnumLiteralDeclaration getSMALLER_OR_EQUALEnumLiteralDeclaration_4() { return cSMALLER_OR_EQUALEnumLiteralDeclaration_4; }
		
		//'<='
		public Keyword getSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0() { return cSMALLER_OR_EQUALLessThanSignEqualsSignKeyword_4_0; }
		
		//SMALLER='<'
		public EnumLiteralDeclaration getSMALLEREnumLiteralDeclaration_5() { return cSMALLEREnumLiteralDeclaration_5; }
		
		//'<'
		public Keyword getSMALLERLessThanSignKeyword_5_0() { return cSMALLERLessThanSignKeyword_5_0; }
	}
	public class TertiaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TertiaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cORVerticalLineVerticalLineKeyword_2_0 = (Keyword)cOREnumLiteralDeclaration_2.eContents().get(0);
		
		//enum TertiaryOp:
		//	PLUS='+' |
		//	MINUS='-' |
		//	OR='||';
		public EnumRule getRule() { return rule; }
		
		//PLUS='+' | MINUS='-' | OR='||'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS='+'
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }
		
		//MINUS='-'
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
		
		//OR='||'
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_2() { return cOREnumLiteralDeclaration_2; }
		
		//'||'
		public Keyword getORVerticalLineVerticalLineKeyword_2_0() { return cORVerticalLineVerticalLineKeyword_2_0; }
	}
	public class SecondaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.SecondaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMODPercentSignKeyword_0_0 = (Keyword)cMODEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cXORCircumflexAccentKeyword_1_0 = (Keyword)cXOREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum SecondaryOp:
		//	MOD='%' |
		//	XOR='^';
		public EnumRule getRule() { return rule; }
		
		//MOD='%' | XOR='^'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MOD='%'
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_0() { return cMODEnumLiteralDeclaration_0; }
		
		//'%'
		public Keyword getMODPercentSignKeyword_0_0() { return cMODPercentSignKeyword_0_0; }
		
		//XOR='^'
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_1() { return cXOREnumLiteralDeclaration_1; }
		
		//'^'
		public Keyword getXORCircumflexAccentKeyword_1_0() { return cXORCircumflexAccentKeyword_1_0; }
	}
	public class PrimaryOpElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.PrimaryOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULAsteriskKeyword_0_0 = (Keyword)cMULEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cANDAmpersandAmpersandKeyword_2_0 = (Keyword)cANDEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PrimaryOp:
		//	MUL='*' |
		//	DIV='/' |
		//	AND='&&';
		public EnumRule getRule() { return rule; }
		
		//MUL='*' | DIV='/' | AND='&&'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MUL='*'
		public EnumLiteralDeclaration getMULEnumLiteralDeclaration_0() { return cMULEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMULAsteriskKeyword_0_0() { return cMULAsteriskKeyword_0_0; }
		
		//DIV='/'
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
		
		//AND='&&'
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_2() { return cANDEnumLiteralDeclaration_2; }
		
		//'&&'
		public Keyword getANDAmpersandAmpersandKeyword_2_0() { return cANDAmpersandAmpersandKeyword_2_0; }
	}
	
	private final MofgenFileElements pMofgenFile;
	private final ImportElements pImport;
	private final PatternElements pPattern;
	private final PatternReturnElements pPatternReturn;
	private final ParamManipulationElements pParamManipulation;
	private final NodeElements pNode;
	private final NodeContentElements pNodeContent;
	private final PatternCallElements pPatternCall;
	private final NodeReferenceOrAssignmentElements pNodeReferenceOrAssignment;
	private final PatternNodeReferenceElements pPatternNodeReference;
	private final AssignmentElements pAssignment;
	private final NodeAttributeCallElements pNodeAttributeCall;
	private final ParameterElements pParameter;
	private final PrimitiveParameterElements pPrimitiveParameter;
	private final ParameterNodeElements pParameterNode;
	private final ParameterRefOrMethodCallElements pParameterRefOrMethodCall;
	private final ParameterRefElements pParameterRef;
	private final MethodCallElements pMethodCall;
	private final ArithmeticExpressionElements pArithmeticExpression;
	private final TertiaryExpressionElements pTertiaryExpression;
	private final SecondaryExpressionElements pSecondaryExpression;
	private final PrimaryExprElements pPrimaryExpr;
	private final RelationExpressionElements pRelationExpression;
	private final BaseExprElements pBaseExpr;
	private final LiteralElements pLiteral;
	private final BooleanLiteralElements pBooleanLiteral;
	private final StringLiteralElements pStringLiteral;
	private final NumberLiteralElements pNumberLiteral;
	private final MathFuncElements eMathFunc;
	private final PrimitiveTypeElements ePrimitiveType;
	private final GeneratorElements pGenerator;
	private final GeneratorCommandElements pGeneratorCommand;
	private final PatternObjectCreationElements pPatternObjectCreation;
	private final PatternObjectElements pPatternObject;
	private final ForStatementElements pForStatement;
	private final ForHeadElements pForHead;
	private final GeneralForHeadElements pGeneralForHead;
	private final ForEachHeadElements pForEachHead;
	private final NodeOrParameterOrCollectionElements pNodeOrParameterOrCollection;
	private final ForBodyElements pForBody;
	private final IfStatementElements pIfStatement;
	private final SingleLineIfElements pSingleLineIf;
	private final GenCommandBlockElements pGenCommandBlock;
	private final BlockIfElements pBlockIf;
	private final IfHeadAndBodyElements pIfHeadAndBody;
	private final IfHeadElements pIfHead;
	private final IfBodyElements pIfBody;
	private final SwitchCaseElements pSwitchCase;
	private final DefaultElements pDefault;
	private final CaseElements pCase;
	private final CaseBodyElements pCaseBody;
	private final CollectionElements pCollection;
	private final ListElements pList;
	private final ListAdHocElements pListAdHoc;
	private final MapElements pMap;
	private final MapAdHocElements pMapAdHoc;
	private final MapTupelElements pMapTupel;
	private final ForRangeElements pForRange;
	private final TerminalRule tTRUE;
	private final TerminalRule tFALSE;
	private final RelationalOpElements eRelationalOp;
	private final TertiaryOpElements eTertiaryOp;
	private final SecondaryOpElements eSecondaryOp;
	private final PrimaryOpElements ePrimaryOp;
	private final TerminalRule tASSIGNMENT_OP;
	private final TerminalRule tNEWLINE;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MGLangGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMofgenFile = new MofgenFileElements();
		this.pImport = new ImportElements();
		this.pPattern = new PatternElements();
		this.pPatternReturn = new PatternReturnElements();
		this.pParamManipulation = new ParamManipulationElements();
		this.pNode = new NodeElements();
		this.pNodeContent = new NodeContentElements();
		this.pPatternCall = new PatternCallElements();
		this.pNodeReferenceOrAssignment = new NodeReferenceOrAssignmentElements();
		this.pPatternNodeReference = new PatternNodeReferenceElements();
		this.pAssignment = new AssignmentElements();
		this.pNodeAttributeCall = new NodeAttributeCallElements();
		this.pParameter = new ParameterElements();
		this.pPrimitiveParameter = new PrimitiveParameterElements();
		this.pParameterNode = new ParameterNodeElements();
		this.pParameterRefOrMethodCall = new ParameterRefOrMethodCallElements();
		this.pParameterRef = new ParameterRefElements();
		this.pMethodCall = new MethodCallElements();
		this.pArithmeticExpression = new ArithmeticExpressionElements();
		this.pTertiaryExpression = new TertiaryExpressionElements();
		this.pSecondaryExpression = new SecondaryExpressionElements();
		this.pPrimaryExpr = new PrimaryExprElements();
		this.pRelationExpression = new RelationExpressionElements();
		this.pBaseExpr = new BaseExprElements();
		this.pLiteral = new LiteralElements();
		this.pBooleanLiteral = new BooleanLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pNumberLiteral = new NumberLiteralElements();
		this.eMathFunc = new MathFuncElements();
		this.ePrimitiveType = new PrimitiveTypeElements();
		this.pGenerator = new GeneratorElements();
		this.pGeneratorCommand = new GeneratorCommandElements();
		this.pPatternObjectCreation = new PatternObjectCreationElements();
		this.pPatternObject = new PatternObjectElements();
		this.pForStatement = new ForStatementElements();
		this.pForHead = new ForHeadElements();
		this.pGeneralForHead = new GeneralForHeadElements();
		this.pForEachHead = new ForEachHeadElements();
		this.pNodeOrParameterOrCollection = new NodeOrParameterOrCollectionElements();
		this.pForBody = new ForBodyElements();
		this.pIfStatement = new IfStatementElements();
		this.pSingleLineIf = new SingleLineIfElements();
		this.pGenCommandBlock = new GenCommandBlockElements();
		this.pBlockIf = new BlockIfElements();
		this.pIfHeadAndBody = new IfHeadAndBodyElements();
		this.pIfHead = new IfHeadElements();
		this.pIfBody = new IfBodyElements();
		this.pSwitchCase = new SwitchCaseElements();
		this.pDefault = new DefaultElements();
		this.pCase = new CaseElements();
		this.pCaseBody = new CaseBodyElements();
		this.pCollection = new CollectionElements();
		this.pList = new ListElements();
		this.pListAdHoc = new ListAdHocElements();
		this.pMap = new MapElements();
		this.pMapAdHoc = new MapAdHocElements();
		this.pMapTupel = new MapTupelElements();
		this.pForRange = new ForRangeElements();
		this.tTRUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.TRUE");
		this.tFALSE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.FALSE");
		this.eRelationalOp = new RelationalOpElements();
		this.eTertiaryOp = new TertiaryOpElements();
		this.eSecondaryOp = new SecondaryOpElements();
		this.ePrimaryOp = new PrimaryOpElements();
		this.tASSIGNMENT_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.ASSIGNMENT_OP");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.mofgen.MGLang.NEWLINE");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.mofgen.MGLang".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//MofgenFile:
	//	imports+=Import* (patterns+=Pattern | generators+=Generator)*;
	public MofgenFileElements getMofgenFileAccess() {
		return pMofgenFile;
	}
	
	public ParserRule getMofgenFileRule() {
		return getMofgenFileAccess().getRule();
	}
	
	//Import:
	//	'import' name=STRING 'as' alias=ID;
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//Pattern: //(abstract?='abstract')? // 'Abstract' necessary? TODO
	//	'pattern' name=ID ('(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')') '{' (colls+=Collection* &
	//	nodes+=Node* & paramManipulations+=ParamManipulation*) '}' return=PatternReturn?;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternReturn:
	//	{PatternReturn} 'return' 'this' ('.' returnValue=[Node])?;
	public PatternReturnElements getPatternReturnAccess() {
		return pPatternReturn;
	}
	
	public ParserRule getPatternReturnRule() {
		return getPatternReturnAccess().getRule();
	}
	
	//ParamManipulation:
	//	param=[ParameterNode] content=NodeContent;
	public ParamManipulationElements getParamManipulationAccess() {
		return pParamManipulation;
	}
	
	public ParserRule getParamManipulationRule() {
		return getParamManipulationAccess().getRule();
	}
	
	//Node:
	//	type=[ecore::EClass] name=ID (createdBy=NodeContent | ASSIGNMENT_OP createdBy=PatternCall)?;
	public NodeElements getNodeAccess() {
		return pNode;
	}
	
	public ParserRule getNodeRule() {
		return getNodeAccess().getRule();
	}
	
	//NodeContent:
	//	{NodeContent} '{' refsAssigns+=NodeReferenceOrAssignment* '}';
	public NodeContentElements getNodeContentAccess() {
		return pNodeContent;
	}
	
	public ParserRule getNodeContentRule() {
		return getNodeContentAccess().getRule();
	}
	
	//PatternCall:
	//	called=[Pattern] '(' params+=ArithmeticExpression* ')';
	public PatternCallElements getPatternCallAccess() {
		return pPatternCall;
	}
	
	public ParserRule getPatternCallRule() {
		return getPatternCallAccess().getRule();
	}
	
	//NodeReferenceOrAssignment:
	//	(PatternNodeReference | Assignment) ('[' condition=ArithmeticExpression ']')?;
	public NodeReferenceOrAssignmentElements getNodeReferenceOrAssignmentAccess() {
		return pNodeReferenceOrAssignment;
	}
	
	public ParserRule getNodeReferenceOrAssignmentRule() {
		return getNodeReferenceOrAssignmentAccess().getRule();
	}
	
	//PatternNodeReference:
	//	type=[ecore::EReference] '->' target=[Node];
	public PatternNodeReferenceElements getPatternNodeReferenceAccess() {
		return pPatternNodeReference;
	}
	
	public ParserRule getPatternNodeReferenceRule() {
		return getPatternNodeReferenceAccess().getRule();
	}
	
	//Assignment:
	//	target=[ecore::EAttribute] ASSIGNMENT_OP value=ArithmeticExpression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	////TODO make Enum Assignments possible
	//NodeAttributeCall:
	//	node=[Node] '.' attribute=[ecore::EAttribute];
	public NodeAttributeCallElements getNodeAttributeCallAccess() {
		return pNodeAttributeCall;
	}
	
	public ParserRule getNodeAttributeCallRule() {
		return getNodeAttributeCallAccess().getRule();
	}
	
	//Parameter:
	//	PrimitiveParameter | ParameterNode;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//PrimitiveParameter:
	//	type=PrimitiveType name=ID;
	public PrimitiveParameterElements getPrimitiveParameterAccess() {
		return pPrimitiveParameter;
	}
	
	public ParserRule getPrimitiveParameterRule() {
		return getPrimitiveParameterAccess().getRule();
	}
	
	//ParameterNode:
	//	type=[ecore::EClassifier] name=ID;
	public ParameterNodeElements getParameterNodeAccess() {
		return pParameterNode;
	}
	
	public ParserRule getParameterNodeRule() {
		return getParameterNodeAccess().getRule();
	}
	
	//ParameterRefOrMethodCall:
	//	ParameterRef | MethodCall;
	public ParameterRefOrMethodCallElements getParameterRefOrMethodCallAccess() {
		return pParameterRefOrMethodCall;
	}
	
	public ParserRule getParameterRefOrMethodCallRule() {
		return getParameterRefOrMethodCallAccess().getRule();
	}
	
	//ParameterRef:
	//	ref=[Parameter];
	public ParameterRefElements getParameterRefAccess() {
		return pParameterRef;
	}
	
	public ParserRule getParameterRefRule() {
		return getParameterRefAccess().getRule();
	}
	
	//MethodCall:
	//	calledNode=[Node] '.' method=[ecore::EOperation];
	public MethodCallElements getMethodCallAccess() {
		return pMethodCall;
	}
	
	public ParserRule getMethodCallRule() {
		return getMethodCallAccess().getRule();
	}
	
	//ArithmeticExpression:
	//	TertiaryExpression;
	public ArithmeticExpressionElements getArithmeticExpressionAccess() {
		return pArithmeticExpression;
	}
	
	public ParserRule getArithmeticExpressionRule() {
		return getArithmeticExpressionAccess().getRule();
	}
	
	//TertiaryExpression ArithmeticExpression:
	//	SecondaryExpression ({Tertiary.left=current} op=TertiaryOp right=SecondaryExpression)*;
	public TertiaryExpressionElements getTertiaryExpressionAccess() {
		return pTertiaryExpression;
	}
	
	public ParserRule getTertiaryExpressionRule() {
		return getTertiaryExpressionAccess().getRule();
	}
	
	//SecondaryExpression ArithmeticExpression:
	//	PrimaryExpr ({Secondary.left=current} op=SecondaryOp right=PrimaryExpr)*;
	public SecondaryExpressionElements getSecondaryExpressionAccess() {
		return pSecondaryExpression;
	}
	
	public ParserRule getSecondaryExpressionRule() {
		return getSecondaryExpressionAccess().getRule();
	}
	
	//PrimaryExpr ArithmeticExpression:
	//	RelationExpression ({Primary.left=current} op=PrimaryOp right=RelationExpression)*;
	public PrimaryExprElements getPrimaryExprAccess() {
		return pPrimaryExpr;
	}
	
	public ParserRule getPrimaryExprRule() {
		return getPrimaryExprAccess().getRule();
	}
	
	//RelationExpression ArithmeticExpression:
	//	BaseExpr ({Rel.left=current} relation=RelationalOp right=BaseExpr)*;
	public RelationExpressionElements getRelationExpressionAccess() {
		return pRelationExpression;
	}
	
	public ParserRule getRelationExpressionRule() {
		return getRelationExpressionAccess().getRule();
	}
	
	//BaseExpr ArithmeticExpression:
	//	'(' ArithmeticExpression ')' | {NegationExpression} '!' expr=BaseExpr | {FunctionCall} func=MathFunc '('
	//	expr=ArithmeticExpression ')' | {Literal} Literal | ParameterRefOrMethodCall;
	public BaseExprElements getBaseExprAccess() {
		return pBaseExpr;
	}
	
	public ParserRule getBaseExprRule() {
		return getBaseExprAccess().getRule();
	}
	
	//Literal:
	//	BooleanLiteral | StringLiteral | NumberLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//BooleanLiteral ecore::EBoolean:
	//	TRUE | FALSE;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return pBooleanLiteral;
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}
	
	//StringLiteral:
	//	STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//NumberLiteral ecore::EDouble:
	//	INT ('.' INT)?;
	public NumberLiteralElements getNumberLiteralAccess() {
		return pNumberLiteral;
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}
	
	//enum MathFunc:
	//	SQRT='sqrt' | ABS='abs';
	public MathFuncElements getMathFuncAccess() {
		return eMathFunc;
	}
	
	public EnumRule getMathFuncRule() {
		return getMathFuncAccess().getRule();
	}
	
	//enum PrimitiveType:
	//	INT='int' | CHAR='char' | DOUBLE='double' | STRING='String' //TODO: String as Primitive? (and therefore also better lowercase?)
	//;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return ePrimitiveType;
	}
	
	public EnumRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}
	
	//Generator:
	//	{Generator} 'gen' '('
	//	params+=Parameter*
	//	')' '{' commands+=GeneratorCommand* '}';
	public GeneratorElements getGeneratorAccess() {
		return pGenerator;
	}
	
	public ParserRule getGeneratorRule() {
		return getGeneratorAccess().getRule();
	}
	
	////TODO Wie hier patterns wie "examplePattern" und PatternObjects dazu mittels "ExamplePattern" ermglichen? Eventuell in Scoping einklinken, alle Patterns holen und dann in PatternObject bersetzen?
	//GeneratorCommand:
	//	ForStatement | IfStatement | SwitchCase | Collection | PatternCall | PatternObjectCreation;
	public GeneratorCommandElements getGeneratorCommandAccess() {
		return pGeneratorCommand;
	}
	
	public ParserRule getGeneratorCommandRule() {
		return getGeneratorCommandAccess().getRule();
	}
	
	//PatternObjectCreation:
	//	pObject=PatternObject ASSIGNMENT_OP patternCall=PatternCall;
	public PatternObjectCreationElements getPatternObjectCreationAccess() {
		return pPatternObjectCreation;
	}
	
	public ParserRule getPatternObjectCreationRule() {
		return getPatternObjectCreationAccess().getRule();
	}
	
	//PatternObject:
	//	type=[Pattern] name=ID;
	public PatternObjectElements getPatternObjectAccess() {
		return pPatternObject;
	}
	
	public ParserRule getPatternObjectRule() {
		return getPatternObjectAccess().getRule();
	}
	
	//ForStatement:
	//	'for' head=ForHead '{' body=ForBody '}';
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}
	
	//ForHead:
	//	GeneralForHead | ForEachHead;
	public ForHeadElements getForHeadAccess() {
		return pForHead;
	}
	
	public ParserRule getForHeadRule() {
		return getForHeadAccess().getRule();
	}
	
	//GeneralForHead:
	//	iteratorVar=ID 'in' range=ForRange;
	public GeneralForHeadElements getGeneralForHeadAccess() {
		return pGeneralForHead;
	}
	
	public ParserRule getGeneralForHeadRule() {
		return getGeneralForHeadAccess().getRule();
	}
	
	//ForEachHead:
	//	src=[NodeOrParameterOrCollection] '-' ref=[ecore::EReference] '->' iteratorVar=ID;
	public ForEachHeadElements getForEachHeadAccess() {
		return pForEachHead;
	}
	
	public ParserRule getForEachHeadRule() {
		return getForEachHeadAccess().getRule();
	}
	
	//NodeOrParameterOrCollection:
	//	Node | Parameter | Collection;
	public NodeOrParameterOrCollectionElements getNodeOrParameterOrCollectionAccess() {
		return pNodeOrParameterOrCollection;
	}
	
	public ParserRule getNodeOrParameterOrCollectionRule() {
		return getNodeOrParameterOrCollectionAccess().getRule();
	}
	
	//ForBody:
	//	GenCommandBlock;
	public ForBodyElements getForBodyAccess() {
		return pForBody;
	}
	
	public ParserRule getForBodyRule() {
		return getForBodyAccess().getRule();
	}
	
	//IfStatement:
	//	SingleLineIf //| BlockIf
	//;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//SingleLineIf:
	//	'if' '(' condition=ArithmeticExpression ')' command=GeneratorCommand;
	public SingleLineIfElements getSingleLineIfAccess() {
		return pSingleLineIf;
	}
	
	public ParserRule getSingleLineIfRule() {
		return getSingleLineIfAccess().getRule();
	}
	
	//GenCommandBlock:
	//	{GenCommandBlock} commands+=GeneratorCommand*;
	public GenCommandBlockElements getGenCommandBlockAccess() {
		return pGenCommandBlock;
	}
	
	public ParserRule getGenCommandBlockRule() {
		return getGenCommandBlockAccess().getRule();
	}
	
	////TODO If-Recursion
	//BlockIf:
	//	'if' if=IfHeadAndBody (('else' 'if' elseifs+=IfHeadAndBody)* ('else' else=IfBody))?;
	public BlockIfElements getBlockIfAccess() {
		return pBlockIf;
	}
	
	public ParserRule getBlockIfRule() {
		return getBlockIfAccess().getRule();
	}
	
	//IfHeadAndBody:
	//	'(' head=IfHead ')' '{' body=IfBody '}';
	public IfHeadAndBodyElements getIfHeadAndBodyAccess() {
		return pIfHeadAndBody;
	}
	
	public ParserRule getIfHeadAndBodyRule() {
		return getIfHeadAndBodyAccess().getRule();
	}
	
	//IfHead:
	//	condition=ArithmeticExpression;
	public IfHeadElements getIfHeadAccess() {
		return pIfHead;
	}
	
	public ParserRule getIfHeadRule() {
		return getIfHeadAccess().getRule();
	}
	
	//IfBody:
	//	commands=GenCommandBlock;
	public IfBodyElements getIfBodyAccess() {
		return pIfBody;
	}
	
	public ParserRule getIfBodyRule() {
		return getIfBodyAccess().getRule();
	}
	
	//SwitchCase:
	//	'switch' '(' attribute=ParameterRefOrMethodCall ')' '{' cases+=Case+ default=Default;
	public SwitchCaseElements getSwitchCaseAccess() {
		return pSwitchCase;
	}
	
	public ParserRule getSwitchCaseRule() {
		return getSwitchCaseAccess().getRule();
	}
	
	//Default:
	//	'default' ':' GeneratorCommand;
	public DefaultElements getDefaultAccess() {
		return pDefault;
	}
	
	public ParserRule getDefaultRule() {
		return getDefaultAccess().getRule();
	}
	
	//Case:
	//	'case' val=ArithmeticExpression ':' body=CaseBody;
	public CaseElements getCaseAccess() {
		return pCase;
	}
	
	public ParserRule getCaseRule() {
		return getCaseAccess().getRule();
	}
	
	//CaseBody:
	//	'{' GenCommandBlock '}' | GeneratorCommand;
	public CaseBodyElements getCaseBodyAccess() {
		return pCaseBody;
	}
	
	public ParserRule getCaseBodyRule() {
		return getCaseBodyAccess().getRule();
	}
	
	//Collection:
	//	List | Map;
	public CollectionElements getCollectionAccess() {
		return pCollection;
	}
	
	public ParserRule getCollectionRule() {
		return getCollectionAccess().getRule();
	}
	
	//List:
	//	'List' name=ID (ASSIGNMENT_OP ListAdHoc);
	public ListElements getListAccess() {
		return pList;
	}
	
	public ParserRule getListRule() {
		return getListAccess().getRule();
	}
	
	//ListAdHoc:
	//	'[' elements+=Literal (',' elements+=Literal)* ']' //TODO Allow empty lists? --> Probably have no purpose here since one will not be able to manipulate them, right?
	//;
	public ListAdHocElements getListAdHocAccess() {
		return pListAdHoc;
	}
	
	public ParserRule getListAdHocRule() {
		return getListAdHocAccess().getRule();
	}
	
	//Map:
	//	'Map' name=ID (ASSIGNMENT_OP MapAdHoc);
	public MapElements getMapAccess() {
		return pMap;
	}
	
	public ParserRule getMapRule() {
		return getMapAccess().getRule();
	}
	
	//MapAdHoc:
	//	'[' entries+=MapTupel (',' entries+=MapTupel)* ']';
	public MapAdHocElements getMapAdHocAccess() {
		return pMapAdHoc;
	}
	
	public ParserRule getMapAdHocRule() {
		return getMapAdHocAccess().getRule();
	}
	
	//MapTupel:
	//	'(' key=Literal ',' value=ArithmeticExpression ')';
	public MapTupelElements getMapTupelAccess() {
		return pMapTupel;
	}
	
	public ParserRule getMapTupelRule() {
		return getMapTupelAccess().getRule();
	}
	
	//ForRange:
	//	start=INT ':' end=INT;
	public ForRangeElements getForRangeAccess() {
		return pForRange;
	}
	
	public ParserRule getForRangeRule() {
		return getForRangeAccess().getRule();
	}
	
	//terminal TRUE returns ecore::EBoolean:
	//	'true';
	public TerminalRule getTRUERule() {
		return tTRUE;
	}
	
	//terminal FALSE returns ecore::EBoolean:
	//	'false';
	public TerminalRule getFALSERule() {
		return tFALSE;
	}
	
	//enum RelationalOp:
	//	GREATER='>' |
	//	GREATER_OR_EQUAL='>=' |
	//	EQUAL='==' |
	//	UNEQUAL='!=' |
	//	SMALLER_OR_EQUAL='<=' |
	//	SMALLER='<';
	public RelationalOpElements getRelationalOpAccess() {
		return eRelationalOp;
	}
	
	public EnumRule getRelationalOpRule() {
		return getRelationalOpAccess().getRule();
	}
	
	//enum TertiaryOp:
	//	PLUS='+' |
	//	MINUS='-' |
	//	OR='||';
	public TertiaryOpElements getTertiaryOpAccess() {
		return eTertiaryOp;
	}
	
	public EnumRule getTertiaryOpRule() {
		return getTertiaryOpAccess().getRule();
	}
	
	//enum SecondaryOp:
	//	MOD='%' |
	//	XOR='^';
	public SecondaryOpElements getSecondaryOpAccess() {
		return eSecondaryOp;
	}
	
	public EnumRule getSecondaryOpRule() {
		return getSecondaryOpAccess().getRule();
	}
	
	//enum PrimaryOp:
	//	MUL='*' |
	//	DIV='/' |
	//	AND='&&';
	public PrimaryOpElements getPrimaryOpAccess() {
		return ePrimaryOp;
	}
	
	public EnumRule getPrimaryOpRule() {
		return getPrimaryOpAccess().getRule();
	}
	
	//terminal ASSIGNMENT_OP:
	//	'=';
	public TerminalRule getASSIGNMENT_OPRule() {
		return tASSIGNMENT_OP;
	}
	
	//terminal NEWLINE:
	//	'\n';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
