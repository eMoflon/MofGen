/*
 * generated by Xtext 2.20.0
 */
package org.moflon.mofgen.generator

import java.io.FileNotFoundException
import java.util.ArrayDeque
import java.util.Collection
import java.util.function.Consumer
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IWorkspace
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.IConfigurationElement
import org.eclipse.core.runtime.ISafeRunnable
import org.eclipse.core.runtime.Platform
import org.eclipse.core.runtime.SafeRunner
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.moflon.mofgen.mGLang.MofgenFile

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MGLangGenerator extends AbstractGenerator {

override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().put("xmi", new XMIResourceFactoryImpl())
		val rs = new ResourceSetImpl;
		rs.getResourceFactoryRegistry().getExtensionToFactoryMap().put("xmi", new XMIResourceFactoryImpl())
		val model = resource.contents.get(0) as MofgenFile;
		val output = rs.createResource(URI.createURI(resource.URI.trimFileExtension+".xmi"))
		output.contents.add(model)
		EcoreUtil.resolveAll(output)

		println("Running Mofgen-Builder extensions...")
		val workspace = getWorkspace()
		val project = getProjectOfResource(workspace, output)
		if(project === null)
			throw new FileNotFoundException("Could not find xtext model file: "+ output.URI.path)
			
		runBuilderExtensions([ext | ext.run(project)])
	}
	
	def static IWorkspace getWorkspace() {
		return ResourcesPlugin.getWorkspace()
	}
	
	def static IProject getProjectOfResource(IWorkspace workspace, Resource resource) {
		if(resource.URI.segmentCount<2)
				return null;
				
		for(project : workspace.root.projects) {
			val projectName = resource.URI.segment(1)
			if(project.name.equalsIgnoreCase(projectName)) {
				return project;
			}
		}
		
		return null;
	}
	
	def static void runBuilderExtensions(Consumer<MofgenBuilderExtension> action) {
		val ISafeRunnable runnable = new ISafeRunnable() {
			
			override handleException(Throwable e) {
				System.err.println(e.getMessage())
			}
			
			override run() throws Exception {
				collectExtensions(MofgenBuilderExtension.BUILDER_EXTENSON_ID, "class", typeof(MofgenBuilderExtension))
						.forEach(action);
			}

		};
		SafeRunner.run(runnable);
	}
	
	/**
	 * Collects all registered extensions with the given ID.
	 * 
	 * @param extensionID
	 *            the ID of the extension
	 * @param property
	 *            the name of the property
	 * @param extensionType
	 *            the extension type
	 * @return all extensions with the given ID as extensions of the given type
	 */
	def static <T> Collection<T> collectExtensions(String extensionID, String property, Class<T> extensionType) {
		val extensions = new ArrayDeque<T>();
		val config = Platform.getExtensionRegistry().getConfigurationElementsFor(extensionID);
		try {
			for (IConfigurationElement e : config) {
				val o = e.createExecutableExtension(property);
				if (extensionType.isInstance(o)) {
					extensions.add(extensionType.cast(o));
				}
			}
		} catch (CoreException ex) {
			System.err.println(ex.message)
		}

		return extensions;
	}
}
